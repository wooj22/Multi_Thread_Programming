# 멀티스레드 프로그래밍 필기 시험  

## 문제 1. 커널(Kernel)의 역할에 대해서 설명해주세요
커널은 소프트웨어와 하드웨어의 중계자 역할로 하드웨어에 직접 접근할 수 있는 권한을 가지며, 응용 프로그램에 시스템 콜을 제공하여 로우 레벨의 작업을 대신 수행해줍니다.
커널은 프로세스와 스레드 관리(스케줄링), 메모리 관리, 네트워크 관리, 파일시스템 관리, 디바이스 관리 등의 역할을 담당합니다.




## 문제 2. 유저 모드(User Mode)와 커널 모드(Kernel Mode)의 차이를 설명하고, 전환이 발생하는 상황을 예를 들어주세요
유저모드는 일반적인 응용 프로그램이 실행되는 단계이며, 커널모드는 커널이 실행되는 단계를 의미합니다. 유저모드에서는 가상 메모리 영역만 접근이 가능하고 CPU의 모든 명령어를 사용할 수 없습니다. 반면에 커널 모드는 모든 메모리 영역에 직접 접근이 가능하고 CPU의 특권 명령어를 모두 실행할 수 있습니다. 즉, 유저모드는 안전하지만 제한적인 환경이라면 커널 모드는 강력하지만 위험한 환경이라고 할 수 있습니다. 때문에 I/O, 스레드 생성 등 로우 레벨의 작업은 모두 내부적으로 커널 모드로 전환되어 수행됩니다.



  
## 문제 3. 컨텍스트 스위칭(Context Switching)의 개념과 성능에 미치는 영향을 설명해주세요
컨텍스트 스위칭이란 CPU가 현재 실행중인 작업(프로세스나 스레드)의 자원 할당을 멈추고, 다른 작업을 복원하여 수행하는 전환 과정을 의미합니다. 이때 메모리 복원 비용, 커널모드 전환 비용, 캐시미스 비용(가장 큼)이 발생하므로 잦은 컨텍스트 스위칭은 성능에 안좋은 영향을 줄 수 있습니다.


  
  
## 문제 4. Windows의 선점형 멀티태스킹(preemptive multitasking)의 특징을 설명해주세요 
중요한 작업의 요청이 들어왔거나, 높은 우선순위의 프로세스가 실행 준비 상태가 되었을 때 현재 실행중인 프로세스의 우선순위가 낮다면 현재 작업을 중단시키고 CPU를 할당받는 것을 의미합니다. 만약 낮은 우선순위의 작업이 계속해서 선점을 당한다면 기아 상태에 빠질 수 있습니다.


  
  
## 문제 5. 코드에서 `join()` API를 호출하는 주된 역할이 무엇인지 설명해주세요

```cpp
t1.join();
t2.join();
```
  
**답:**
스레드가 종료될때까지 대기합니다. join()을 호출하지 않으면 스레드 실행중 프로그램이 종료될 수 있어 작업이 안전하게 종료되지 않을 수 있습니다.
  
    


## 문제 6. 코드의 (A) 지점에서 `std::this_thread::yield()` API를 사용하는 이유가 무엇인지 설명해주세요

```cpp
while (!ready.load(std::memory_order_acquire)) {
    if (spins < 100) {
        ++spins;
    } else {
        std::this_thread::yield(); // (A)
    }
}
```
  
**답:**
yield()는 CPU 자원을 양보할 수 있게 합니다. spin의 경우 루프를 돌며 대기를 하는데, 이 시간이 오래되면 중요한 작업이 아닌 것에 CPU를 잡아먹게 되는 것이므로, 다른 작업에 CPU를 양보하기 위해 yield()를 사용합니다.
    


## 문제 7. 코드의 `mtx.try_lock()` API는 `mtx.lock()`과 어떻게 다르게 동작하는지 설명해주세요  

```cpp
if (mtx.try_lock()) {
    // ...
    mtx.unlock();
} else {
    // ...
}
```

위 

**답:**
lock()은 락을 획득할 수 있을 때 까지 대기하지만, try_lock()은 락 획득을 시도해보고 실패한다면 다음으로 넘어갑니다.
   



## 문제 8. `safe_function` 함수는 내부에서 코드가 실행 중에 예외가 발생할 수도 있다. `std::lock_guard`를 사용함으로서 왜 좋은지를 설명해주세요. 
  
```cpp
// 예외가 발생할 수도 있다.
void safe_function() {
    std::lock_guard<std::mutex> lock(mtx);
    // ....  
} 
```


**답:**
락을 획득하고 해제하지 않은 상태에서 예외가 발생하면, 이 mutex를 기다리는 다른 스레드들은 영원히 락 획득을 기다리게 됩니다. 
lock_guard는 RAII패턴으로 소멸자에서 unlock()을 호출하여 안전하게 lock을 사용할 수 있습니다.
  
  
 

## 문제 9. 코드에서 `std::unique_lock` 생성자에 `std::defer_lock` API 태그를 전달하는 이유가 무엇인지 설명하는 문제이다.

```cpp
std::unique_lock<std::mutex> lock(mtx_, std::defer_lock);
// ...
lock.lock(); 
```

**답:**
std::unique_lock<std::mutex> lock(mtx_)는 선언과 동시에 lock()을 시도합니다. 
이때 std::defer_lock 태그를 함께 전달하면 잠금 상태가 아닌 unique_lock객체의 생성이 가능하여 잠금 지연처리가 가능해집니다.


  
    
## 문제 10. 코드에서 (B)가 아닌 (A) 방식을 사용해야하는 이유를 설명해주세요  

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>

std::mutex mtx;
std::condition_variable cv;
std::queue<int> data_queue;

void consumer() {
    std::unique_lock<std::mutex> lock(mtx);

    // (A)
    cv.wait(lock, []{ return !data_queue.empty(); });

    // (B)
    // while (data_queue.empty()) {
    //     cv.wait(lock);
    // }

    int data = data_queue.front();
    data_queue.pop();
    std::cout << "Consumed: " << data << std::endl;
}
```

**답:**
조건변수는 공유할 상태의 신호를 공유하는 객체로, 상태의 값까지 담지는 못합니다. 
cv.wait(lock)을 할 경우, notify로 스레드가 깨어나더라도 조건변수의 특성에 따라 다시 lock을 반납하고 대기상태에 들어갑니다.
cv.wati(lock, 조건상태)에 조건상태가 true가 될 때에 다시 락을 획득하여 대기를 멈추므로, 조건변수는 조건 상태를 반환하는 함수를 함께 사용해야합니다.


  

## 문제 11. `std::unique_lock`의 `unlock()` API를 수동으로 호출하는 것이 `std::lock_guard`에 비해 가지는 이점이 무엇인지 설명해주세요.
  
```cpp
std::unique_lock<std::mutex> lock(mtx_);
// ... (임계 영역 1)
lock.unlock(); 
// ... (락이 필요 없는 긴 작업)
lock.lock();
// ... (임계 영역 2)
```

**답:**
lock_guard는 RAII패턴에 충실하게 소멸자에서만 unlock()을 호출하는 반면, unique_lock은 사용자가 원하는 타이밍에 unlock()을 호출할 수 있어 잠금을 더욱 유연하게 사용할 수 있습니다.
간단한 작업의 경우 lock_guard를 사용하는것이 빠르지만, 위 코드와 같이 임계구역과 사이에 비 임계구역이 길게 있는 경우에는 unique_lock()을 사용하면 그 사이에 다른 스레드들이 lock을 획득하여 작업을 진행할 수 있게 때문에 성능에 좋은 영향을 미칩니다.


      
  
## 문제 12. `std::shared_mutex`를 사용하면서, `get` 함수는 `std::shared_lock` API를, `put` 함수는 `std::unique_lock` API를 사용하는 이유를 설명해주세요.  
  
```cpp
// 읽기 작업 (get)
std::shared_lock<std::shared_mutex> lock(mutex_);
// 쓰기 작업 (put)
std::unique_lock<std::shared_mutex> lock(mutex_);
```

**답:**
  읽기 작업은 동시에 여러 스레드가 접근하여도 데이터가 무결하지만, 쓰기 작업의 경우 여러 스레드가 접근한다면 경쟁조건 문제가 발생할 수 있습니다.
  shared_mutex는 이러한 점을 고려하여 읽기 락과 쓰기 락을 분리하고 쓰기락에만 독점권을 부여한 mutex입니다.
  읽기 작업의 임계구역에서는 shared_lock을 통한 잠금으로 여러 shared_lock들이 동시에 접근하는 것을 허락하며, 쓰기 작업의 임계구역에서는 unique_lock을 통한 잠금으로 다른 모든 스레드들의 동시 접근을 막고, 독점 락을 부여합니다.


 
  
## 문제 13. (A) 지점에서는 `add` 함수가 이미 `mtx` 락을 소유한 상태에서, 내부적으로 `add_internal` 함수를 호출하여 동일한 `mtx` 락을 다시 획득하려 시도하고 있다. 이때 `std::mutex` 대신 `std::recursive_mutex` API를 사용해야 하는 이유가 무엇인지 설명해주세요   
  
```cpp
class Counter {
    std::recursive_mutex mtx;
    void add_internal(int x) {
        std::lock_guard<std::recursive_mutex> lock(mtx);
        // ...
    }
public:
    void add(int x) {
        std::lock_guard<std::recursive_mutex> lock(mtx);
        add_internal(x); // (A)
    }
};
```

**답:**  



   
  
## 문제 14. `std::jthread`가 기존 `std::thread`와 비교하여 가지는 주요 개선점을 설명해주세요.
  
**답:**
jthread는 소멸자에서 join()을 호출하여 안전하게 스레드가 종료되도록 하는 RAII 패턴의 스레드입니다. 
jthread는 stop_token과 stop_source를 지원하여 스레드의 종료 신호를 주고받을 수 있으며, request_stop()을 통해 스레드를 종료시킬 수 있습니다.
  



  
    
## 문제 15. 메모리 오더 방식 중 가장 안전한 오더가 무엇이고, 이유를 설명해주세요  
- `memory_order_relaxed`
- `memory_order_acquire` / `memory_order_release`
- `memory_order_seq_cst`
- `memory_order_acq_rel`
  
**답:** 
  memory_order_seq_cst이 가장 안전한 오더 방식입니다. memory_order_seq_cst는 원자성을 보장할 뿐만 아니라, 스레드의 실행 순서까지 완벽하게 보장합니다.


  
  
## 문제 16: 스레드 생성과 매개변수 전달 (람다)
메인 스레드에서 `std::vector<int>`를 하나 생성합니다. 람다 표현식을 사용하여 새 스레드를 생성하고, 이 벡터의 참조를 람다에 캡처하여 전달하세요. 새 스레드는 1초 대기 후, 캡처한 벡터에 정수 3개를 (예: 10, 20, 30) `push_back` 해야 합니다. 메인 스레드는 스레드가 종료될 때까지 대기하고, 벡터의 최종 내용을 출력하여 3개의 정수가 올바르게 추가되었는지 확인하세요.  
`//TODO`에 코드를 만들어주세요

```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <chrono>

int main() {
    std::vector<int> myVector = {1, 2, 3};
    std::cout << "Main: Vector 초기 상태: " << myVector.size() << "개" << std::endl;

    // 람다 표현식으로 스레드 생성.
    // [&]를 사용하여 myVector의 참조를 캡처합니다.
    std::thread t1([&myVector]() {
        std::cout << "Thread: 1초 대기..." << std::endl;
        std::this_thread::sleep_for(std::chrono::seconds(1));
        
        std::cout << "Thread: 데이터 추가..." << std::endl;
        myVector.push_back(10);
        myVector.push_back(20);
        myVector.push_back(30);
    });

    // 스레드가 작업을 완료할 때까지 대기
    t1.join();

    std::cout << "Main: 스레드 종료됨. 최종 Vector 내용:" << std::endl;
    for (int val : myVector) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
```
  
**답:**

  





## 문제 17. RAII를 사용한 스레드 자동 Join
`std::thread` 객체는 소멸될 때 `join()`이나 `detach()`가 호출되지 않으면 프로그램이 비정상 종료됩니다. 예외가 발생하더라도 스레드가 안전하게 `join()`되도록 보장하는 `ThreadGuard` 클래스를 RAII 패턴으로 구현해주세요.

**실습 코드:**

```cpp
#include <iostream>
#include <thread>
#include <stdexcept>

class ThreadGuard {
private:
    std::thread& t_;
public:
    explicit ThreadGuard(std::thread& t) : t_(t) {}
    
    ~ThreadGuard() {
        // TODO: 스레드가 join 가능한 상태라면(joinable),
        // 자동으로 join()을 호출하도록 코드를 작성하세요.
        if (t_.joinable()) {
           t_.join();
        }
    }
    
    // 복사 및 대입 방지
    ThreadGuard(const ThreadGuard&) = delete;
    ThreadGuard& operator=(const ThreadGuard&) = delete;
};

void shortTask() {
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    std::cout << "Task finished" << std::endl;
}

int main() {
    try {
        std::thread t(shortTask);
        // TODO: ThreadGuard 객체를 생성하여 t를 관리하세요.
        ThreadGuard threadGuard(t);
        
        throw std::runtime_error("Simulated error!"); // 강제 예외 발생
        
    } catch (const std::exception& e) {
        std::cout << "Caught exception: " << e.what() << std::endl;
    }
    // 예외가 발생했더라도, ThreadGuard의 소멸자 덕분에
    // "Task finished"가 "Caught exception..." 보다 먼저 또는 동시에 출력되어야 한다.
    return 0;
}
```

 **답:**





## 문제 18. 스레드 안전한 카운터 만들기
아래 코드에서 `std::atomic`을 스레드 세이프하게 counter 변수를 계산합니다. 아래의 코드에서 `//TODO` 부분에 들어가 코드를 작성하세요

```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <atomic>

// 스레드간 공유될 원자적 카운터
std::atomic<int> counter{0};

void increment() {
    for (int i = 0; i < 100000; ++i) {
        // counter의 값을 1 증가 시킵니다.
        counter++;
    }
}

int main() {
    std::vector<std::thread> threads;
    
    // 10개의 스레드 생성
    for (int i = 0; i < 10; ++i) {
        threads.emplace_back(increment);
    }
    
    // 모든 스레드가 종료될 때까지 대기
    for (auto& t : threads) {
        t.join();
    }
    
    std::cout << "예상 결과: " << 1000000 << "\n";
    // counter.load()를 사용하거나 암시적 변환을 통해 값을 읽을 수 있습니다.
    std::cout << "실제 결과: " << counter << "\n";
    
    return 0;
}
```
  
**답:**

  


  
## 문제 19: 작업 교환
단 하나의 작업(task)을 나타내는 `std::atomic<int> task_id{100}` 변수가 있습니다. 여러 개의 워커(worker) 스레드가 이 작업을 가져가려고 시도합니다. 단 하나의 스레드만 원래 값(100)을 가져가고, `task_id`를 0 (작업 완료)으로 설정하도록 구현하세요. 작업을 가져간 스레드는 "스레드 [ID]가 작업 [작업 ID]를 가져감"을 출력하고, 나머지는 "스레드 [ID]가 작업에 실패함"을 출력하세요.
  
```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <atomic>

std::atomic<int> task_id{100}; // 초기 작업 ID

void worker_thread() {
    // 0으로 값을 교환하고 이전 값을 반환받음
    int old_task = task_id.exchange(0);
    
    if (old_task == 100) {
        std::cout << "스레드 " << std::this_thread::get_id() 
                  << "가 작업 " << old_task << "를 가져감\n";
    } else {
        std::cout << "스레드 " << std::this_thread::get_id() 
                  << "가 작업에 실패함\n";
    }
}

int main() {
    std::vector<std::thread> threads;
    for (int i = 0; i < 5; ++i) {
        threads.emplace_back(worker_thread);
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    return 0;
}
```  
  
**답:**

  






## 문제 20. 
`std::atomic<int> value{10}`가 있습니다. 스레드에서 `value`의 현재 값이 10일 경우에만 20으로 갱신하는 코드를 작성하세요. `CAS 함수를`을 사용하세요.

1.  값이 10이어서 갱신에 성공하면 "성공: 10 -> 20"을 출력하세요.
2.  다른 스레드가 값을 먼저 변경(예: 15)하여 갱신에 실패하면, "실패: 현재 값 [실제 값]"을 출력하세요.

```cpp
#include <iostream>
#include <atomic>
#include <thread>

std::atomic<int> value{10};

void update_value() {
    int expected = 10;
    int desired = 20;
    
    if (value.compare_exchange_strong(expected, desired)) {
        std::cout << "성공: 10 -> " << desired << "\n";
    } else {
        // 이 시점에서 expected 변수는 value의 현재 값(10이 아닌 값)으로 
        // 갱신되었습니다.
        std::cout << "실패: 현재 값 " << expected << "\n";
    }
}

int main() {
    std::thread t1(update_value);
    t1.join();
    
    // 실패 케이스 테스트 (선택 사항)
    // value.store(15); // 값을 미리 변경
    // std::thread t2(update_value);
    // t2.join(); 
    
    return 0;
}
```  
  
**답:**  
    









    