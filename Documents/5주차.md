# 5ì£¼ì°¨: Win32 ìŠ¤ë ˆë“œ í”„ë¡œê·¸ë˜ë° 3 - ê³ ê¸‰ ë™ê¸°í™” ê¸°ë²• 1
  
## 1. íë¦„ ì œì–´(Flow Control) ê°œë…
ìŠ¤ë ˆë“œ í”„ë¡œê·¸ë˜ë°ì—ì„œ **íë¦„ ì œì–´(Flow Control)** ëŠ” ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ì‹¤í–‰ë  ë•Œ ì‘ì—…ì˜ **ì‹¤í–‰ ìˆœì„œ, ì†ë„, ë™ê¸°í™” ë°©ì‹**ì„ ì¡°ì ˆí•˜ëŠ” ê°œë…ì„ ë§í•œë‹¤.

### 1.1 íë¦„ ì œì–´ì˜ í•„ìš”ì„±
ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì€ ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤.

* **ê²½ìŸ ì¡°ê±´(Race Condition)**: ë‘ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ê³µìœ  ìì›ì— ì ‘ê·¼í•  ë•Œ ì˜ëª»ëœ ê°’ì´ ë°œìƒ
* **êµì°© ìƒíƒœ(Deadlock)**: ìŠ¤ë ˆë“œë“¤ì´ ì„œë¡œ ìì›ì„ ê¸°ë‹¤ë¦¬ë©° ë¬´í•œ ëŒ€ê¸°
* **ê¸°ì•„ ìƒíƒœ(Starvation)**: íŠ¹ì • ìŠ¤ë ˆë“œê°€ ìš°ì„ ìˆœìœ„ë‚˜ ìŠ¤ì¼€ì¤„ë§ ë•Œë¬¸ì— ì‹¤í–‰ ê¸°íšŒë¥¼ ì–»ì§€ ëª»í•¨
* **ì†ë„ ë¶ˆê· í˜•**: ì–´ë–¤ ìŠ¤ë ˆë“œëŠ” ë„ˆë¬´ ë¹¨ë¦¬, ì–´ë–¤ ìŠ¤ë ˆë“œëŠ” ë„ˆë¬´ ëŠë¦¬ê²Œ ì‹¤í–‰ë˜ì–´ ì‹œìŠ¤í…œ ë³‘ëª©ì´ ë°œìƒ

#### ê²½ìŸ ì¡°ê±´ (Race Condition) ì˜ˆì‹œ
* ì˜¨ë¼ì¸ ê²Œì„ í´ë¼ì´ì–¸íŠ¸ì—ì„œ **ìºë¦­í„°ì˜ HP(ì²´ë ¥) ê°’**ì„ ê´€ë¦¬í•œë‹¤ê³  í•˜ì.
* í•œ ìŠ¤ë ˆë“œëŠ” **ë„¤íŠ¸ì›Œí¬ ìˆ˜ì‹  ìŠ¤ë ˆë“œ**ì—ì„œ "ëª¬ìŠ¤í„°ì—ê²Œ ê³µê²©ë‹¹í•¨ â†’ HP -10" íŒ¨í‚·ì„ ì²˜ë¦¬í•˜ê³ ,
* ë™ì‹œì— ë‹¤ë¥¸ ìŠ¤ë ˆë“œëŠ” **UI ë Œë”ë§ ìŠ¤ë ˆë“œ**ì—ì„œ "ì²´ë ¥ íšŒë³µ ì•„ì´í…œ ì‚¬ìš© â†’ HP +20" ì´ë²¤íŠ¸ë¥¼ ì ìš©í•˜ë ¤ê³  í•œë‹¤.
* ë§Œì•½ ì´ ë‘ ì—°ì‚°ì´ ë™ê¸°í™” ì—†ì´ ë™ì‹œì— ì‹¤í–‰ë˜ë©´, ê²°ê³¼ê°€ ë®ì–´ì“°ê¸° ë˜ì–´ **HP ê°’ì´ -10 ë˜ëŠ” +20 ì¤‘ í•˜ë‚˜ë§Œ ë°˜ì˜**ë˜ëŠ” ì˜ëª»ëœ ê²°ê³¼ê°€ ë‚˜ì˜¨ë‹¤.

ğŸ‘‰ **ë¬¸ì œ:** í”Œë ˆì´ì–´ì˜ HPê°€ ì‹¤ì œì™€ ë‹¤ë¥´ê²Œ ì˜ëª» í‘œì‹œë˜ê±°ë‚˜, ì„œë²„ì™€ í´ë¼ì´ì–¸íŠ¸ ë™ê¸°í™”ê°€ ê¹¨ì ¸ì„œ ì¹˜ëª…ì ì¸ ë²„ê·¸ ë°œìƒ.
  
```cpp
#include <windows.h>
#include <thread>
#include <iostream>

int playerHP = 100;

void DamageThread() {
    for (int i = 0; i < 1000; i++) {
        playerHP -= 10; // ëª¬ìŠ¤í„° ê³µê²©
    }
}

void HealThread() {
    for (int i = 0; i < 1000; i++) {
        playerHP += 10; // í¬ì…˜ ì‚¬ìš©
    }
}

int main() {
    std::thread t1(DamageThread);
    std::thread t2(HealThread);

    t1.join();
    t2.join();

    std::cout << "Final HP = " << playerHP << std::endl;
    // ì˜ˆìƒ: 100ì´ì–´ì•¼ í•˜ì§€ë§Œ Race Conditionìœ¼ë¡œ ë‹¤ë¥¸ ê°’ì´ ë‚˜ì˜¬ ìˆ˜ ìˆìŒ
    return 0;
}

```  
  

#### 2. êµì°© ìƒíƒœ (Deadlock) ì˜ˆì‹œ
* ì˜¨ë¼ì¸ ê²Œì„ í´ë¼ì´ì–¸íŠ¸ì—ì„œ **ì¸ë²¤í† ë¦¬ ê´€ë¦¬**ì™€ **ì•„ì´í…œ í€µìŠ¬ë¡¯ ì—…ë°ì´íŠ¸**ë¥¼ ì„œë¡œ ë‹¤ë¥¸ ë½ìœ¼ë¡œ ë³´í˜¸í•œë‹¤ê³  í•˜ì.
* ìŠ¤ë ˆë“œ A: ì¸ë²¤í† ë¦¬ ë½ì„ ë¨¼ì € ì¡ê³ , ê·¸ í›„ í€µìŠ¬ë¡¯ ë½ì„ ì¡ìœ¼ë ¤ í•œë‹¤.
* ìŠ¤ë ˆë“œ B: í€µìŠ¬ë¡¯ ë½ì„ ë¨¼ì € ì¡ê³ , ê·¸ í›„ ì¸ë²¤í† ë¦¬ ë½ì„ ì¡ìœ¼ë ¤ í•œë‹¤.
* ë‘ ìŠ¤ë ˆë“œê°€ ì„œë¡œ ë°˜ëŒ€ ìˆœì„œë¡œ ë½ì„ ê¸°ë‹¤ë¦¬ë©´ì„œ **ì˜ì›íˆ í’€ë¦¬ì§€ ì•ŠëŠ” êµì°© ìƒíƒœ**ê°€ ë°œìƒí•œë‹¤.

ğŸ‘‰ **ë¬¸ì œ:** ì¸ë²¤í† ë¦¬ë‚˜ í€µìŠ¬ë¡¯ UIê°€ ë©ˆì¶°ë²„ë ¤ ì‚¬ìš©ìê°€ ê²Œì„ì„ ì •ìƒì ìœ¼ë¡œ í”Œë ˆì´í•  ìˆ˜ ì—†ìŒ.
  
```cpp
#include <windows.h>
#include <thread>
#include <iostream>

CRITICAL_SECTION inventoryLock;
CRITICAL_SECTION quickslotLock;

void ThreadA() {
    EnterCriticalSection(&inventoryLock);
    Sleep(10); // ë½ì„ ì˜¤ë˜ ì¥ê³  ìˆìŒ
    EnterCriticalSection(&quickslotLock);

    std::cout << "Thread A finished" << std::endl;

    LeaveCriticalSection(&quickslotLock);
    LeaveCriticalSection(&inventoryLock);
}

void ThreadB() {
    EnterCriticalSection(&quickslotLock);
    Sleep(10); // ë½ì„ ì˜¤ë˜ ì¥ê³  ìˆìŒ
    EnterCriticalSection(&inventoryLock);

    std::cout << "Thread B finished" << std::endl;

    LeaveCriticalSection(&inventoryLock);
    LeaveCriticalSection(&quickslotLock);
}

int main() {
    InitializeCriticalSection(&inventoryLock);
    InitializeCriticalSection(&quickslotLock);

    std::thread t1(ThreadA);
    std::thread t2(ThreadB);

    t1.join();
    t2.join();

    DeleteCriticalSection(&inventoryLock);
    DeleteCriticalSection(&quickslotLock);
    return 0;
}

```  
  
#### 3. ê¸°ì•„ ìƒíƒœ (Starvation) ì˜ˆì‹œ
* ê²Œì„ í´ë¼ì´ì–¸íŠ¸ì—ì„œ **ë¦¬ì†ŒìŠ¤ ë¡œë”© ìŠ¤ë ˆë“œ**ì™€ **UI ì´ë²¤íŠ¸ ì²˜ë¦¬ ìŠ¤ë ˆë“œ**ê°€ ìˆë‹¤ê³  í•˜ì.
* ë§Œì•½ ìŠ¤ì¼€ì¤„ëŸ¬ê°€ ìš°ì„ ìˆœìœ„ë¥¼ ë¦¬ì†ŒìŠ¤ ë¡œë”© ìŠ¤ë ˆë“œì— ë†’ê²Œ ì£¼ê³ , ì´ ìŠ¤ë ˆë“œê°€ ëŠì„ì—†ì´ ëŒ€ëŸ‰ì˜ ë¦¬ì†ŒìŠ¤ë¥¼ ì½ëŠ”ë‹¤ë©´,
* ë‚®ì€ ìš°ì„ ìˆœìœ„ë¥¼ ê°€ì§„ UI ì´ë²¤íŠ¸ ì²˜ë¦¬ ìŠ¤ë ˆë“œëŠ” ì‹¤í–‰ ê¸°íšŒë¥¼ ê±°ì˜ ì–»ì§€ ëª»í•œë‹¤.
* ê·¸ ê²°ê³¼, ì‚¬ìš©ìê°€ **ë²„íŠ¼ í´ë¦­, ë©”ë‰´ ì´ë™ ë“± UI ì…ë ¥ì„ í–ˆëŠ”ë° ë°˜ì‘ì´ ê±°ì˜ ì—†ëŠ” ìƒíƒœ**ê°€ ëœë‹¤.

ğŸ‘‰ **ë¬¸ì œ:** ê²Œì„ì€ ì‹¤í–‰ ì¤‘ì´ì§€ë§Œ ìœ ì € ì¸í„°í˜ì´ìŠ¤ê°€ ë©ˆì¶˜ ê²ƒì²˜ëŸ¼ ë³´ì—¬, í”Œë ˆì´ ê²½í—˜ì´ í¬ê²Œ ì•…í™”ëœë‹¤.
  
```cpp
#include <windows.h>
#include <thread>
#include <iostream>

bool running = true;

DWORD WINAPI HighPriorityThread(LPVOID) {
    while (running) {
        // CPU ì ìœ 
    }
    return 0;
}

DWORD WINAPI LowPriorityThread(LPVOID) {
    while (running) {
        std::cout << "Low priority thread executed" << std::endl;
        Sleep(100); // ì‹¤í–‰ ê¸°íšŒê°€ ì ìŒ
    }
    return 0;
}

int main() {
    HANDLE hHigh = CreateThread(NULL, 0, HighPriorityThread, NULL, 0, NULL);
    HANDLE hLow = CreateThread(NULL, 0, LowPriorityThread, NULL, 0, NULL);

    SetThreadPriority(hHigh, THREAD_PRIORITY_HIGHEST);
    SetThreadPriority(hLow, THREAD_PRIORITY_LOWEST);

    Sleep(2000); // ì‹¤í–‰ í›„ ì ì‹œ ëŒ€ê¸°
    running = false;

    WaitForSingleObject(hHigh, INFINITE);
    WaitForSingleObject(hLow, INFINITE);
    return 0;
}

```  

#### 4. ì†ë„ ë¶ˆê· í˜• (Throughput Imbalance) ì˜ˆì‹œ
* ì˜¨ë¼ì¸ ê²Œì„ì—ì„œ **ë„¤íŠ¸ì›Œí¬ ìˆ˜ì‹  ìŠ¤ë ˆë“œ**ëŠ” ì´ˆë‹¹ ìˆ˜ë°± ê°œì˜ íŒ¨í‚·ì„ ë¹ ë¥´ê²Œ ì²˜ë¦¬í•˜ì§€ë§Œ,
* **ë Œë”ë§ ìŠ¤ë ˆë“œ**ê°€ ì´ë¥¼ ë”°ë¼ê°€ì§€ ëª»í•´ **í”„ë ˆì„ ë“œë(FPS í•˜ë½)** ì´ ë°œìƒí•œë‹¤ê³  í•˜ì.
* ì˜ˆë¥¼ ë“¤ì–´ ì±„íŒ… íŒ¨í‚·ì´ í­ì£¼í•˜ê±°ë‚˜ ëŒ€ê·œëª¨ ì „íˆ¬ ì´ë²¤íŠ¸ê°€ ë°œìƒí•  ë•Œ, ë„¤íŠ¸ì›Œí¬ëŠ” ì •ìƒì ìœ¼ë¡œ ë°ì´í„°ë¥¼ ë°›ì•„ì˜¤ì§€ë§Œ,
* ë Œë”ë§ ìŠ¤ë ˆë“œê°€ UI ì—…ë°ì´íŠ¸ë¥¼ ì œë•Œ ëª» í•´ì„œ **ì±„íŒ…ì°½ì´ ë°€ë¦¬ê±°ë‚˜ í™”ë©´ ë°˜ì‘ì´ ëŠ¦ëŠ” í˜„ìƒ**ì´ ìƒê¸´ë‹¤.

ğŸ‘‰ **ë¬¸ì œ:** í´ë¼ì´ì–¸íŠ¸ì˜ ì „ì²´ ì„±ëŠ¥ì´ íŠ¹ì • ìŠ¤ë ˆë“œ ë³‘ëª©ì— ì˜í•´ ë–¨ì–´ì§€ê³ , í”Œë ˆì´ì–´ëŠ” "ë ‰ì´ ê±¸ë¦°ë‹¤"ê³  ëŠë‚€ë‹¤.

```cpp
#include <windows.h>
#include <thread>
#include <queue>
#include <mutex>
#include <iostream>

std::queue<int> networkPackets;
std::mutex mtx;
bool running = true;

void NetworkThread() {
    int counter = 0;
    while (running) {
        std::lock_guard<std::mutex> lock(mtx);
        networkPackets.push(counter++);
        Sleep(1); // ë§¤ìš° ë¹ ë¥´ê²Œ íŒ¨í‚· ìƒì„±
    }
}

void RenderThread() {
    while (running) {
        std::lock_guard<std::mutex> lock(mtx);
        if (!networkPackets.empty()) {
            std::cout << "Render consumes packet " << networkPackets.front() << std::endl;
            networkPackets.pop();
        }
        Sleep(50); // ë Œë”ë§ ì†ë„ê°€ í›¨ì”¬ ëŠë¦¼
    }
}

int main() {
    std::thread t1(NetworkThread);
    std::thread t2(RenderThread);

    Sleep(2000); // ì‹¤í–‰
    running = false;

    t1.join();
    t2.join();
    return 0;
}
```  

>> ì†ë„ ë¶ˆê· í˜• ë¬¸ì œì˜ í•µì‹¬ í•´ê²°ì±…ì€ ìƒì‚°ì-ì†Œë¹„ì ê°„ ê· í˜•ì„ ë§ì¶”ëŠ” ê²ƒì´ë‹¤.
>> Backpressure: í í¬ê¸° ì œí•œ, ì¤‘ìš” íŒ¨í‚·ë§Œ ìœ ì§€
>> Batching/Coalescing: ì—¬ëŸ¬ íŒ¨í‚·ì„ ë¬¶ê±°ë‚˜ ìµœì‹  ìƒíƒœë§Œ ë°˜ì˜
>> Async Decoupling: ë„¤íŠ¸ì›Œí¬ ì²˜ë¦¬ì™€ ë Œë”ë§ì„ ë¶„ë¦¬
>> Load Balancing: ë©€í‹°ìŠ¤ë ˆë“œ/ë©€í‹°ì½”ì–´ í™œìš©
>> Rate Limiting: ìƒì‚° ì†ë„ë¥¼ ì†Œë¹„ì ì†ë„ì— ë§ì¶¤
  


ì´ëŸ° ë¬¸ì œë¥¼ ì˜ˆë°©í•˜ê³  íš¨ìœ¨ì ì¸ í˜‘ì—…ì„ ìœ„í•´ íë¦„ ì œì–´ê°€ í•„ìš”í•˜ë‹¤.


### 1.2 íë¦„ ì œì–´ì˜ ì£¼ìš” ë©”ì»¤ë‹ˆì¦˜

#### (1) ë™ê¸°í™”(Synchronization)
* **ëª©ì **: ê³µìœ  ìì› ì ‘ê·¼ ì‹œ ë°ì´í„° ë¬´ê²°ì„±ì„ ë³´ì¥
* **ë„êµ¬**: `Critical Section`, `Mutex`, `Semaphore`, `Event`
* **ì˜ˆì‹œ**: ìƒì‚°ì-ì†Œë¹„ì íŒ¨í„´ì—ì„œ íì— push/pop í•  ë•Œ ë™ê¸°í™” 
![](./images/212.png)   
  
#### (2) ì‹ í˜¸(Signaling)
* **ëª©ì **: ìŠ¤ë ˆë“œ ê°„ ì‘ì—… ìˆœì„œë¥¼ ë§ì¶¤
* **ë„êµ¬**: `Event`, `Condition Variable`
* **ì˜ˆì‹œ**: "ìƒì‚°ìê°€ ë°ì´í„°ë¥¼ ë„£ìœ¼ë©´ â†’ ì†Œë¹„ìì—ê²Œ ì‹ í˜¸ ë³´ë‚´ì„œ ì²˜ë¦¬ ì‹œì‘"
![](./images/214.png)     

#### (3) ìŠ¤ì¼€ì¤„ë§(Scheduling)
* **ëª©ì **: ì–´ë–¤ ìŠ¤ë ˆë“œê°€ ì–¸ì œ ì‹¤í–‰ë ì§€ ê²°ì •
* **ë„êµ¬**: OS ìŠ¤ì¼€ì¤„ëŸ¬, `Sleep`, ìš°ì„ ìˆœìœ„ ì„¤ì •
* **ì˜ˆì‹œ**: ë Œë”ë§ ìŠ¤ë ˆë“œëŠ” 16msë§ˆë‹¤ ì‹¤í–‰ë˜ë„ë¡ ì¡°ì •
![](./images/215.png)     

#### (4) ì†ë„ ì¡°ì ˆ(Rate Limiting / Throttling)
* **ëª©ì **: ê³¼ë„í•œ ì‘ì—… ì‹¤í–‰ì„ ë§‰ê³  ê· í˜• ìœ ì§€
* **ë„êµ¬**: í ë²„í¼ í¬ê¸° ì œí•œ, ì„¸ë§ˆí¬ì–´
* **ì˜ˆì‹œ**: ë„¤íŠ¸ì›Œí¬ íŒ¨í‚· ìˆ˜ì‹  ì†ë„ê°€ ë„ˆë¬´ ë¹ ë¥´ë©´ ë²„í¼ë¥¼ ì œí•œí•˜ì—¬ ì†Œë¹„ ìŠ¤ë ˆë“œê°€ ë”°ë¼ì˜¬ ìˆ˜ ìˆë„ë¡ ì œì–´
![](./images/216.png)     

#### (5) íŒŒì´í”„ë¼ì¸ ì œì–´(Pipeline Flow Control)
* **ëª©ì **: ì—¬ëŸ¬ ë‹¨ê³„ë¡œ ë¶„ë¦¬ëœ ì‘ì—… íë¦„ì—ì„œ ë³‘ëª© ë°©ì§€
* **ë„êµ¬**: ë‹¨ê³„ë³„ í, ì´ë²¤íŠ¸, ì„¸ë§ˆí¬ì–´
* **ì˜ˆì‹œ**: ë¦¬ì†ŒìŠ¤ ë¡œë“œ â†’ ë””ì½”ë”© â†’ ë Œë”ë§ ë‹¨ê³„ì—ì„œ ì• ë‹¨ê³„ê°€ ë„ˆë¬´ ë¹¨ë¼ì„œ ë’·ë‹¨ê³„ê°€ ì²˜ë¦¬ ë¶ˆê°€í•˜ë©´ íë¦„ì„ ë©ˆì¶¤
![](./images/217.png)     

  
### 1.3 ê²Œì„ ê°œë°œì—ì„œ íë¦„ ì œì–´ í™œìš© ì˜ˆì‹œ
* **ë„¤íŠ¸ì›Œí¬ íŒ¨í‚· ì²˜ë¦¬**
  * ì„œë²„ì—ì„œ ì˜¤ëŠ” íŒ¨í‚·ì€ ë§¤ìš° ë¹ ë¦„
  * ê²Œì„ ë¡œì§ ìŠ¤ë ˆë“œê°€ ëª¨ë‘ ì²˜ë¦¬í•˜ì§€ ëª»í•˜ë©´ ë²„í¼ ì˜¤ë²„í”Œë¡œìš° ë°œìƒ
  * ë”°ë¼ì„œ **í í¬ê¸° ì œí•œ + ì´ë²¤íŠ¸ ì‹ í˜¸**ë¡œ íë¦„ ì œì–´

* **ì• ë‹ˆë©”ì´ì…˜ íŒŒì´í”„ë¼ì¸**
  * Stage1(ëª¨ë¸ ë¡œë”©) â†’ Stage2(ì• ë‹ˆë©”ì´ì…˜ ê³„ì‚°) â†’ Stage3(ë Œë”ë§)
  * Stage2ê°€ ëŠë ¤ì§€ë©´ Stage1ì—ì„œ ë°ì´í„°ë¥¼ ì œí•œí•´ì•¼ ì „ì²´ í”„ë ˆì„ ìœ ì§€

* **ë©€í‹°ì½”ì–´ AI ì—°ì‚°**
  * ì—¬ëŸ¬ AI ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ê²½ë¡œ íƒìƒ‰(Pathfinding)ì„ ìˆ˜í–‰
  * ì¤‘ì•™ íì—ì„œ ìš”ì²­ì„ ë¶„ë°°í•˜ê³ , ì„¸ë§ˆí¬ì–´ë¡œ "í•œ ë²ˆì— ëª‡ ê°œê¹Œì§€ ì‹¤í–‰ ê°€ëŠ¥"ì„ ì œí•œ

### 1.4 ìš”ì•½
* **íë¦„ ì œì–´(Flow Control)** = ìŠ¤ë ˆë“œ ê°„ ì‹¤í–‰ ì†ë„, ìˆœì„œ, ìì› ì‚¬ìš©ì„ ì¡°ì ˆí•˜ëŠ” ë©”ì»¤ë‹ˆì¦˜
* ì£¼ìš” ë„êµ¬: **Critical Section, Mutex, Semaphore, Event, Condition Variable**
* ê²Œì„ ê°œë°œì—ì„œëŠ” **ë„¤íŠ¸ì›Œí¬ ì²˜ë¦¬, ë Œë”ë§ íŒŒì´í”„ë¼ì¸, AI ê³„ì‚°** ë“±ì—ì„œ í•µì‹¬ì ìœ¼ë¡œ í™œìš©


### 1.5 ì‹¤ìŠµ: ì„¸ë§ˆí¬ì–´ë¡œ ì‘ì—… ì†ë„ë¥¼ ì œì–´(Rate Limiting)  
  
```cpp  
#include <windows.h>
#include <iostream>
#include <queue>
#include <string>
#include <process.h> // _beginthreadex, _endthreadex

// =================================================================
// ì „ì—­ ë³€ìˆ˜ ë° ë™ê¸°í™” ê°ì²´
// =================================================================

// ì‘ì—…ì„ ì €ì¥í•  ê³µìœ  í
std::queue<std::string> g_taskQueue;

// ê³µìœ  íì— ëŒ€í•œ ì ‘ê·¼ì„ ë™ê¸°í™”í•˜ê¸° ìœ„í•œ í¬ë¦¬í‹°ì»¬ ì„¹ì…˜
CRITICAL_SECTION g_cs;

// ì²˜ë¦¬ ê°€ëŠ¥í•œ ì‘ì—…ì˜ ìµœëŒ€ ê°œìˆ˜ë¥¼ ì œí•œí•˜ëŠ” ì„¸ë§ˆí¬ì–´
// ì´ ì„¸ë§ˆí¬ì–´ê°€ Rate Limitingì˜ í•µì‹¬ ì—­í• ì„ í•©ë‹ˆë‹¤.
HANDLE g_hSemaphore;

// ìŠ¤ë ˆë“œ ì¢…ë£Œë¥¼ ì•Œë¦¬ê¸° ìœ„í•œ í”Œë˜ê·¸
volatile bool g_bIsRunning = true;

// ë²„í¼(í)ì˜ ìµœëŒ€ í¬ê¸°. ì„¸ë§ˆí¬ì–´ì˜ ìµœëŒ€ ì¹´ìš´íŠ¸ì™€ ë™ì¼í•˜ê²Œ ì„¤ì •í•©ë‹ˆë‹¤.
const int MAX_BUFFER_SIZE = 5;


// =================================================================
// ìŠ¤ë ˆë“œ í•¨ìˆ˜
// =================================================================

/**
 * @brief ì‘ì—… ìƒì„±ì(Producer) ìŠ¤ë ˆë“œ í•¨ìˆ˜
 * ë¹ ë¥´ê²Œ ì‘ì—…ì„ ìƒì„±í•˜ì—¬ íì— ì¶”ê°€í•©ë‹ˆë‹¤.
 * @param pParam ìŠ¤ë ˆë“œì— ì „ë‹¬ë˜ëŠ” ì¸ì (ì‚¬ìš© ì•ˆ í•¨)
 * @return ìŠ¤ë ˆë“œ ì¢…ë£Œ ì½”ë“œ
 */
unsigned int __stdcall ProducerThread(void* pParam)
{
    int taskCount = 0;

    while (taskCount < 20)
    {
        // 1. ì„¸ë§ˆí¬ì–´ë¥¼ ê¸°ë‹¤ë¦½ë‹ˆë‹¤.
        //    ë§Œì•½ ì„¸ë§ˆí¬ì–´ ì¹´ìš´íŠ¸ê°€ 0ì´ë©´ (ì¦‰, íê°€ ê½‰ ì°¼ìœ¼ë©´)
        //    Consumerê°€ ì‘ì—…ì„ ì²˜ë¦¬í•˜ê³  ì„¸ë§ˆí¬ì–´ë¥¼ í•´ì œí•  ë•Œê¹Œì§€ ì—¬ê¸°ì„œ ëŒ€ê¸°í•©ë‹ˆë‹¤.
        // ì¹´ìš´íŠ¸ > 0 ì´ë©´: ì„¸ë§ˆí¬ì–´ëŠ” ì¦‰ì‹œ ì¹´ìš´íŠ¸ë¥¼ 1 ê°ì†Œì‹œí‚¤ê³  í•¨ìˆ˜ë¥¼ ë¦¬í„´í•©ë‹ˆë‹¤. ìŠ¤ë ˆë“œëŠ” ëŒ€ê¸° ì—†ì´ ë‹¤ìŒ ì½”ë“œë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.
        // ì¹´ìš´íŠ¸ == 0 ì´ë©´: ìŠ¤ë ˆë“œëŠ” ì¹´ìš´íŠ¸ê°€ 0ë³´ë‹¤ ì»¤ì§ˆ ë•Œê¹Œì§€(ì¦‰, ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ReleaseSemaphoreë¥¼ í˜¸ì¶œí•  ë•Œê¹Œì§€) ë¬´í•œì • ëŒ€ê¸°(block)í•©ë‹ˆë‹¤.
        WaitForSingleObject(g_hSemaphore, INFINITE);

        // 2. í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ì„ í†µí•´ íì— ëŒ€í•œ ì ‘ê·¼ì„ ë³´í˜¸í•©ë‹ˆë‹¤.
        EnterCriticalSection(&g_cs);

        // ì‘ì—… ìƒì„±
        taskCount++;
        std::string task = "ì‘ì—… " + std::to_string(taskCount);
        g_taskQueue.push(task);
        std::cout << "[ìƒì„±] " << task << " (í˜„ì¬ í í¬ê¸°: " << g_taskQueue.size() << ")" << std::endl;

        // 3. í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ í•´ì œ
        LeaveCriticalSection(&g_cs);

        // ë¹ ë¥¸ ì‘ì—… ìƒì„±ì„ ì‹œë®¬ë ˆì´ì…˜í•˜ê¸° ìœ„í•´ ì§§ì€ ì‹œê°„ ëŒ€ê¸°
        Sleep(100);
    }

    // ì‘ì—… ìƒì„±ì´ ì™„ë£Œë˜ë©´ Consumer ìŠ¤ë ˆë“œ ì¢…ë£Œë¥¼ ìœ„í•´ í”Œë˜ê·¸ ì„¤ì •
    g_bIsRunning = false;
    std::cout << "\n--- ëª¨ë“  ì‘ì—… ìƒì„± ì™„ë£Œ ---\n" << std::endl;
    return 0;
}

/**
 * @brief ì‘ì—… ì†Œë¹„ì(Consumer) ìŠ¤ë ˆë“œ í•¨ìˆ˜
 * íì—ì„œ ì‘ì—…ì„ ê°€ì ¸ì™€ ëŠë¦¬ê²Œ ì²˜ë¦¬í•©ë‹ˆë‹¤.
 * @param pParam ìŠ¤ë ˆë“œì— ì „ë‹¬ë˜ëŠ” ì¸ì (ì‚¬ìš© ì•ˆ í•¨)
 * @return ìŠ¤ë ˆë“œ ì¢…ë£Œ ì½”ë“œ
 */
unsigned int __stdcall ConsumerThread(void* pParam)
{
    while (g_bIsRunning || !g_taskQueue.empty())
    {
        std::string task;
        bool hasTask = false;

        // 1. í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ì„ í†µí•´ íì— ëŒ€í•œ ì ‘ê·¼ì„ ë³´í˜¸í•©ë‹ˆë‹¤.
        EnterCriticalSection(&g_cs);

        if (!g_taskQueue.empty())
        {
            task = g_taskQueue.front();
            g_taskQueue.pop();
            hasTask = true;
        }

        // 2. í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ í•´ì œ
        LeaveCriticalSection(&g_cs);


        if (hasTask)
        {
            std::cout << "    [ì²˜ë¦¬] " << task << " ì‹œì‘..." << std::endl;

            // ëŠë¦° ì‘ì—… ì²˜ë¦¬ë¥¼ ì‹œë®¬ë ˆì´ì…˜í•˜ê¸° ìœ„í•´ ê¸´ ì‹œê°„ ëŒ€ê¸°
            Sleep(500);

            std::cout << "    [ì²˜ë¦¬] " << task << " ì™„ë£Œ!" << std::endl;


            // 3. ì‘ì—… ì²˜ë¦¬ê°€ ëë‚¬ìŒì„ ì•Œë¦¬ê³ , ë¹„ì–´ìˆëŠ” ìŠ¬ë¡¯ì´ ìƒê²¼ìŒì„ ì„¸ë§ˆí¬ì–´ì— ì•Œë¦½ë‹ˆë‹¤.
            //    ì´ í˜¸ì¶œë¡œ ì¸í•´ ì„¸ë§ˆí¬ì–´ ì¹´ìš´íŠ¸ê°€ 1 ì¦ê°€í•˜ê³ ,
            //    Producer ìŠ¤ë ˆë“œê°€ ëŒ€ê¸° ì¤‘ì´ì—ˆë‹¤ë©´ ë‹¤ì‹œ ì‘ì—…ì„ ìƒì„±í•  ìˆ˜ ìˆê²Œ ë©ë‹ˆë‹¤.
            ReleaseSemaphore(g_hSemaphore, 1, NULL);
        }
        else
        {
            // ì²˜ë¦¬í•  ì‘ì—…ì´ ì—†ìœ¼ë©´ ì ì‹œ ëŒ€ê¸°
            Sleep(10);
        }
    }
    return 0;
}


// =================================================================
// Main í•¨ìˆ˜
// =================================================================

int main()
{
    HANDLE hThreads[2];
    unsigned int threadID;

    // 1. ë™ê¸°í™” ê°ì²´ ì´ˆê¸°í™”
    InitializeCriticalSection(&g_cs);

    // ì„¸ë§ˆí¬ì–´ ìƒì„±
    // ì´ˆê¸° ì¹´ìš´íŠ¸: MAX_BUFFER_SIZE (ì²˜ìŒì—ëŠ” ë²„í¼ê°€ ë¹„ì–´ìˆìœ¼ë¯€ë¡œ ìµœëŒ€ì¹˜ë§Œí¼ ì‘ì—… ìƒì„± ê°€ëŠ¥)
    // ìµœëŒ€ ì¹´ìš´íŠ¸: MAX_BUFFER_SIZE (ë²„í¼ì˜ ìµœëŒ€ í¬ê¸°)
    g_hSemaphore = CreateSemaphore(
        NULL,            // ê¸°ë³¸ ë³´ì•ˆ ì†ì„±
        MAX_BUFFER_SIZE, // ì´ˆê¸° ì¹´ìš´íŠ¸
        MAX_BUFFER_SIZE, // ìµœëŒ€ ì¹´ìš´íŠ¸
        NULL             // ì´ë¦„ ì—†ëŠ” ì„¸ë§ˆí¬ì–´
    );

    if (g_hSemaphore == NULL)
    {
        std::cerr << "ì„¸ë§ˆí¬ì–´ ìƒì„± ì‹¤íŒ¨: " << GetLastError() << std::endl;
        return 1;
    }

    std::cout << "--- ì„¸ë§ˆí¬ì–´ë¥¼ ì´ìš©í•œ ì†ë„ ì œì–´(Rate Limiting) ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘ ---" << std::endl;
    std::cout << "ìµœëŒ€ ë²„í¼ í¬ê¸°: " << MAX_BUFFER_SIZE << std::endl << std::endl;

    // 2. ìŠ¤ë ˆë“œ ìƒì„±
    hThreads[0] = (HANDLE)_beginthreadex(NULL, 0, &ProducerThread, NULL, 0, &threadID);
    hThreads[1] = (HANDLE)_beginthreadex(NULL, 0, &ConsumerThread, NULL, 0, &threadID);

    // 3. ëª¨ë“  ìŠ¤ë ˆë“œê°€ ì¢…ë£Œë  ë•Œê¹Œì§€ ëŒ€ê¸°
    WaitForMultipleObjects(2, hThreads, TRUE, INFINITE);

    std::cout << "\n--- ëª¨ë“  ì‘ì—… ì²˜ë¦¬ ì™„ë£Œ. í”„ë¡œê·¸ë¨ ì¢…ë£Œ. ---" << std::endl;

    // 4. ë¦¬ì†ŒìŠ¤ í•´ì œ
    CloseHandle(hThreads[0]);
    CloseHandle(hThreads[1]);
    CloseHandle(g_hSemaphore);
    DeleteCriticalSection(&g_cs);

    return 0;
}
```

</br>  
</br>  
  
## 2. íë¦„ ì œì–´ - ë©€í‹°ìŠ¤ë ˆë“œ íŒ¨í„´ë“¤
íë¦„ ì œì–´ê°€ í•„ìš”í•œ ëŒ€í‘œì ì¸ ìƒí™©ë“¤:
- **ìƒì‚°ì-ì†Œë¹„ì íŒ¨í„´**: ë°ì´í„°ë¥¼ ìƒì„±í•˜ëŠ” ìŠ¤ë ˆë“œì™€ ì†Œë¹„í•˜ëŠ” ìŠ¤ë ˆë“œ ê°„ì˜ ì†ë„ ì¡°ì ˆ
- **ë¦¬ë”-íŒ”ë¡œì›Œ íŒ¨í„´**: ì—¬ëŸ¬ ìŠ¤ë ˆë“œ ì¤‘ í•˜ë‚˜ë§Œ ë¦¬ë”ê°€ ë˜ì–´ ì‘ì—…ì„ ìˆ˜í–‰
- **íŒŒì´í”„ë¼ì¸ ì²˜ë¦¬**: ì—¬ëŸ¬ ë‹¨ê³„ì˜ ì‘ì—…ì„ ìˆœì°¨ì ìœ¼ë¡œ ì²˜ë¦¬


### 2.1 ìƒì‚°ì-ì†Œë¹„ì íŒ¨í„´ (Producer-Consumer)
* **ê°œë…**: ë°ì´í„°ë¥¼ ìƒì„±í•˜ëŠ” ìŠ¤ë ˆë“œ(ìƒì‚°ì)ì™€ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•˜ëŠ” ìŠ¤ë ˆë“œ(ì†Œë¹„ì)ê°€ ì„œë¡œ í˜‘ë ¥í•˜ëŠ” êµ¬ì¡°ë‹¤.
* **ë¬¸ì œ**: ìƒì‚° ì†ë„ì™€ ì†Œë¹„ ì†ë„ê°€ ë‹¤ë¥¼ ìˆ˜ ìˆê¸° ë•Œë¬¸ì— **ë²„í¼(í)** ë¥¼ ë‘ì–´ ê· í˜•ì„ ë§ì¶˜ë‹¤.
* **ë™ê¸°í™” ë„êµ¬**: `CriticalSection`ìœ¼ë¡œ í ì ‘ê·¼ ë³´í˜¸, `Event`ë¡œ ëŒ€ê¸°/ì‹ í˜¸ ì²˜ë¦¬.
 

```mermaid
flowchart LR
    P[ìƒì‚°ì ìŠ¤ë ˆë“œ] -->|ë°ì´í„° ìƒì„±| Q[ê³µìœ  ë²„í¼]
    Q -->|ë°ì´í„° ì†Œë¹„| C[ì†Œë¹„ì ìŠ¤ë ˆë“œ]
```

#### ì‹¤ìŠµ: ìƒì‚°ì-ì†Œë¹„ì íŒ¨í„´

```cpp
#include <windows.h>
#include <process.h>
#include <queue>
#include <iostream>

CRITICAL_SECTION cs;
HANDLE hEvent;
std::queue<int> buffer;

unsigned __stdcall Producer(void*) {
    for (int i = 0; i < 5; i++) {
        Sleep(500); // ìƒì‚° ì§€ì—°
        
        EnterCriticalSection(&cs);
        buffer.push(i);
        std::cout << "Produced: " << i << std::endl;
        LeaveCriticalSection(&cs);
        
        SetEvent(hEvent); // ì†Œë¹„ì ê¹¨ìš°ê¸°
    }

    return 0;
}

unsigned __stdcall Consumer(void*) {
    while (true) {
        // Producerê°€ ì•„ì´í…œì„ í•˜ë‚˜ ì´ìƒ ë„£ì—ˆë‹¤ëŠ” ì‹ í˜¸ë¥¼ ê¸°ë‹¤ë¦¼
        WaitForSingleObject(hEvent, INFINITE);

        // ê¹¨ì–´ë‚¬ìœ¼ë©´, íê°€ ì™„ì „íˆ ë¹Œ ë•Œê¹Œì§€ ëª¨ë“  ì•„ì´í…œì„ ì†Œë¹„
        EnterCriticalSection(&cs);
        while (!buffer.empty()) { // íê°€ ë¹„ì–´ìˆì§€ ì•Šì€ ë™ì•ˆ ë°˜ë³µ
            int data = buffer.front();
            buffer.pop();
            std::cout << "Consumed: " << data << std::endl;
        }
        LeaveCriticalSection(&cs);
    }
    return 0;
}
/*
unsigned __stdcall Consumer(void*) {
Â  Â  while (true) {
Â  Â  Â  Â  WaitForSingleObject(hEvent, INFINITE);

Â  Â  Â  Â  EnterCriticalSection(&cs);

Â  Â  Â  Â  if (!buffer.empty()) {

Â  Â  Â  Â  Â  Â  int data = buffer.front();

Â  Â  Â  Â  Â  Â  buffer.pop();

Â  Â  Â  Â  Â  Â  std::cout << "Consumed: " << data << std::endl;

Â  Â  Â  Â  }

Â  Â  Â  Â  LeaveCriticalSection(&cs);

Â  Â  }

Â  Â  return 0;
}
*/

int main() 
{
    InitializeCriticalSection(&cs);
    hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    _beginthreadex(NULL, 0, Producer, NULL, 0, NULL);
    _beginthreadex(NULL, 0, Consumer, NULL, 0, NULL);

    Sleep(5000);
    return 0;
}
```
  
[ë¬¸ì œ í•´ê²° ì„¤ëª…](https://docs.google.com/document/d/e/2PACX-1vRuffkZXgyAnXzcceW0D_fZZZ2xowB9q-9gyRthOG0tGDrjMfmPQrW_FuqEvtKzVGlVUNC1bf5U0vBa/pub  )  
  
 
 
#### ê²Œì„ì—ì„œ í™œìš© ì˜ˆì‹œ: ì±„íŒ… ë©”ì‹œì§€ ì²˜ë¦¬
* ë„¤íŠ¸ì›Œí¬ ìŠ¤ë ˆë“œ(ìƒì‚°ì)ê°€ ë©”ì‹œì§€ë¥¼ íì— ìŒ“ê³ ,
* ê²Œì„ ë¡œì§ ìŠ¤ë ˆë“œ(ì†Œë¹„ì)ê°€ íì—ì„œ êº¼ë‚´ í™”ë©´ì— ì¶œë ¥í•œë‹¤.


##### í”„ë¡œê·¸ë¨ íë¦„ ê°œìš”

```plaintext
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚   main.cpp   â”‚
 â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚   ChatClient.run  â”‚
 â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚  (ìŠ¤ë ˆë“œ 4ê°œ ìƒì„±)
        â”‚
   â”Œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
   â–¼    â–¼     â–¼     â–¼
Input  Sender Recv  Printer
Thread Thread Thread Thread
```

##### ë‚´ë¶€ ì²˜ë¦¬ íë¦„ (ë©”ì‹œì§€ ì „ì†¡ ê²½ë¡œ)

```plaintext
   [ì½˜ì†” ì…ë ¥]
        â”‚
        â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ InputThread      â”‚
 â”‚ (ìƒì‚°ì)          â”‚
 â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ enqueue
       â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ OutQ (RingQueue) â”‚
 â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ dequeue
       â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ SenderThread     â”‚
 â”‚ (ì†Œë¹„ì)          â”‚
 â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ send()
       â–¼
   [ì„œë²„ ì „ì†¡]
```


##### ë‚´ë¶€ ì²˜ë¦¬ íë¦„ (ë©”ì‹œì§€ ìˆ˜ì‹  ê²½ë¡œ)

```plaintext
   [ì„œë²„ ìˆ˜ì‹  ë°ì´í„°]
        â”‚
        â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ RecvThread       â”‚
 â”‚ (ìƒì‚°ì)          â”‚
 â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ enqueue
       â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ InQ (RingQueue)  â”‚
 â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ dequeue
       â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ PrintThread      â”‚
 â”‚ (ì†Œë¹„ì)          â”‚
 â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â–¼
   [ì½˜ì†” ì¶œë ¥]
```


##### ì¢…ë£Œ íë¦„

```plaintext
ì‚¬ìš©ìê°€ "/quit" ì…ë ¥
         â”‚
         â–¼
 InputThread â†’ shutdown Event set
         â”‚
         â–¼
 ëª¨ë“  ìŠ¤ë ˆë“œ WaitForMultipleObjectsë¡œ
 shutdown ê°ì§€ â†’ ì•ˆì „í•˜ê²Œ ì¢…ë£Œ
```
  
  
* **ë‘ ê°œì˜ RingQueue**(`outQ`, `inQ`)ê°€ ì¤‘ì‹¬
* `InputThread`ì™€ `SenderThread`ê°€ **ì¶œë ¥ ê²½ë¡œ(ìƒì‚°ìâ†’ì†Œë¹„ì)**
* `RecvThread`ì™€ `PrintThread`ê°€ **ì…ë ¥ ê²½ë¡œ(ìƒì‚°ìâ†’ì†Œë¹„ì)**
* ì¢…ë£ŒëŠ” **shutdown ì´ë²¤íŠ¸**ë¡œ ëª¨ë“  ìŠ¤ë ˆë“œì— ë™ì‹œì— ì „ë‹¬
  
  
```mermaid
sequenceDiagram
    participant U as ì‚¬ìš©ì
    participant I as InputThread
    participant O as OutQ
    participant S as SenderThread
    participant SV as ì„œë²„
    participant R as RecvThread
    participant IN as InQ
    participant P as PrintThread
    participant C as ì½˜ì†”
    participant E as shutdownEvent

    %% ì†¡ì‹  ê²½ë¡œ
    U->>I: ì½˜ì†” ì…ë ¥
    I->>O: ë©”ì‹œì§€ enqueue
    O->>S: ë©”ì‹œì§€ dequeue
    S->>SV: send()

    %% ìˆ˜ì‹  ê²½ë¡œ
    SV->>R: ë©”ì‹œì§€ ìˆ˜ì‹ 
    R->>IN: ë©”ì‹œì§€ enqueue
    IN->>P: ë©”ì‹œì§€ dequeue
    P->>C: ì½˜ì†” ì¶œë ¥

    %% ì¢…ë£Œ ì‹œë‚˜ë¦¬ì˜¤
    U->>I: "/quit" ì…ë ¥
    I->>E: shutdown ì´ë²¤íŠ¸ set
    E->>I: ì¢…ë£Œ ê°ì§€
    E->>S: ì¢…ë£Œ ê°ì§€
    E->>R: ì¢…ë£Œ ê°ì§€
    E->>P: ì¢…ë£Œ ê°ì§€
    I-->>I: ìŠ¤ë ˆë“œ ì¢…ë£Œ
    S-->>S: ìŠ¤ë ˆë“œ ì¢…ë£Œ
    R-->>R: ìŠ¤ë ˆë“œ ì¢…ë£Œ
    P-->>P: ìŠ¤ë ˆë“œ ì¢…ë£Œ
```  



### 2.2 ë¦¬ë”-íŒ”ë¡œì›Œ íŒ¨í„´ (Leader-Follower)
ë¦¬ë”-íŒ”ë¡œì›Œ íŒ¨í„´ì˜ í•µì‹¬ ì•„ì´ë””ì–´ëŠ” ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ì´ë²¤íŠ¸ë¥¼ ê¸°ë‹¤ë¦¬ë©´ì„œ ë°œìƒí•˜ëŠ” ë¹„íš¨ìœ¨(Thundering Herd Problem)ì„ ë§‰ëŠ” ê²ƒì´ë‹¤.  
ì˜¤ì§ í•˜ë‚˜ì˜ 'ë¦¬ë”' ìŠ¤ë ˆë“œë§Œì´ ì´ë²¤íŠ¸ë¥¼ ê¸°ë‹¤ë¦¬ê³ , ë‚˜ë¨¸ì§€ 'íŒ”ë¡œì›Œ' ìŠ¤ë ˆë“œë“¤ì€ ë¦¬ë”ê°€ ë  ì°¨ë¡€ë¥¼ ê¸°ë‹¤ë¦°ë‹¤.  
  
* **ê°œë…**: ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ëŒ€ê¸°í•˜ë‹¤ê°€, **ì˜¤ì§ í•˜ë‚˜ì˜ ë¦¬ë”**ê°€ ì´ë²¤íŠ¸ë¥¼ ì²˜ë¦¬í•œë‹¤.
* **ì¥ì **: ìŠ¤ë ˆë“œ í’€ ë‚´ì—ì„œ ë¶€ë‹´ ë¶„ì‚°, ê²½í•© ì¤„ì„.

#### ASCII ê·¸ë¦¼

```
[Thread Pool]
   |    |    |
  [L]  [F]  [F]   --> ì´ë²¤íŠ¸ ë°œìƒ --> ë¦¬ë” ì²˜ë¦¬
         ^   
         | (ë¦¬ë” ì—­í•  êµì²´)
```

#### Mermaid ë‹¤ì´ì–´ê·¸ë¨

```mermaid
flowchart LR
    E[ì´ë²¤íŠ¸ ì†ŒìŠ¤] --> L[ë¦¬ë” ìŠ¤ë ˆë“œ]
    L -->|ì‘ì—… ì²˜ë¦¬| Done[ì™„ë£Œ]
    L -->|ë¦¬ë” ì—­í•  í•´ì œ| F1[íŒ”ë¡œì›Œ ìŠ¤ë ˆë“œ]
    F1 -->|ë¦¬ë” ìŠ¹ê²©| L
```

#### ì‹¤ìŠµ: ë¦¬ë”-íŒ”ë¡œì›Œ íŒ¨í„´
- ë¦¬ë”: ë®¤í…ìŠ¤(g_hLeaderMutex)ë¥¼ íšë“í•œ ìŠ¤ë ˆë“œì´ë‹¤. ë¦¬ë”ë§Œì´ ì‘ì—… íì— ìƒˆ ì‘ì—…ì´ ë“¤ì–´ì˜¤ê¸°ë¥¼ ê¸°ë‹¤ë¦½ë‹ˆë‹¤(g_hTaskSemaphore).  
- íŒ”ë¡œì›Œ: ë®¤í…ìŠ¤ë¥¼ íšë“í•˜ì§€ ëª»í•˜ê³  ëŒ€ê¸° ì¤‘ì¸ ìŠ¤ë ˆë“œë“¤ì´ë‹¤.  
- ì‘ì—… íë¦„:  
    - ë¦¬ë”ê°€ ìƒˆ ì‘ì—…ì„ ê°ì§€í•˜ë©´, ì¦‰ì‹œ íŒ”ë¡œì›Œ ì¤‘ í•˜ë‚˜ì—ê²Œ ë¦¬ë” ìë¦¬ë¥¼ ë„˜ê²¨ì¤€ë‹¤(ë®¤í…ìŠ¤ í•´ì œ).
    - ìƒˆë¡œìš´ ë¦¬ë”ëŠ” ë‹¤ìŒ ì‘ì—…ì„ ê¸°ë‹¤ë¦¬ê¸° ì‹œì‘í•œë‹¤.
    - ê¸°ì¡´ ë¦¬ë”ëŠ” ìì‹ ì´ ê°ì§€í–ˆë˜ ì‘ì—…ì„ ì²˜ë¦¬í•œ í›„, ë‹¤ì‹œ íŒ”ë¡œì›Œê°€ ë˜ì–´ ë¦¬ë” ìë¦¬ë¥¼ ê¸°ë‹¤ë¦°ë‹¤.

```cpp
#include <windows.h>
#include <iostream>
#include <queue>
#include <string>
#include <vector>
#include <process.h> // _beginthreadex, _endthreadex

// =================================================================
// ì „ì—­ ë³€ìˆ˜ ë° ë™ê¸°í™” ê°ì²´
// =================================================================

// ì‘ì—…ì„ ì €ì¥í•  ê³µìœ  í
std::queue<std::string> g_taskQueue;

// ê³µìœ  í ì ‘ê·¼ì„ ë™ê¸°í™”í•˜ê¸° ìœ„í•œ í¬ë¦¬í‹°ì»¬ ì„¹ì…˜
CRITICAL_SECTION g_csQueue;

// ë¦¬ë” ìŠ¤ë ˆë“œë¥¼ ì„ ì¶œí•˜ê¸° ìœ„í•œ ì˜¤í† -ë¦¬ì…‹ ì´ë²¤íŠ¸
// ì´ ì´ë²¤íŠ¸ë¥¼ í†µê³¼í•œ ìŠ¤ë ˆë“œê°€ 'ë¦¬ë”'ê°€ ë©ë‹ˆë‹¤.
HANDLE g_hLeaderElectionEvent;

// ìƒˆë¡œìš´ ì‘ì—…ì´ ì¶”ê°€ë˜ì—ˆìŒì„ ì•Œë¦¬ëŠ” ì„¸ë§ˆí¬ì–´
// ë¦¬ë” ìŠ¤ë ˆë“œë§Œì´ ì´ ì„¸ë§ˆí¬ì–´ë¥¼ ê¸°ë‹¤ë¦½ë‹ˆë‹¤.
HANDLE g_hTaskSemaphore;

// ìŠ¤ë ˆë“œ ì¢…ë£Œë¥¼ ì•Œë¦¬ê¸° ìœ„í•œ í”Œë˜ê·¸
volatile bool g_bIsRunning = true;

// ì‘ì—…ì(ë¦¬ë”/íŒ”ë¡œì›Œ) ìŠ¤ë ˆë“œì˜ ìˆ˜
const int NUM_WORKER_THREADS = 4;


// =================================================================
// ìŠ¤ë ˆë“œ í•¨ìˆ˜
// =================================================================

/**
 * @brief ì‘ì—… ìƒì„±ì(Producer) ìŠ¤ë ˆë“œ í•¨ìˆ˜
 * ì£¼ê¸°ì ìœ¼ë¡œ ì‘ì—…ì„ ìƒì„±í•˜ì—¬ íì— ì¶”ê°€í•˜ê³  ì„¸ë§ˆí¬ì–´ë¥¼ í†µí•´ ì•Œë¦½ë‹ˆë‹¤.
 * @param pParam ìŠ¤ë ˆë“œì— ì „ë‹¬ë˜ëŠ” ì¸ì (ì‚¬ìš© ì•ˆ í•¨)
 * @return ìŠ¤ë ˆë“œ ì¢…ë£Œ ì½”ë“œ
 */
unsigned int __stdcall ProducerThread(void* pParam)
{
    for (int i = 1; i <= 15; ++i)
    {
        // 1. íë¥¼ ì ê·¸ê³  ì‘ì—…ì„ ì¶”ê°€í•©ë‹ˆë‹¤.
        EnterCriticalSection(&g_csQueue);
        std::string task = "ì‘ì—… " + std::to_string(i);
        g_taskQueue.push(task);
        std::cout << "[ìƒì„±] " << task << " (í˜„ì¬ í í¬ê¸°: " << g_taskQueue.size() << ")" << std::endl;
        LeaveCriticalSection(&g_csQueue);

        // 2. ì„¸ë§ˆí¬ì–´ ì¹´ìš´íŠ¸ë¥¼ 1 ì¦ê°€ì‹œì¼œ ëŒ€ê¸° ì¤‘ì¸ ë¦¬ë” ìŠ¤ë ˆë“œì—ê²Œ ìƒˆ ì‘ì—…ì´ ìˆìŒì„ ì•Œë¦½ë‹ˆë‹¤.
        ReleaseSemaphore(g_hTaskSemaphore, 1, NULL);

        // ì‘ì—…ì„ ì£¼ê¸°ì ìœ¼ë¡œ ìƒì„±í•˜ê¸° ìœ„í•´ ì ì‹œ ëŒ€ê¸°
        Sleep(500);
    }

    g_bIsRunning = false;
    std::cout << "\n--- ëª¨ë“  ì‘ì—… ìƒì„± ì™„ë£Œ. ì›Œì»¤ ìŠ¤ë ˆë“œ ì¢…ë£Œ ì‹ í˜¸ ì „ì†¡ ---\n" << std::endl;

    // ì¢…ë£Œ ì‹ í˜¸ë¥¼ ë°›ì€ ì›Œì»¤ ìŠ¤ë ˆë“œë“¤ì´ ì„¸ë§ˆí¬ì–´ ëŒ€ê¸° ìƒíƒœì—ì„œ ë¹ ì ¸ë‚˜ì˜¬ ìˆ˜ ìˆë„ë¡ ì²˜ë¦¬
    ReleaseSemaphore(g_hTaskSemaphore, NUM_WORKER_THREADS, NULL);

    return 0;
}

/**
 * @brief ì‘ì—…ì(Worker) ìŠ¤ë ˆë“œ í•¨ìˆ˜ (ë¦¬ë” ë˜ëŠ” íŒ”ë¡œì›Œ ì—­í•  ìˆ˜í–‰)
 * @param pParam ìŠ¤ë ˆë“œ ID
 * @return ìŠ¤ë ˆë“œ ì¢…ë£Œ ì½”ë“œ
 */
unsigned int __stdcall WorkerThread(void* pParam)
{
    DWORD threadId = GetCurrentThreadId();

    while (true) // ë©”ì¸ ë£¨í”„. ì¢…ë£Œ ì¡°ê±´ì€ ë¦¬ë”ë¡œ ì„ ì¶œëœ ì§í›„ í™•ì¸í•©ë‹ˆë‹¤.
    {
        printf("ìŠ¤ë ˆë“œ %lu: ë¦¬ë”ê°€ ë˜ê¸° ìœ„í•´ ëŒ€ê¸° ì¤‘ (íŒ”ë¡œì›Œ ìƒíƒœ)...\n", threadId);

        // 1. ë¦¬ë”ë¡œ ì„ ì¶œë˜ê¸° ìœ„í•´ ì´ë²¤íŠ¸ë¥¼ ê¸°ë‹¤ë¦½ë‹ˆë‹¤.
        //    ì˜¤í† -ë¦¬ì…‹ ì´ë²¤íŠ¸ì´ë¯€ë¡œ, ì˜¤ì§ í•˜ë‚˜ì˜ ìŠ¤ë ˆë“œë§Œ í†µê³¼í•©ë‹ˆë‹¤.
        WaitForSingleObject(g_hLeaderElectionEvent, INFINITE);

        // 2. ë¦¬ë”ê°€ ëœ ì§í›„, ì¢…ë£Œ í”Œë˜ê·¸ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
        if (!g_bIsRunning) {
            // ë‹¤ë¥¸ ëŒ€ê¸° ì¤‘ì¸ ìŠ¤ë ˆë“œë„ ì¢…ë£Œë  ìˆ˜ ìˆë„ë¡ ì´ë²¤íŠ¸ë¥¼ ë‹¤ì‹œ í™œì„±í™”í•©ë‹ˆë‹¤.
            SetEvent(g_hLeaderElectionEvent);
            break; // ë£¨í”„ë¥¼ íƒˆì¶œí•˜ì—¬ ìŠ¤ë ˆë“œ ì¢…ë£Œ
        }

        printf("ìŠ¤ë ˆë“œ %lu: [ë¦¬ë”]ê°€ ë¨. ìƒˆ ì‘ì—…ì„ ê¸°ë‹¤ë¦½ë‹ˆë‹¤.\n", threadId);

        // 3. ë¦¬ë”ëŠ” ìƒˆ ì‘ì—…ì´ ë„ì°©í•˜ê¸°ë¥¼ ê¸°ë‹¤ë¦½ë‹ˆë‹¤. (ì„¸ë§ˆí¬ì–´ ëŒ€ê¸°)
        WaitForSingleObject(g_hTaskSemaphore, INFINITE);

        // 4. ì‘ì—…ì´ ê°ì§€ë˜ë©´, ì¦‰ì‹œ ë‹¤ë¥¸ íŒ”ë¡œì›Œì—ê²Œ ë¦¬ë” ìë¦¬ë¥¼ ë„˜ê²¨ì¤ë‹ˆë‹¤.
        //    ì´ê²ƒì´ íŒ¨í„´ì˜ í•µì‹¬ìœ¼ë¡œ, ì‹œìŠ¤í…œì´ í˜„ì¬ ì‘ì—…ì„ ì²˜ë¦¬í•˜ëŠ” ë™ì•ˆì—ë„
        //    ìƒˆë¡œìš´ ë¦¬ë”ê°€ ë‹¤ìŒ ì´ë²¤íŠ¸ë¥¼ ê¸°ë‹¤ë¦´ ìˆ˜ ìˆê²Œ í•©ë‹ˆë‹¤.
        printf("ìŠ¤ë ˆë“œ %lu: [ë¦¬ë”] ìƒˆ ì‘ì—… ê°ì§€! ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ê²Œ ë¦¬ë” ì—­í• ì„ ìœ„ì„í•©ë‹ˆë‹¤.\n", threadId);
        SetEvent(g_hLeaderElectionEvent);


        std::string task;
        bool hasTask = false;

        // 5. ì´ì œ ë¦¬ë”ê°€ ì•„ë‹ˆë¯€ë¡œ, í• ë‹¹ëœ ì‘ì—…ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
        EnterCriticalSection(&g_csQueue);
        if (!g_taskQueue.empty())
        {
            task = g_taskQueue.front();
            g_taskQueue.pop();
            hasTask = true;
        }
        LeaveCriticalSection(&g_csQueue);

        if (hasTask)
        {
            printf("    ìŠ¤ë ˆë“œ %lu: '%s' ì²˜ë¦¬ ì‹œì‘...\n", threadId, task.c_str());
            Sleep(1000); // ì‘ì—… ì²˜ë¦¬ ì‹œë®¬ë ˆì´ì…˜
            printf("    ìŠ¤ë ˆë“œ %lu: '%s' ì²˜ë¦¬ ì™„ë£Œ!\n", threadId, task.c_str());
        }
    }

    printf("ìŠ¤ë ˆë“œ %lu: ì¢…ë£Œí•©ë‹ˆë‹¤.\n", threadId);
    return 0;
}


// =================================================================
// Main í•¨ìˆ˜
// =================================================================

int main()
{
    std::vector<HANDLE> hWorkers(NUM_WORKER_THREADS);
    unsigned int threadID;

    // 1. ë™ê¸°í™” ê°ì²´ ì´ˆê¸°í™”
    InitializeCriticalSection(&g_csQueue);

    // ë¦¬ë” ì„ ì¶œì„ ìœ„í•œ ì˜¤í† -ë¦¬ì…‹ ì´ë²¤íŠ¸ ìƒì„±
    // bManualReset = FALSE (ìë™ ë¦¬ì…‹), bInitialState = TRUE (ì´ˆê¸° ì‹ í˜¸ ìƒíƒœ)
    // ì´ˆê¸° ìƒíƒœê°€ TRUEì´ë¯€ë¡œ, ì‹œì‘í•˜ìë§ˆì ìŠ¤ë ˆë“œ ì¤‘ í•˜ë‚˜ê°€ ë¦¬ë”ê°€ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    g_hLeaderElectionEvent = CreateEvent(NULL, FALSE, TRUE, NULL);

    // ì„¸ë§ˆí¬ì–´ ìƒì„± (ì´ˆê¸° ì¹´ìš´íŠ¸: 0)
    // ì²˜ìŒì—ëŠ” ì‘ì—…ì´ ì—†ìœ¼ë¯€ë¡œ ë¦¬ë”ê°€ ë°”ë¡œ ëŒ€ê¸° ìƒíƒœì— ë“¤ì–´ê°€ì•¼ í•©ë‹ˆë‹¤.
    g_hTaskSemaphore = CreateSemaphore(NULL, 0, NUM_WORKER_THREADS + 1, NULL);

    std::cout << "--- ë¦¬ë”-íŒ”ë¡œì›Œ íŒ¨í„´ (Mutex-Free) ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘ ---" << std::endl;
    std::cout << "ì›Œì»¤ ìŠ¤ë ˆë“œ ìˆ˜: " << NUM_WORKER_THREADS << std::endl << std::endl;

    // 2. ì›Œì»¤ ìŠ¤ë ˆë“œë“¤ ìƒì„±
    for (int i = 0; i < NUM_WORKER_THREADS; ++i)
    {
        hWorkers[i] = (HANDLE)_beginthreadex(NULL, 0, &WorkerThread, NULL, 0, &threadID);
    }

    // 3. í”„ë¡œë“€ì„œ ìŠ¤ë ˆë“œ ìƒì„±
    HANDLE hProducer = (HANDLE)_beginthreadex(NULL, 0, &ProducerThread, NULL, 0, &threadID);

    // 4. ëª¨ë“  ìŠ¤ë ˆë“œê°€ ì¢…ë£Œë  ë•Œê¹Œì§€ ëŒ€ê¸°
    WaitForSingleObject(hProducer, INFINITE);
    WaitForMultipleObjects(NUM_WORKER_THREADS, hWorkers.data(), TRUE, INFINITE);

    std::cout << "\n--- ëª¨ë“  ì‘ì—… ì²˜ë¦¬ ì™„ë£Œ. í”„ë¡œê·¸ë¨ ì¢…ë£Œ. ---" << std::endl;

    // 5. ë¦¬ì†ŒìŠ¤ í•´ì œ
    CloseHandle(hProducer);
    for (int i = 0; i < NUM_WORKER_THREADS; ++i)
    {
        CloseHandle(hWorkers[i]);
    }
    CloseHandle(g_hLeaderElectionEvent);
    CloseHandle(g_hTaskSemaphore);
    DeleteCriticalSection(&g_csQueue);

    return 0;
}
```
  
  
### 2.3 íŒŒì´í”„ë¼ì¸ ì²˜ë¦¬ (Pipeline Processing)
* **ê°œë…**: ë°ì´í„°ë¥¼ ì—¬ëŸ¬ ë‹¨ê³„ë¡œ ë‚˜ëˆ„ì–´, ê° ë‹¨ê³„ë§ˆë‹¤ ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ì²˜ë¦¬í•œë‹¤.
* **ì¥ì **: ë³‘ë ¬ ì²˜ë¦¬ë¡œ ì „ì²´ ì²˜ë¦¬ëŸ‰ ì¦ê°€.

```
[Stage1: Load] --> [Stage2: Decode] --> [Stage3: Render]
```

```mermaid
flowchart LR
    S1[ë‹¨ê³„1: ë°ì´í„° ë¡œë“œ] --> S2[ë‹¨ê³„2: ë””ì½”ë”©]
    S2 --> S3[ë‹¨ê³„3: ë Œë”ë§]
```

#### ì‹¤ìŠµ: íŒŒì´í”„ë¼ì¸ ì²˜ë¦¬
  
```cpp
#include <windows.h>
#include <process.h>
#include <queue>
#include <iostream>

CRITICAL_SECTION cs1, cs2;
std::queue<int> q1, q2;
HANDLE ev1, ev2;

unsigned __stdcall Stage1(void*) {
    for (int i = 0; i < 5; i++) {
        Sleep(300);
        EnterCriticalSection(&cs1);
        q1.push(i);
        std::cout << "Stage1: " << i << std::endl;
        LeaveCriticalSection(&cs1);
        SetEvent(ev1);
    }
    return 0;
}

unsigned __stdcall Stage2(void*) {
    while (true) {
        WaitForSingleObject(ev1, INFINITE);
        EnterCriticalSection(&cs1);
        if (!q1.empty()) {
            int d = q1.front(); q1.pop();
            LeaveCriticalSection(&cs1);
            d *= 2; // ì²˜ë¦¬
            EnterCriticalSection(&cs2);
            q2.push(d);
            std::cout << "Stage2: " << d << std::endl;
            LeaveCriticalSection(&cs2);
            SetEvent(ev2);
        } else {
            LeaveCriticalSection(&cs1);
        }
    }
    return 0;
}

unsigned __stdcall Stage3(void*) {
    while (true) {
        WaitForSingleObject(ev2, INFINITE);
        EnterCriticalSection(&cs2);
        if (!q2.empty()) {
            int d = q2.front(); q2.pop();
            std::cout << "Stage3: " << d << std::endl;
        }
        LeaveCriticalSection(&cs2);
    }
    return 0;
}

int main() {
    InitializeCriticalSection(&cs1);
    InitializeCriticalSection(&cs2);
    ev1 = CreateEvent(NULL, FALSE, FALSE, NULL);
    ev2 = CreateEvent(NULL, FALSE, FALSE, NULL);

    _beginthreadex(NULL, 0, Stage1, NULL, 0, NULL);
    _beginthreadex(NULL, 0, Stage2, NULL, 0, NULL);
    _beginthreadex(NULL, 0, Stage3, NULL, 0, NULL);

    Sleep(5000);
    return 0;
}
```

#### ê²Œì„ì—ì„œ í™œìš© ì˜ˆì‹œ
* **ì• ë‹ˆë©”ì´ì…˜ íŒŒì´í”„ë¼ì¸**:
  * Stage1: ë¦¬ì†ŒìŠ¤ ë¡œë“œ
  * Stage2: ìŠ¤ì¼ˆë ˆí†¤ ë³€í™˜ ì²˜ë¦¬
  * Stage3: ìµœì¢… ë Œë”ë§

  

### ìš”ì•½
* **ìƒì‚°ì-ì†Œë¹„ì**ëŠ” **ì†ë„ ì°¨ì´ë¥¼ ë²„í¼ë¡œ í•´ê²°**
* **ë¦¬ë”-íŒ”ë¡œì›Œ**ëŠ” **ìŠ¤ë ˆë“œ í’€ì—ì„œ ë¦¬ë”ë¥¼ ì„ ì¶œí•´ ë¶€í•˜ ë¶„ì‚°**
* **íŒŒì´í”„ë¼ì¸ ì²˜ë¦¬**ëŠ” **ì‘ì—… ë‹¨ê³„ë¥¼ ë‚˜ëˆ  ë³‘ë ¬ ì²˜ë¦¬**

</br>  
</br>  
  
## 3. Interlocked í•¨ìˆ˜ë“¤ ( **ì¤‘ìš”** )
Interlocked í•¨ìˆ˜ëŠ” ì›ìì (atomic) ì—°ì‚°ì„ ì œê³µí•˜ì—¬ **ë½ ì—†ì´ë„ ìŠ¤ë ˆë“œ ì•ˆì „í•œ ì—°ì‚°ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆê²Œ í•œë‹¤.**     
ì´ëŠ” ì„±ëŠ¥ìƒ ë§¤ìš° ìœ ë¦¬í•˜ë©°, ê°„ë‹¨í•œ ë™ê¸°í™”ì— ì í•©í•˜ë‹¤.   
  
### ì£¼ìš” Interlocked í•¨ìˆ˜ë“¤

```cpp
// InterlockedIncrement / InterlockedDecrement
LONG InterlockedIncrement(LONG volatile* Addend);
LONG InterlockedDecrement(LONG volatile* Addend);

// InterlockedExchange
LONG InterlockedExchange(LONG volatile* Target, LONG Value);

// InterlockedCompareExchange (CAS - Compare And Swap)
LONG InterlockedCompareExchange(
    LONG volatile* Destination,
    LONG Exchange,
    LONG Comparand
);

// InterlockedAdd
LONG InterlockedAdd(LONG volatile* Addend, LONG Value);

// InterlockedExchangePointer
PVOID InterlockedExchangePointer(
    PVOID volatile* Target,
    PVOID Value
);


// 64ë¹„íŠ¸ ë²„ì „
LONGLONG InterlockedIncrement64(LONGLONG volatile* Addend);
LONGLONG InterlockedDecrement64(LONGLONG volatile* Addend);
LONGLONG InterlockedExchange64(LONGLONG volatile* Target, LONGLONG Value);
LONGLONG InterlockedCompareExchange64(
    LONGLONG volatile* Destination,
    LONGLONG Exchange,
    LONGLONG Comparand
);
LONGLONG InterlockedAdd64(LONGLONG volatile* Addend, LONGLONG Value);

// í¬ì¸í„°ìš© í•¨ìˆ˜
PVOID InterlockedCompareExchangePointer(
    PVOID volatile* Destination,
    PVOID Exchange,
    PVOID Comparand
);

// ë¹„íŠ¸ ì—°ì‚°
LONG InterlockedAnd(LONG volatile* Destination, LONG Value);
LONG InterlockedOr(LONG volatile* Destination, LONG Value);
LONG InterlockedXor(LONG volatile* Destination, LONG Value);

// êµì²´ í›„ ë§ì…ˆ
LONG InterlockedExchangeAdd(LONG volatile* Addend, LONG Value);

// ë©”ëª¨ë¦¬ ì¥ë²½
VOID MemoryBarrier();

```
  

### InterlockedIncrement / InterlockedDecrement

```cpp
LONG InterlockedIncrement(LONG volatile* Addend);
LONG InterlockedDecrement(LONG volatile* Addend);
```

* ê³µìœ  ë³€ìˆ˜ ê°’ì„ **ì›ìì ìœ¼ë¡œ 1 ì¦ê°€ / ê°ì†Œ**í•œë‹¤.
* ë°˜í™˜ê°’ì€ ì—°ì‚° í›„ì˜ ê°’ì´ë‹¤.
* ìŠ¤ë ˆë“œ ì¹´ìš´í„°, ì°¸ì¡° ì¹´ìš´íŠ¸ ë“±ì—ì„œ ìì£¼ ì‚¬ìš©ëœë‹¤.

#### ê°„ë‹¨í•œ ì˜ˆì œ

```cpp
#include <windows.h>
#include <iostream>

LONG g_counter = 0;

DWORD WINAPI ThreadProc(LPVOID) {
    for (int i = 0; i < 1000; i++) {
        InterlockedIncrement(&g_counter);
    }
    return 0;
}

int main() {
    HANDLE h1 = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);
    HANDLE h2 = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);

    WaitForSingleObject(h1, INFINITE);
    WaitForSingleObject(h2, INFINITE);

    std::cout << "Counter = " << g_counter << std::endl; // 2000 ì˜ˆìƒ
    return 0;
}
```

  
### InterlockedExchange

```cpp
LONG InterlockedExchange(LONG volatile* Target, LONG Value);
```

* `*Target`ì„ `Value`ë¡œ ì›ìì ìœ¼ë¡œ êµì²´í•œë‹¤.
* **êµì²´í•˜ê¸° ì „ì˜ ê°’**ì„ ë°˜í™˜í•œë‹¤.
* ìŠ¤ë ˆë“œ ê°„ í”Œë˜ê·¸ ë³€ìˆ˜ ì„¤ì • ë“±ì— ì‚¬ìš©ëœë‹¤.

#### ê°„ë‹¨í•œ ì˜ˆì œ

```cpp
LONG g_flag = 0;

void SetFlag() {
    LONG old = InterlockedExchange(&g_flag, 1);
    if (old == 0) {
        // ìµœì´ˆë¡œ flagë¥¼ 1ë¡œ ë§Œë“  ìŠ¤ë ˆë“œ
        printf("Flag set by this thread\n");
    }
}
```

---

### InterlockedCompareExchange (CAS - Compare And Swap)

```cpp
LONG InterlockedCompareExchange(
    LONG volatile* Destination,
    LONG Exchange,
    LONG Comparand
);
```

* `*Destination` ê°’ì´ `Comparand`ì™€ ê°™ìœ¼ë©´ `Exchange`ë¡œ êµì²´í•œë‹¤.
* ë°˜í™˜ê°’ì€ êµì²´ **ì´ì „ì˜ ê°’**ì´ë‹¤.
* ì›ìì  ë¹„êµ-êµí™˜(CAS) ì—°ì‚°ìœ¼ë¡œ, lock-free ì•Œê³ ë¦¬ì¦˜ì˜ í•µì‹¬ì´ë‹¤.

#### ê°„ë‹¨í•œ ì˜ˆì œ

```cpp
LONG g_value = 0;

void TryUpdateValue() {
    LONG expected = 0;
    LONG newValue = 123;

    LONG old = InterlockedCompareExchange(&g_value, newValue, expected);
    if (old == expected) {
        printf("Value updated to %ld\n", g_value);
    } else {
        printf("Failed, current value = %ld\n", old);
    }
}
```

---

### InterlockedAdd

```cpp
LONG InterlockedAdd(LONG volatile* Addend, LONG Value);
```

* `*Addend`ì— `Value`ë¥¼ ì›ìì ìœ¼ë¡œ ë”í•œë‹¤.
* ë°˜í™˜ê°’ì€ ì—°ì‚° í›„ì˜ ê°’ì´ë‹¤.
* ëˆ„ì  í•©ì‚°, ê°€ì¤‘ì¹˜ ê³„ì‚° ë“±ì— ì‚¬ìš©ëœë‹¤.

#### ê°„ë‹¨í•œ ì˜ˆì œ

```cpp
LONG g_total = 0;

void AddScore(LONG score) {
    LONG newTotal = InterlockedAdd(&g_total, score);
    printf("Total score = %ld\n", newTotal);
}
```

---

### InterlockedExchangePointer

```cpp
PVOID InterlockedExchangePointer(
    PVOID volatile* Target,
    PVOID Value
);
```

* í¬ì¸í„°ë¥¼ ì›ìì ìœ¼ë¡œ êµì²´í•œë‹¤.
* ë°˜í™˜ê°’ì€ êµì²´í•˜ê¸° ì „ì˜ í¬ì¸í„°ë‹¤.
* ë©€í‹°ìŠ¤ë ˆë“œì—ì„œ í¬ì¸í„° êµì²´ ì‹œ ì•ˆì „í•˜ê²Œ ì‚¬ìš©ëœë‹¤.

#### ê°„ë‹¨í•œ ì˜ˆì œ

```cpp
PVOID g_ptr = NULL;

void SetResource(void* newRes) {
    void* old = InterlockedExchangePointer(&g_ptr, newRes);
    if (old != NULL) {
        printf("Old resource released\n");
        // ReleaseResource(old); // ê°€ì •
    }
}
```


### InterlockedIncrement64 / InterlockedDecrement64

```cpp
LONGLONG InterlockedIncrement64(LONGLONG volatile* Addend);
LONGLONG InterlockedDecrement64(LONGLONG volatile* Addend);
```

* 64ë¹„íŠ¸ ì •ìˆ˜ë¥¼ ì›ìì ìœ¼ë¡œ **1 ì¦ê°€/ê°ì†Œ**í•œë‹¤.
* ë°˜í™˜ê°’: ì—°ì‚° í›„ ê°’.

#### ê°„ë‹¨í•œ ì˜ˆì œ

```cpp
LONGLONG g_count64 = 0;

DWORD WINAPI ThreadProc(LPVOID) {
    for (int i = 0; i < 1000; i++) {
        InterlockedIncrement64(&g_count64);
    }
    return 0;
}

int main() {
    HANDLE h1 = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);
    HANDLE h2 = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);
    WaitForSingleObject(h1, INFINITE);
    WaitForSingleObject(h2, INFINITE);

    printf("Count64 = %lld\n", g_count64); // 2000 ì˜ˆìƒ
}
```

---

### InterlockedExchange64

```cpp
LONGLONG InterlockedExchange64(LONGLONG volatile* Target, LONGLONG Value);
```

* `*Target`ì„ `Value`ë¡œ ì›ìì ìœ¼ë¡œ êµì²´.
* ë°˜í™˜ê°’: êµì²´ ì´ì „ ê°’.

#### ê°„ë‹¨í•œ ì˜ˆì œ

```cpp
LONGLONG g_value64 = 100;

void UpdateValue() {
    LONGLONG old = InterlockedExchange64(&g_value64, 999);
    printf("Old=%lld, New=%lld\n", old, g_value64);
}
```

---

### InterlockedCompareExchange64

```cpp
LONGLONG InterlockedCompareExchange64(
    LONGLONG volatile* Destination,
    LONGLONG Exchange,
    LONGLONG Comparand
);
```

* `*Destination == Comparand`ì´ë©´ `Exchange`ë¡œ êµì²´.
* ë°˜í™˜ê°’: êµì²´ ì „ ê°’.

#### ê°„ë‹¨í•œ ì˜ˆì œ

```cpp
LONGLONG g_value64 = 0;

void CAS64() {
    LONGLONG old = InterlockedCompareExchange64(&g_value64, 111, 0);
    if (old == 0) printf("CAS success, new=%lld\n", g_value64);
    else printf("CAS failed, current=%lld\n", g_value64);
}
```


### InterlockedAdd64

```cpp
LONGLONG InterlockedAdd64(LONGLONG volatile* Addend, LONGLONG Value);
```

* `*Addend += Value` ì›ìì  ë§ì…ˆ.
* ë°˜í™˜ê°’: ì—°ì‚° í›„ ê°’.

#### ê°„ë‹¨í•œ ì˜ˆì œ

```cpp
LONGLONG g_sum64 = 0;

void Add64() {
    LONGLONG total = InterlockedAdd64(&g_sum64, 50);
    printf("Total = %lld\n", total);
}
```


### í¬ì¸í„°ìš© í•¨ìˆ˜ InterlockedCompareExchangePointer

```cpp
PVOID InterlockedCompareExchangePointer(
    PVOID volatile* Destination,
    PVOID Exchange,
    PVOID Comparand
);
```

* `*Destination == Comparand`ì¼ ë•Œ `Exchange`ë¡œ êµì²´.
* ë°˜í™˜ê°’: êµì²´ ì „ ê°’.

#### ê°„ë‹¨í•œ ì˜ˆì œ

```cpp
PVOID g_ptr = NULL;

void SetResource(void* newRes) {
    void* expected = NULL;
    void* old = InterlockedCompareExchangePointer(&g_ptr, newRes, expected);
    if (old == expected) {
        printf("Pointer set successfully\n");
    } else {
        printf("Already set by another thread\n");
    }
}
```
  

### ë¹„íŠ¸ ì—°ì‚° ê´€ë ¨ InterlockedAnd

```cpp
LONG InterlockedAnd(LONG volatile* Destination, LONG Value);
```

* `*Destination &= Value` (ì›ìì  AND).
* ë°˜í™˜ê°’: ì—°ì‚° ì „ ê°’.

#### ê°„ë‹¨í•œ ì˜ˆì œ

```cpp
LONG g_flags = 0xFF; // 11111111

void MaskFlag() {
    LONG old = InterlockedAnd(&g_flags, 0x0F); // í•˜ìœ„ 4ë¹„íŠ¸ë§Œ ìœ ì§€
    printf("Old=0x%X, New=0x%X\n", old, g_flags);
}
```

---

### ë¹„íŠ¸ ì—°ì‚° ê´€ë ¨ InterlockedOr

```cpp
LONG InterlockedOr(LONG volatile* Destination, LONG Value);
```

* `*Destination |= Value` (ì›ìì  OR).
* ë°˜í™˜ê°’: ì—°ì‚° ì „ ê°’.

#### ê°„ë‹¨í•œ ì˜ˆì œ

```cpp
LONG g_flags = 0x01;

void SetBit() {
    LONG old = InterlockedOr(&g_flags, 0x04);
    printf("Old=0x%X, New=0x%X\n", old, g_flags);
}
```

---

### ë¹„íŠ¸ ì—°ì‚° ê´€ë ¨ InterlockedXor

```cpp
LONG InterlockedXor(LONG volatile* Destination, LONG Value);
```

* `*Destination ^= Value` (ì›ìì  XOR).
* ë°˜í™˜ê°’: ì—°ì‚° ì „ ê°’.

#### ê°„ë‹¨í•œ ì˜ˆì œ

```cpp
LONG g_flags = 0x05; // 0101

void ToggleBit() {
    LONG old = InterlockedXor(&g_flags, 0x01);
    printf("Old=0x%X, New=0x%X\n", old, g_flags);
}
```


### êµì²´ í›„ ë§ì…ˆ InterlockedExchangeAdd

```cpp
LONG InterlockedExchangeAdd(LONG volatile* Addend, LONG Value);
```

* `*Addend += Value` ìˆ˜í–‰.
* ë°˜í™˜ê°’: ì—°ì‚° **ì „** ê°’ (â†’ `InterlockedAdd`ì™€ ì°¨ì´ì ).

#### ê°„ë‹¨í•œ ì˜ˆì œ

```cpp
LONG g_total = 10;

void AddScore() {
    LONG old = InterlockedExchangeAdd(&g_total, 5);
    printf("Old=%ld, New=%ld\n", old, g_total); // Old=10, New=15
}
```


### 5-1. ë©”ëª¨ë¦¬ ì¥ë²½ MemoryBarrier

```cpp
VOID MemoryBarrier();
```

* CPU ëª…ë ¹ ì¬ì •ë ¬ì„ ë°©ì§€í•˜ëŠ” **í’€ íœìŠ¤(full fence)**.
* ë‹¤ì¤‘ CPU ì½”ì–´ í™˜ê²½ì—ì„œ lock-free ì•Œê³ ë¦¬ì¦˜ì˜ ì¼ê´€ì„±ì„ ë³´ì¥.

#### ê°„ë‹¨í•œ ì˜ˆì œ

```cpp
LONG g_ready = 0;
int g_data = 0;

DWORD WINAPI Producer(LPVOID) {
    g_data = 42;
    MemoryBarrier();        // g_data ì“°ê¸° ì™„ë£Œ ë³´ì¥
    InterlockedExchange(&g_ready, 1);
    return 0;
}

DWORD WINAPI Consumer(LPVOID) {
    while (InterlockedCompareExchange(&g_ready, 1, 1) != 1) {
        Sleep(1);
    }
    MemoryBarrier();        // g_data ì½ê¸° ì´ì „ì— g_ready ë°˜ë“œì‹œ í™•ì¸
    printf("Received data = %d\n", g_data);
    return 0;
}
```



### ì‹¤ìŠµ: Lock-Free ì°¸ì¡° ì¹´ìš´íŒ…

```cpp
#include <windows.h>
#include <iostream>
#include <vector>
#include <thread>

class RefCountedObject {
private:
    volatile LONG refCount;
    std::string data;
    
public:
    RefCountedObject(const std::string& str) : refCount(1), data(str) {
        std::cout << "Object created: " << data << std::endl;
    }
    
    void AddRef() {
        LONG newCount = InterlockedIncrement(&refCount);
        std::cout << "RefCount increased to: " << newCount 
                  << " [Thread: " << GetCurrentThreadId() << "]" << std::endl;
    }
    
    void Release() {
        LONG newCount = InterlockedDecrement(&refCount);
        std::cout << "RefCount decreased to: " << newCount 
                  << " [Thread: " << GetCurrentThreadId() << "]" << std::endl;
        
        if (newCount == 0) {
            delete this;
        }
    }
    
    LONG GetRefCount() const {
        // InterlockedCompareExchangeë¥¼ ì‚¬ìš©í•œ ì•ˆì „í•œ ì½ê¸°
        return InterlockedCompareExchange(
            const_cast<volatile LONG*>(&refCount), 0, 0);
    }
    
private:
    ~RefCountedObject() {
        std::cout << "Object destroyed: " << data << std::endl;
    }
};
``` 


### ì‹¤ìŠµ: ìŠ¤í•€ë½ êµ¬í˜„ ì˜ˆì œ

```cpp
#include <iostream>
#include <vector>
#include <windows.h>
#include <process.h> // _beginthreadexë¥¼ ìœ„í•´ í•„ìš”

// ì œê³µëœ SpinLock í´ë˜ìŠ¤
class SpinLock {
private:
    volatile LONG locked;

public:
    SpinLock() : locked(0) {}

    void Lock() {
        // ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ lockedë¥¼ 0ìœ¼ë¡œ ë°”ê¿€ ë•Œê¹Œì§€ ê³„ì† ì‹œë„ (ìŠ¤í•€)
        while (InterlockedCompareExchange(&locked, 1, 0) != 0) {
            // ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ê²Œ CPUë¥¼ ì–‘ë³´í•˜ì—¬ ë¬´í•œ ë£¨í”„ ë°©ì§€ ì„±ëŠ¥ í–¥ìƒ
            YieldProcessor(); 
        }
    }

    void Unlock() {
        // locked ê°’ì„ 0ìœ¼ë¡œ ì„¤ì •í•˜ì—¬ ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ì§„ì…í•  ìˆ˜ ìˆë„ë¡ í•¨
        InterlockedExchange(&locked, 0);
    }
};

// --- ì „ì—­ ë³€ìˆ˜ ë° ë½ ê°ì²´ ---
SpinLock g_lock;          // ê³µìœ  ë°ì´í„°ë¥¼ ë³´í˜¸í•  ìŠ¤í•€ë½ ê°ì²´
long g_counter = 0;       // ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ê³µìœ í•  ë°ì´í„°
const int THREAD_COUNT = 10;
const int INCREMENT_PER_THREAD = 100000;

// --- ìŠ¤ë ˆë“œ í•¨ìˆ˜ ---
// _beginthreadexëŠ” ì´ í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ë¥¼ ìš”êµ¬í•©ë‹ˆë‹¤.
unsigned int __stdcall ThreadFunction(void* arg) {
    int threadId = *(static_cast<int*>(arg)); // ì¸ìë¡œ ë°›ì€ ìŠ¤ë ˆë“œ ID

    for (int i = 0; i < INCREMENT_PER_THREAD; ++i) {
        // --- ì„ê³„ ì˜ì—­ ì‹œì‘ (Critical Section) ---
        g_lock.Lock();

        // SpinLockìœ¼ë¡œ ë³´í˜¸ë˜ëŠ” ì½”ë“œ
        g_counter++;

        g_lock.Unlock();
        // --- ì„ê³„ ì˜ì—­ ì¢…ë£Œ ---
    }
    
    // ìŠ¤ë ˆë“œ IDê°€ ë‹´ê¸´ ë©”ëª¨ë¦¬ í•´ì œ
    delete static_cast<int*>(arg);
    return 0;
}


int main() {
    std::vector<HANDLE> threadHandles;

    std::cout << THREAD_COUNT << "ê°œì˜ ìŠ¤ë ˆë“œê°€ ê°ê° " << INCREMENT_PER_THREAD << "ë²ˆì”© ì¹´ìš´í„°ë¥¼ ì¦ê°€ì‹œí‚µë‹ˆë‹¤." << std::endl;

    // _beginthreadexë¥¼ ì‚¬ìš©í•˜ì—¬ ìŠ¤ë ˆë“œ ìƒì„±
    for (int i = 0; i < THREAD_COUNT; ++i) {
        // ìŠ¤ë ˆë“œ í•¨ìˆ˜ì— ìŠ¤ë ˆë“œ IDë¥¼ ë„˜ê²¨ì£¼ê¸° ìœ„í•´ ë™ì  í• ë‹¹
        int* threadId = new int(i);
        
        HANDLE hThread = (HANDLE)_beginthreadex(
            NULL,                   // ë³´ì•ˆ ì†ì„± (ê¸°ë³¸ê°’)
            0,                      // ìŠ¤íƒ í¬ê¸° (ê¸°ë³¸ê°’)
            ThreadFunction,         // ìŠ¤ë ˆë“œ í•¨ìˆ˜ í¬ì¸í„°
            threadId,               // ìŠ¤ë ˆë“œ í•¨ìˆ˜ì— ì „ë‹¬í•  ì¸ì
            0,                      // ìƒì„± í”Œë˜ê·¸ (ì¦‰ì‹œ ì‹¤í–‰)
            NULL                    // ìŠ¤ë ˆë“œ IDë¥¼ ë°›ì„ ë³€ìˆ˜ ì£¼ì†Œ (í•„ìš” ì—†ìŒ)
        );

        if (hThread) {
            threadHandles.push_back(hThread);
        } else {
            std::cerr << "ìŠ¤ë ˆë“œ ìƒì„± ì‹¤íŒ¨!" << std::endl;
            delete threadId; // ì‹¤íŒ¨ ì‹œ ë©”ëª¨ë¦¬ í•´ì œ
        }
    }

    // ëª¨ë“  ìŠ¤ë ˆë“œê°€ ì¢…ë£Œë  ë•Œê¹Œì§€ ëŒ€ê¸°
    WaitForMultipleObjects((DWORD)threadHandles.size(), threadHandles.data(), TRUE, INFINITE);

    // ìŠ¤ë ˆë“œ í•¸ë“¤ ì •ë¦¬
    for (HANDLE h : threadHandles) {
        CloseHandle(h);
    }
    
    long long expected_result = (long long)THREAD_COUNT * INCREMENT_PER_THREAD;
    std::cout << "\nì˜ˆìƒ ê²°ê³¼: " << expected_result << std::endl;
    std::cout << "ì‹¤ì œ ê²°ê³¼: " << g_counter << std::endl;

    if (g_counter == expected_result) {
        std::cout << "ì„±ê³µ: SpinLockì´ ê³µìœ  ë°ì´í„°ë¥¼ ì„±ê³µì ìœ¼ë¡œ ë³´í˜¸í–ˆìŠµë‹ˆë‹¤." << std::endl;
    } else {
        std::cout << "ì‹¤íŒ¨: ë°ì´í„° ê²½ìŸ ìƒíƒœê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤." << std::endl;
    }

    return 0;
}
```



### ì‹¤ì œ í™œìš© ì˜ˆì œ: ê°„ë‹¨í•œ lock-free í (ë‹¨ì¼ ìƒì‚°ì, ë‹¨ì¼ ì†Œë¹„ììš© SPSC í)
(ë©€í‹° ìƒì‚°ì/ì†Œë¹„ìê¹Œì§€ í™•ì¥í•˜ë ¤ë©´ ë” ë³µì¡í•œ ë©”ëª¨ë¦¬ ì¥ë²½ê³¼ CAS ë£¨í”„ê°€ í•„ìš”í•˜ë‹¤)


#### ê¸°ë³¸ ì•„ì´ë””ì–´
* **ë°°ì—´ ê¸°ë°˜ ì›í˜• í**ë¥¼ ì‚¬ìš©í•œë‹¤.
* `head` (ì½ê¸° ì¸ë±ìŠ¤), `tail` (ì“°ê¸° ì¸ë±ìŠ¤)ë¥¼ `Interlocked` ì—°ì‚°ìœ¼ë¡œ ì¡°ì‘í•œë‹¤.
* `InterlockedCompareExchange`ë¡œ `head`/`tail` ì¶©ëŒì„ ë°©ì§€í•œë‹¤.
* í¬ë¦¬í‹°ì»¬ì„¹ì…˜ì€ ì“°ì§€ ì•Šê³ , ì˜¤ì§ ì›ìì  ì—°ì‚°ë§Œ ì‚¬ìš©í•œë‹¤.


#### ì½”ë“œ

```cpp
#include <windows.h>
#include <iostream>

const int QUEUE_SIZE = 1024;

struct LockFreeQueue {
    volatile LONG head; // ì½ê¸° ìœ„ì¹˜
    volatile LONG tail; // ì“°ê¸° ìœ„ì¹˜
    int buffer[QUEUE_SIZE];
};

// ì´ˆê¸°í™”
void InitQueue(LockFreeQueue* q) {
    q->head = 0;
    q->tail = 0;
}

// Enqueue (ìƒì‚°ì ì „ìš©)
bool Enqueue(LockFreeQueue* q, int value) {
    LONG nextTail = (q->tail + 1) % QUEUE_SIZE;

    if (nextTail == q->head) {
        // íê°€ ê°€ë“ ì°¸
        return false;
    }

    q->buffer[q->tail] = value;

    // ì“°ê¸° ì™„ë£Œ â†’ ë©”ëª¨ë¦¬ ì¥ë²½
    MemoryBarrier();

    q->tail = nextTail;
    return true;
}

// Dequeue (ì†Œë¹„ì ì „ìš©)
bool Dequeue(LockFreeQueue* q, int* outValue) {
    if (q->head == q->tail) {
        // íê°€ ë¹„ì–´ ìˆìŒ
        return false;
    }

    *outValue = q->buffer[q->head];

    // ì½ê¸° ì™„ë£Œ â†’ ë©”ëª¨ë¦¬ ì¥ë²½
    MemoryBarrier();

    q->head = (q->head + 1) % QUEUE_SIZE;
    return true;
}

```


```cpp
LockFreeQueue g_queue;

DWORD WINAPI Producer(LPVOID) {
    for (int i = 0; i < 20; i++) {
        while (!Enqueue(&g_queue, i)) {
            Sleep(1); // íê°€ ê°€ë“ ì°¨ë©´ ì ì‹œ ì‰¼
        }
        std::cout << "Produced: " << i << std::endl;
    }
    return 0;
}

DWORD WINAPI Consumer(LPVOID) {
    int value;
    for (int i = 0; i < 20; i++) {
        while (!Dequeue(&g_queue, &value)) {
            Sleep(1); // íê°€ ë¹„ë©´ ì ì‹œ ì‰¼
        }
        std::cout << "Consumed: " << value << std::endl;
    }
    return 0;
}

int main() {
    InitQueue(&g_queue);

    HANDLE h1 = CreateThread(NULL, 0, Producer, NULL, 0, NULL);
    HANDLE h2 = CreateThread(NULL, 0, Consumer, NULL, 0, NULL);

    WaitForSingleObject(h1, INFINITE);
    WaitForSingleObject(h2, INFINITE);

    return 0;
}
```


#### ë™ì‘ ê°œìš”
* `Producer` ìŠ¤ë ˆë“œëŠ” `Enqueue`ë¡œ ë°ì´í„°ë¥¼ ë„£ëŠ”ë‹¤.
* `Consumer` ìŠ¤ë ˆë“œëŠ” `Dequeue`ë¡œ ë°ì´í„°ë¥¼ ëº€ë‹¤.
* `InterlockedCompareExchange`ë¡œ `head`/`tail` ê°±ì‹ ì„ ì›ìì ìœ¼ë¡œ ìˆ˜í–‰í•´ **ë°ì´í„° ê²½í•© ì—†ì´ ì•ˆì „**í•˜ë‹¤.
* ë½(`CriticalSection`)ì„ ì“°ì§€ ì•Šìœ¼ë¯€ë¡œ ê°€ë²¼ìš´ êµ¬ì¡°ë‹¤.

* PSC í™˜ê²½ì—ì„œëŠ” CAS ë¶ˆí•„ìš” â†’ ë‹¨ìˆœíˆ head, tailë§Œ ì½ê³ /ê°±ì‹ .
* **ë©”ëª¨ë¦¬ ì¥ë²½(MemoryBarrier)**ì„ ë„£ì–´ CPU ì¬ì •ë ¬ ë°©ì§€.
* ìƒì‚°ìëŠ” tailë§Œ, ì†Œë¹„ìëŠ” headë§Œ ë…ì í•˜ë¯€ë¡œ lock-freeê°€ ìì—°ìŠ¤ëŸ½ê²Œ ë³´ì¥ë¨.

  

### ì‹¤ìŠµ: ê°„ë‹¨í•œ lock-free í (ë‹¤ì¤‘ ìƒì‚°ì/ë‹¤ì¤‘ ì†Œë¹„ì(MPMC))
SPSC ë•Œì²˜ëŸ¼ ë‹¨ìˆœí•˜ì§€ ì•Šê³ , ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— `head`ì™€ `tail`ì„ ê°±ì‹ í•˜ë¯€ë¡œ **CAS(InterlockedCompareExchange)** ë¥¼ ì‚¬ìš©í•´ì•¼ í•œë‹¤.
ê°€ëŠ¥í•œ í•œ **ê°„ë‹¨í•œ ê³ ì • í¬ê¸° ì›í˜• ë²„í¼ ê¸°ë°˜**ìœ¼ë¡œ êµ¬í˜„í•˜ê² ë‹¤.

  
```cpp
#include <windows.h>
#include <iostream>

const int QUEUE_SIZE = 1024;

struct LockFreeQueue {
    volatile LONG head;
    volatile LONG tail;
    int buffer[QUEUE_SIZE];
};

void InitQueue(LockFreeQueue* q) {
    q->head = 0;
    q->tail = 0;
}

// Enqueue: ì—¬ëŸ¬ ìƒì‚°ì ê°€ëŠ¥
bool Enqueue(LockFreeQueue* q, int value) {
    while (true) {
        LONG tail = q->tail;
        LONG head = q->head;
        LONG nextTail = (tail + 1) % QUEUE_SIZE;

        if (nextTail == head) {
            // íê°€ ê°€ë“ ì°¸
            return false;
        }

        // tail CAS ì‹œë„
        if (InterlockedCompareExchange(&q->tail, nextTail, tail) == tail) {
            // ì„±ê³µì ìœ¼ë¡œ tail í™•ë³´í–ˆìœ¼ë©´ ê°’ ì €ì¥
            q->buffer[tail] = value;
            return true;
        }
        // ì‹¤íŒ¨ ì‹œ ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ tail ì—…ë°ì´íŠ¸ â†’ ì¬ì‹œë„
    }
}

// Dequeue: ì—¬ëŸ¬ ì†Œë¹„ì ê°€ëŠ¥
bool Dequeue(LockFreeQueue* q, int* outValue) {
    while (true) {
        LONG head = q->head;
        LONG tail = q->tail;

        if (head == tail) {
            // íê°€ ë¹„ì–´ ìˆìŒ
            return false;
        }

        LONG nextHead = (head + 1) % QUEUE_SIZE;

        // head CAS ì‹œë„
        if (InterlockedCompareExchange(&q->head, nextHead, head) == head) {
            *outValue = q->buffer[head];
            return true;
        }
        // ì‹¤íŒ¨ ì‹œ ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ head ì—…ë°ì´íŠ¸ â†’ ì¬ì‹œë„
    }
}
```

```cpp
LockFreeQueue g_queue;

DWORD WINAPI Producer(LPVOID param) {
    int id = (int)(INT_PTR)param;
    for (int i = 0; i < 10; i++) {
        while (!Enqueue(&g_queue, id * 100 + i)) {
            Sleep(1); // íê°€ ê°€ë“ ì°¨ë©´ ì ì‹œ ëŒ€ê¸°
        }
        std::cout << "Producer " << id << " -> " << (id * 100 + i) << std::endl;
    }
    return 0;
}

DWORD WINAPI Consumer(LPVOID param) {
    int id = (int)(INT_PTR)param;
    int value;
    for (int i = 0; i < 10; i++) {
        while (!Dequeue(&g_queue, &value)) {
            Sleep(1); // íê°€ ë¹„ë©´ ì ì‹œ ëŒ€ê¸°
        }
        std::cout << "Consumer " << id << " <- " << value << std::endl;
    }
    return 0;
}

int main() {
    InitQueue(&g_queue);

    // ìƒì‚°ì 2ê°œ, ì†Œë¹„ì 2ê°œ
    HANDLE producers[2];
    HANDLE consumers[2];

    producers[0] = CreateThread(NULL, 0, Producer, (LPVOID)1, 0, NULL);
    producers[1] = CreateThread(NULL, 0, Producer, (LPVOID)2, 0, NULL);

    consumers[0] = CreateThread(NULL, 0, Consumer, (LPVOID)1, 0, NULL);
    consumers[1] = CreateThread(NULL, 0, Consumer, (LPVOID)2, 0, NULL);

    WaitForMultipleObjects(2, producers, TRUE, INFINITE);
    WaitForMultipleObjects(2, consumers, TRUE, INFINITE);

    return 0;
}
```
  

#### ë™ì‘ ê°œìš”
* **head/tail ê°±ì‹ ì„ CAS(InterlockedCompareExchange)** ë¡œ êµ¬í˜„ â†’ ë‹¤ì¤‘ ìƒì‚°ì/ì†Œë¹„ìì—ì„œë„ ì•ˆì „.
* **Enqueue**: tail í™•ë³´ â†’ ë°ì´í„° ê¸°ë¡.
* **Dequeue**: head í™•ë³´ â†’ ë°ì´í„° ì½ê¸°.
* íê°€ ê°€ë“ ì°¨ë©´ `false`, íê°€ ë¹„ë©´ `false` ë°˜í™˜.
* ê³ ì • í¬ê¸°ë¼ì„œ ì˜¤ë²„í”Œë¡œìš° ì—†ìŒ(ë‹¤ë§Œ ë²„í¼ ì‚¬ì´ì¦ˆ ì œí•œ ì¡´ì¬).
  
ğŸ‘‰ ì´ ë²„ì „ì€ êµìœ¡ìš©ìœ¼ë¡œ ìµœëŒ€í•œ ë‹¨ìˆœí™”í•œ ê²ƒì´ê³ , ì‹¤ì œ ê³ ì„±ëŠ¥ lock-free íëŠ” **ë©”ëª¨ë¦¬ ì¥ë²½(memory fence)**, **false sharing ë°©ì§€ íŒ¨ë”©** ë“±ì„ ê³ ë ¤í•´ì•¼ í•œë‹¤.


#### ê°œì„ ëœ ë²„ì „
ì•ì„œ ë§Œë“  **MPMC Lock-free í**ì— **MemoryBarrier** ë¥¼ ì¶”ê°€í•´ì„œ CPU ë©”ëª¨ë¦¬ ì¬ì •ë ¬ ë¬¸ì œê¹Œì§€ ë°©ì§€í•˜ëŠ” ë²„ì „ì´ë‹¤.

ìœˆë„ìš°ì˜ `Interlocked*` í•¨ìˆ˜ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ **í’€ ë©”ëª¨ë¦¬ ì¥ë²½(full fence)** ì„ ì œê³µí•˜ì§€ë§Œ, íì˜ ë°ì´í„°(`buffer`)ë¥¼ ì½ê³  ì“°ëŠ” ë¶€ë¶„ì€ `head` / `tail` ì¸ë±ìŠ¤ ë³€ê²½ê³¼ ë°˜ë“œì‹œ ìˆœì„œë¥¼ ë³´ì¥í•´ì•¼ í•˜ë¯€ë¡œ **ì¶”ê°€ MemoryBarrier() í˜¸ì¶œ**ì´ ì•ˆì „í•˜ë‹¤.


```cpp
#include <windows.h>
#include <iostream>

const int QUEUE_SIZE = 1024;

struct LockFreeQueue {
    volatile LONG head;
    volatile LONG tail;
    int buffer[QUEUE_SIZE];
};

void InitQueue(LockFreeQueue* q) {
    q->head = 0;
    q->tail = 0;
}

// Enqueue (ì—¬ëŸ¬ Producer)
bool Enqueue(LockFreeQueue* q, int value) {
    while (true) {
        LONG tail = q->tail;
        LONG head = q->head;
        LONG nextTail = (tail + 1) % QUEUE_SIZE;

        if (nextTail == head) {
            // íê°€ ê°€ë“ ì°¸
            return false;
        }

        if (InterlockedCompareExchange(&q->tail, nextTail, tail) == tail) {
            // ì¸ë±ìŠ¤ í™•ë³´ ì„±ê³µ
            MemoryBarrier(); // ì¸ë±ìŠ¤ ë³€ê²½ ì „ ë°˜ë“œì‹œ ë©”ëª¨ë¦¬ ë™ê¸°í™”
            q->buffer[tail] = value;
            MemoryBarrier(); // ê°’ ì“°ê¸° í›„ ë°˜ë“œì‹œ ì™„ë£Œ ë³´ì¥
            return true;
        }
        // ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„
    }
}

// Dequeue (ì—¬ëŸ¬ Consumer)
bool Dequeue(LockFreeQueue* q, int* outValue) {
    while (true) {
        LONG head = q->head;
        LONG tail = q->tail;

        if (head == tail) {
            // íê°€ ë¹„ì–´ ìˆìŒ
            return false;
        }

        LONG nextHead = (head + 1) % QUEUE_SIZE;

        if (InterlockedCompareExchange(&q->head, nextHead, head) == head) {
            MemoryBarrier(); // head ì—…ë°ì´íŠ¸ ì „ ë™ê¸°í™”
            *outValue = q->buffer[head];
            MemoryBarrier(); // ì½ê¸° ì™„ë£Œ ë³´ì¥
            return true;
        }
        // ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„
    }
}
```

```cpp
LockFreeQueue g_queue;

DWORD WINAPI Producer(LPVOID param) {
    int id = (int)(INT_PTR)param;
    for (int i = 0; i < 10; i++) {
        while (!Enqueue(&g_queue, id * 100 + i)) {
            Sleep(1); // íê°€ ê°€ë“ ì°¨ë©´ ì ì‹œ ëŒ€ê¸°
        }
        std::cout << "Producer " << id << " -> " << (id * 100 + i) << std::endl;
    }
    return 0;
}

DWORD WINAPI Consumer(LPVOID param) {
    int id = (int)(INT_PTR)param;
    int value;
    for (int i = 0; i < 10; i++) {
        while (!Dequeue(&g_queue, &value)) {
            Sleep(1); // íê°€ ë¹„ë©´ ì ì‹œ ëŒ€ê¸°
        }
        std::cout << "Consumer " << id << " <- " << value << std::endl;
    }
    return 0;
}

int main() {
    InitQueue(&g_queue);

    HANDLE producers[2];
    HANDLE consumers[2];

    producers[0] = CreateThread(NULL, 0, Producer, (LPVOID)1, 0, NULL);
    producers[1] = CreateThread(NULL, 0, Producer, (LPVOID)2, 0, NULL);

    consumers[0] = CreateThread(NULL, 0, Consumer, (LPVOID)1, 0, NULL);
    consumers[1] = CreateThread(NULL, 0, Consumer, (LPVOID)2, 0, NULL);

    WaitForMultipleObjects(2, producers, TRUE, INFINITE);
    WaitForMultipleObjects(2, consumers, TRUE, INFINITE);

    return 0;
}
```

##### ê°œì„  í¬ì¸íŠ¸
1. **MemoryBarrier() ì¶”ê°€**

   * ìƒì‚°ì: `tail` ì¸ë±ìŠ¤ í™•ë³´ â†’ `buffer`ì— ì“°ê¸° ìˆœì„œ ë³´ì¥.
   * ì†Œë¹„ì: `head` ì¸ë±ìŠ¤ í™•ë³´ â†’ `buffer` ì½ê¸° ìˆœì„œ ë³´ì¥.
   * CPUì˜ ë©”ëª¨ë¦¬ ì¬ì •ë ¬ ë° ìºì‹œ ë¬¸ì œë¡œ ì¸í•œ ë°ì´í„° ë¶ˆì¼ì¹˜ ë°©ì§€.

2. **InterlockedCompareExchange** ëŠ” ì›ìì  ë™ì‘ + í’€íœìŠ¤ë¥¼ ì œê³µí•˜ì§€ë§Œ, **ë°ì´í„° ì ‘ê·¼ ë¶€ë¶„ê¹Œì§€ í™•ì‹¤í•˜ê²Œ ë³´í˜¸**í•˜ê¸° ìœ„í•´ MemoryBarrierë¥¼ ë„£ëŠ” ê²ƒì´ ì•ˆì „í•˜ë‹¤.

  

### ë©”ëª¨ë¦¬ ì¥ë²½(memory barrier, fence)
ë©”ëª¨ë¦¬ ì¥ë²½(memory barrier, fence)ì€ **ì»´íŒŒì¼ëŸ¬ì™€ CPUê°€ ë©”ëª¨ë¦¬ ì ‘ê·¼ì„ ì¬ì •ë ¬í•˜ì§€ ëª»í•˜ê²Œ ë§‰ì•„ ì½”ë“œì— ê¸°ìˆ í•œ ìˆœì„œë¥¼ ëŒ€ë¡œ ë³´ì´ë„ë¡ ê°•ì œí•˜ëŠ” ì¥ì¹˜**ë‹¤. ë©€í‹°ì½”ì–´ í™˜ê²½ì—ì„œ ìŠ¤ë ˆë“œ ê°„ì— ê³µìœ  ë°ì´í„°ë¥¼ ì£¼ê³ ë°›ì„ ë•Œ **ê°€ì‹œì„±(visibility)**ê³¼ **ìˆœì„œ(ordering)**ë¥¼ ë³´ì¥í•˜ê¸° ìœ„í•´ í•„ìš”í•˜ë‹¤.


#### ì™œ í•„ìš”í•œê°€
1. **ì»´íŒŒì¼ëŸ¬ ì¬ì •ë ¬**ì´ ì¡´ì¬í•œë‹¤
   ìµœì í™”ë¥¼ ìœ„í•´ ì»´íŒŒì¼ëŸ¬ëŠ” ë…ë¦½ì ì¸ ë©”ëª¨ë¦¬ ì½ê¸°/ì“°ê¸°ë¥¼ ì•ë’¤ë¡œ ì´ë™ì‹œí‚¬ ìˆ˜ ìˆë‹¤. ì¥ë²½ì€ ì´ëŸ¬í•œ ì´ë™ì„ ê¸ˆì§€í•´ì¤€ë‹¤.

2. **CPU ì¬ì •ë ¬ê³¼ ìºì‹œ/ë²„í¼**ê°€ ì¡´ì¬í•œë‹¤
   í˜„ëŒ€ CPUëŠ” íŒŒì´í”„ë¼ì´ë‹ê³¼ ìŠ¤í† ì–´ ë²„í¼ ë•Œë¬¸ì— í”„ë¡œê·¸ë¨ ìˆœì„œëŒ€ë¡œ ë‹¤ë¥¸ ì½”ì–´ì— ë³´ì´ì§€ ì•Šì„ ìˆ˜ ìˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ í•œ ì½”ì–´ê°€ `data=42; ready=1;`ì„ ì‹¤í–‰í•´ë„ ë‹¤ë¥¸ ì½”ì–´ëŠ” `ready==1`ì„ ë¨¼ì € ë³´ê³  `data`ëŠ” ì•„ì§ ì´ì „ ê°’ìœ¼ë¡œ ë³¼ ìˆ˜ ìˆë‹¤.

3. **ë©€í‹°ì½”ì–´ ê°€ì‹œì„± ë¬¸ì œ**ë¥¼ í•´ê²°í•´ì•¼ í•œë‹¤
   í•œ ì½”ì–´ê°€ ì“´ ê°’ì´ ë‹¤ë¥¸ ì½”ì–´ ìºì‹œì— ì¦‰ì‹œ ë°˜ì˜ë˜ì§€ ì•Šì„ ìˆ˜ ìˆë‹¤. ì¥ë²½ì€ ì“°ê¸° ì „íŒŒì™€ ì½ê¸° ìˆœì„œë¥¼ ê°•ì œí•´ ì´ëŸ¬í•œ ê²½ìŸ ìƒí™©ì„ ì˜ˆë°©í•œë‹¤.


#### ë©”ëª¨ë¦¬ ì¥ë²½ì˜ ì¢…ë¥˜ì™€ ì˜ë¯¸
* **ì»´íŒŒì¼ëŸ¬ ì¥ë²½(compiler barrier)**: ì»´íŒŒì¼ëŸ¬ì—ê²Œ ì¬ì •ë ¬ ê¸ˆì§€ë¥¼ ì§€ì‹œí•˜ì§€ë§Œ CPUì—ê²ŒëŠ” ì•„ë¬´ ê²ƒë„ ê°•ì œí•˜ì§€ ì•ŠëŠ”ë‹¤. MSVCì˜ `_ReadWriteBarrier()`ê°€ ì—¬ê¸°ì— í•´ë‹¹í•œë‹¤.
* **CPU ì¥ë²½(hardware fence)**: CPUì˜ ì¬ì •ë ¬ê³¼ ë²„í¼ë§ê¹Œì§€ ì œì–´í•œë‹¤. Windowsì˜ `MemoryBarrier()`ê°€ ëŒ€í‘œì ì´ë‹¤.
* **íšë“/í•´ì œ(acquire/release) ì˜ë¯¸ë¡ **

  * **Acquire**: ì¥ë²½ ì´í›„ì˜ ì½ê¸°/ì“°ê¸°ê°€ **ì•ìœ¼ë¡œ ë„˜ì–´ê°€ì§€ ëª»í•˜ê²Œ** í•œë‹¤. ë³´í†µ â€œì½ê³  ë‚˜ì„œ ê·¸ ë’¤ì˜ ì‘ì—…ì„ ì‹œì‘í•˜ê¸° ì „ ì œë™â€ìœ¼ë¡œ ì´í•´í•˜ë©´ ëœë‹¤.
  * **Release**: ì¥ë²½ ì´ì „ì˜ ì½ê¸°/ì“°ê¸°ê°€ **ë’¤ë¡œ ë°€ë¦¬ì§€ ëª»í•˜ê²Œ** í•œë‹¤. ë³´í†µ â€œëª¨ë“  ì¤€ë¹„ë¥¼ ëë‚´ê³  ê³µê°œí•˜ê¸° ì§ì „ ì œë™â€ìœ¼ë¡œ ì´í•´í•˜ë©´ ëœë‹¤.
  * **Full fence**: Acquire + Releaseë¥¼ ëª¨ë‘ ë³´ì¥í•´ ì•ë’¤ ëª¨ë“  ì¬ì •ë ¬ì„ ë§‰ëŠ”ë‹¤.
* **ì„¸ë¶€ ë¶„ë¥˜ í‘œê¸°**
  ë¬¸í—Œì—ì„œëŠ” `Load-Load`, `Load-Store`, `Store-Load`, `Store-Store` ë“±ì˜ ìŒì´ ì–¸ê¸‰ë˜ë©°, íŠ¹íˆ `Store-Load` ë°©ì§€ë¥¼ ê°•í•˜ê²Œ ë³´ì¥í•˜ëŠ” ê²ƒì´ í’€ íœìŠ¤ì— í•´ë‹¹í•œë‹¤.


#### Windowsì™€ C++ì—ì„œì˜ ë„êµ¬

* **Windows**

  * `MemoryBarrier()`ëŠ” CPU ì „ë°˜ì— ëŒ€í•´ **í’€ íœìŠ¤**ë¥¼ ì œê³µí•œë‹¤.
  * `Interlocked*` ê³„ì—´ ì›ì ì—°ì‚°ì€ ì—°ì‚° ì „í›„ì— **í’€ íœìŠ¤ ì„±ì§ˆ**ì„ ê°–ë„ë¡ ì •ì˜ë˜ì–´ ìˆë‹¤. ì¦‰, ë‹¨ìˆœ ì¹´ìš´í„° ì¦ê°ì´ë‚˜ CASì— ìˆ˜ë°˜ë˜ëŠ” ê°€ì‹œì„±ê³¼ ìˆœì„œë¥¼ ìì²´ì ìœ¼ë¡œ í™•ë³´í•œë‹¤.
  * `_ReadWriteBarrier()`ëŠ” **ì»´íŒŒì¼ëŸ¬ ì¥ë²½**ì´ë‹¤. CPUëŠ” ë©ˆì¶”ì§€ ì•ŠëŠ”ë‹¤.
* **C++11 atomics**

  * `std::atomic`ê³¼ `std::atomic_thread_fence(memory_order)`ë¥¼ ì‚¬ìš©í•˜ë©´ ì´ì‹ì„± ìˆê²Œ ê°™ì€ ê°œë…ì„ í‘œí˜„í•  ìˆ˜ ìˆë‹¤.
  * ëŒ€í‘œì ì¸ ë©”ëª¨ë¦¬ ì˜¤ë”ëŠ” `memory_order_relaxed`, `acquire`, `release`, `acq_rel`, `seq_cst`ê°€ ìˆë‹¤. `seq_cst`ëŠ” ê°€ì¥ ê°•í•œ ìˆœì„œë¥¼ ì œê³µí•œë‹¤.



#### ì „í˜•ì  ë²„ê·¸ì™€ ìˆ˜ì • ì˜ˆ

##### 1) í”Œë˜ê·¸ë¡œ ê³µê°œí•˜ëŠ” íŒ¨í„´ì˜ ìœ„í—˜
ë‹¤ìŒ ì½”ë“œëŠ” ì•½í•œ ë©”ëª¨ë¦¬ ëª¨ë¸ì—ì„œëŠ” ì˜ëª» ë™ì‘í•  ìˆ˜ ìˆë‹¤.

```cpp
// ì˜ëª»ëœ ì˜ˆ
int g_data = 0;
volatile int g_ready = 0; // volatileë§Œìœ¼ë¡œëŠ” ì¶©ë¶„í•˜ì§€ ì•Šë‹¤

// Producer
g_data = 42;           // ë°ì´í„° ì‘ì„±
g_ready = 1;           // ê³µê°œ

// Consumer
while (g_ready == 0) { /* spin */ }
int x = g_data;        // ì—¬ê¸°ì„œ 0ì„ ì½ì„ ìˆ˜ ìˆë‹¤
```

`volatile`ì€ **ì›ìì„±ì´ë‚˜ ìŠ¤ë ˆë“œ ê°„ ìˆœì„œ ë³´ì¥**ì„ ì œê³µí•˜ì§€ ì•ŠëŠ”ë‹¤. Windowsì—ì„  ë‹¤ìŒì²˜ëŸ¼ ìˆ˜ì •í•œë‹¤.

```cpp
int g_data = 0;
LONG g_ready = 0;

// Producer
g_data = 42;
MemoryBarrier();                          // ë°ì´í„° ì“°ê¸° â†’ ê³µê°œ ìˆœì„œ ê³ ì •
InterlockedExchange(&g_ready, 1);         // ê³µê°œ

// Consumer
while (InterlockedCompareExchange(&g_ready, 1, 1) != 1) { /* spin */ }
MemoryBarrier();                          // ê³µê°œ í™•ì¸ â†’ ë°ì´í„° ì½ê¸° ìˆœì„œ ê³ ì •
int x = g_data;                           // í•­ìƒ 42ë¥¼ ì½ëŠ”ë‹¤
```

C++ í‘œì¤€ ë°©ì‹ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.

```cpp
std::atomic<int> ready{0};
int data = 0;

// Producer
data = 42;
ready.store(1, std::memory_order_release);

// Consumer
while (ready.load(std::memory_order_acquire) == 0) { /* spin */ }
int x = data; // release/acquireë¡œ ìˆœì„œê°€ ë³´ì¥ëœë‹¤
```

##### 2) SPSC/MPMC íì—ì„œì˜ ë°°ì¹˜
ìƒì‚°ìëŠ” **ë²„í¼ì— ë°ì´í„°ë¥¼ ë¨¼ì € ì“°ê³ **, ì¥ë²½ì„ ë‘ê³ , **ì¸ë±ìŠ¤ë¥¼ ê³µê°œ**í•´ì•¼ í•œë‹¤. ì†Œë¹„ìëŠ” **ì¸ë±ìŠ¤ë¥¼ ë¨¼ì € ì½ê³ **, ì¥ë²½ì„ ë‘ê³ , **ë²„í¼ì—ì„œ ë°ì´í„°ë¥¼ ì½ì–´ì•¼** í•œë‹¤.

```cpp
// Producer ìª½
q->buffer[pos] = value;   // ì‹¤ì œ ë°ì´í„° ê¸°ë¡
MemoryBarrier();          // ì“°ê¸° ì™„ë£Œë¥¼ ë³´ì´ê²Œ ë³´ì¥
InterlockedExchange(&q->tail, nextPos); // ê³µê°œ

// Consumer ìª½
LONG tail = InterlockedCompareExchange(&q->tail, 0, 0); // ì½ê¸°
if (head != tail) {
    MemoryBarrier();      // ê³µê°œ í™•ì¸ í›„ ì½ê¸° ìˆœì„œ ê³ ì •
    int v = q->buffer[head];
    // ...
}
```


#### x86ì€ ê°•í•œ ë©”ëª¨ë¦¬ ëª¨ë¸ì¸ë° ì™œ ì¥ë²½ì´ í•„ìš”í•œê°€
x86ì˜ TSO ëª¨ë¸ì€ ë¹„êµì  ê°•í•´ì„œ **Load-Load**ì™€ **Store-Store** ì¬ì •ë ¬ì„ í•˜ì§€ ì•ŠëŠ” ê²ƒìœ¼ë¡œ ì•Œë ¤ì ¸ ìˆë‹¤. ê·¸ëŸ¼ì—ë„ ë¶ˆêµ¬í•˜ê³  ë‹¤ìŒ ì´ìœ ë¡œ ì¥ë²½ì´ ì—¬ì „íˆ í•„ìš”í•˜ë‹¤.

* **ë‹¤ë¥¸ ì•„í‚¤í…ì²˜ ì´ì‹ì„±**ì„ ìœ„í•´ í•„ìš”í•˜ë‹¤. ARM, Power ë“±ì€ ë” ì•½í•œ ëª¨ë¸ì„ ì‚¬ìš©í•œë‹¤.
* **ì»´íŒŒì¼ëŸ¬ ì¬ì •ë ¬**ì€ ì•„í‚¤í…ì²˜ì™€ ë¬´ê´€í•˜ê²Œ ì¼ì–´ë‚  ìˆ˜ ìˆë‹¤.
* **ëª…ì‹œì  ì˜ë„ í‘œí˜„**ìœ¼ë¡œ ìœ ì§€ë³´ìˆ˜ì„±ì„ ë†’ì¸ë‹¤.


#### ì¥ë²½ê³¼ ë‹¤ë¥¸ ê°œë…ì˜ ì°¨ì´
* **ë½(CRITICAL_SECTION, SRWLock)**: ìƒí˜¸ ë°°ì œë¥¼ ì œê³µí•˜ë©´ì„œ ë‚´ë¶€ì ìœ¼ë¡œ í•„ìš”í•œ ë©”ëª¨ë¦¬ ì¥ë²½ì„ í•¨ê»˜ ì œê³µí•œë‹¤. ë½ì„ ì‚¬ìš©í•˜ë©´ ë³„ë„ì˜ ì¥ë²½ì„ ë„£ì„ í•„ìš”ê°€ ê±°ì˜ ì—†ë‹¤.
* **ì›ì ì—°ì‚°(Interlocked*)**: ì—°ì‚° ìì²´ê°€ ì›ìì ì´ë©° ëŒ€ê°œ í’€ íœìŠ¤ë¥¼ ë™ë°˜í•œë‹¤. ë‹¤ë§Œ ì—°ì‚° **ì£¼ë³€ì˜ ì¼ë°˜ ë©”ëª¨ë¦¬ ì ‘ê·¼**ê¹Œì§€ ì˜¬ë°”ë¥¸ ìˆœì„œë¥¼ ë³´ì¥í•˜ë ¤ë©´ ì ì ˆí•œ ìœ„ì¹˜ì— ì¥ë²½ì„ ì¶”ê°€í•´ì•¼ í•  ìˆ˜ ìˆë‹¤.
* **volatile**: I/O ë©”ëª¨ë¦¬ ì ‘ê·¼ ë³´ì¥ì´ë‚˜ ìµœì í™” ì–µì œ ìš©ë„ë¡œ ì“°ì´ë©°, **ë™ê¸°í™” ë³´ì¥**ì´ ì•„ë‹ˆë‹¤. ë™ê¸°í™”ì— ì‚¬ìš©í•˜ì§€ ë§ì•„ì•¼ í•œë‹¤.

#### ì‹¤ì „ ì²´í¬ë¦¬ìŠ¤íŠ¸
1. **ë°ì´í„°ë¥¼ ë¨¼ì € ì“°ê³  â†’ release ì„±ì§ˆì˜ ì¥ë²½ â†’ â€œì¤€ë¹„ë¨â€ ì‹ í˜¸ë¥¼ ê°±ì‹ **í•œë‹¤.
2. **ì‹ í˜¸ë¥¼ ë¨¼ì € í™•ì¸í•˜ê³  â†’ acquire ì„±ì§ˆì˜ ì¥ë²½ â†’ ë°ì´í„°ë¥¼ ì½ëŠ”ë‹¤**.
3. Interlocked ì—°ì‚°ì€ í’€ íœìŠ¤ì´ì§€ë§Œ, **ë²„í¼ ì ‘ê·¼ê³¼ ê³µê°œ ì‚¬ì´ì˜ ìˆœì„œ**ë¥¼ ëª…í™•íˆ í•˜ë ¤ë©´ `MemoryBarrier()`ë¥¼ ë„£ëŠ”ë‹¤.
4. ê°€ëŠ¥í•œ ê²½ìš° **ë½ì´ë‚˜ `std::atomic`** ê°™ì€ ê³ ìˆ˜ì¤€ ë„êµ¬ë¥¼ ìš°ì„  ì‚¬ìš©í•œë‹¤.
5. ê³¼ë„í•œ ì¥ë²½ì€ ì„±ëŠ¥ì„ ë–¨ì–´ëœ¨ë¦¬ë¯€ë¡œ **í•„ìš” ìµœì†Œí•œ**ìœ¼ë¡œ ë°°ì¹˜í•œë‹¤.


#### ìš”ì•½
ë©”ëª¨ë¦¬ ì¥ë²½ì€ ë©€í‹°ìŠ¤ë ˆë“œ í”„ë¡œê·¸ë¨ì—ì„œ **ë‹¤ë¥¸ ì½”ì–´ê°€ ê´€ì°°í•˜ëŠ” ë©”ëª¨ë¦¬ ì ‘ê·¼ì˜ ìˆœì„œì™€ ê°€ì‹œì„±**ì„ í†µì œí•˜ëŠ” í•„ìˆ˜ ë„êµ¬ë‹¤. Windowsì—ì„œëŠ” `MemoryBarrier()`ì™€ `Interlocked*`ë¥¼ ì´ìš©í•´ êµ¬í˜„í•  ìˆ˜ ìˆìœ¼ë©°, C++ í‘œì¤€ì—ì„œëŠ” `std::atomic`ì˜ acquire/release í˜¹ì€ `atomic_thread_fence`ë¡œ ê°™ì€ ê°œë…ì„ í‘œí˜„í•  ìˆ˜ ìˆë‹¤. ì¥ë²½ì„ ì ì ˆíˆ ë°°ì¹˜í•˜ë©´ í”Œë˜ê·¸ ê³µê°œ, lock-free í, ì°¸ì¡° ì¹´ìš´íŒ…, ì´ì¤‘ ì²´í¬ ì´ˆê¸°í™” ê°™ì€ íŒ¨í„´ì—ì„œ **ìˆœì„œ ê¹¨ì§ìœ¼ë¡œ ì¸í•œ í¬ê·€í•œ ë²„ê·¸**ë¥¼ ì˜ˆë°©í•  ìˆ˜ ìˆë‹¤.
  
  
</br>  
</br>  
</br>  
  
  
-----  
  
## í•µì‹¬ ìš©ì–´ì™€ ê°œë…ë“¤
**íë¦„ ì œì–´ (Flow Control):**
ì‘ì—…ë“¤ ê°„ì˜ ì‹¤í–‰ ìˆœì„œë¥¼ ë³´ì¥í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ íŒŒì¼ì„ ë‹¤ìš´ë¡œë“œí•œ í›„ì— ì••ì¶•ì„ í’€ì–´ì•¼ í•œë‹¤ë©´, ë‹¤ìš´ë¡œë“œ ì™„ë£Œë¥¼ ê¸°ë‹¤ë¦° í›„ ì••ì¶• í•´ì œ ì‘ì—…ì„ ì‹œì‘í•´ì•¼ í•©ë‹ˆë‹¤. ì´ë²¤íŠ¸ ê°ì²´ë‚˜ ì„¸ë§ˆí¬ì–´ ë“±ìœ¼ë¡œ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**ê²½ìŸ ì¡°ê±´ (Race Condition):**
ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ê°™ì€ ë°ì´í„°ë¥¼ ìˆ˜ì •í•  ë•Œ ë°œìƒí•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ `counter++` ì—°ì‚°ì€ ì‹¤ì œë¡œëŠ” ì½ê¸°-ì¦ê°€-ì“°ê¸°ì˜ 3ë‹¨ê³„ë¡œ ì´ë£¨ì–´ì§€ëŠ”ë°, ë‘ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ì‹¤í–‰í•˜ë©´ ì˜ˆìƒê³¼ ë‹¤ë¥¸ ê²°ê³¼ê°€ ë‚˜ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**ì›ìì„± (Atomicity):**
ì¤‘ë‹¨ë  ìˆ˜ ì—†ëŠ” ë‹¨ì¼ ì—°ì‚°ì„ ì˜ë¯¸í•©ë‹ˆë‹¤. Win32ì˜ `InterlockedIncrement()` ê°™ì€ í•¨ìˆ˜ë“¤ì´ ì›ìì  ì—°ì‚°ì„ ì œê³µí•©ë‹ˆë‹¤. ì›ìì  ì—°ì‚°ì€ ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ì¤‘ê°„ ìƒíƒœë¥¼ ë³¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.

**ìƒí˜¸ ë°°ì œ (Mutual Exclusion):**
í•œ ë²ˆì— í•˜ë‚˜ì˜ ìŠ¤ë ˆë“œë§Œ ê³µìœ  ìì›ì— ì ‘ê·¼í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. Critical Sectionì´ë‚˜ Mutex ë“±ìœ¼ë¡œ êµ¬í˜„í•©ë‹ˆë‹¤.

**ë°ë“œë½ (Deadlock):**
ë‘ ê°œ ì´ìƒì˜ ìŠ¤ë ˆë“œê°€ ì„œë¡œê°€ ê°€ì§„ ìì›ì„ ê¸°ë‹¤ë¦¬ë©° ì˜ì›íˆ ëŒ€ê¸°í•˜ëŠ” ìƒí™©ì…ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ìŠ¤ë ˆë“œ Aê°€ ë®¤í…ìŠ¤ 1ì„ ê°€ì§€ê³  ë®¤í…ìŠ¤ 2ë¥¼ ê¸°ë‹¤ë¦¬ê³ , ìŠ¤ë ˆë“œ Bê°€ ë®¤í…ìŠ¤ 2ë¥¼ ê°€ì§€ê³  ë®¤í…ìŠ¤ 1ì„ ê¸°ë‹¤ë¦¬ëŠ” ê²½ìš°ì…ë‹ˆë‹¤.

**ê¸°ì•„ ìƒíƒœ (Starvation):**
íŠ¹ì • ìŠ¤ë ˆë“œê°€ ê³„ì†í•´ì„œ ì‹¤í–‰ ê¸°íšŒë¥¼ ì–»ì§€ ëª»í•˜ëŠ” ìƒí™©ì…ë‹ˆë‹¤. ë†’ì€ ìš°ì„ ìˆœìœ„ì˜ ìŠ¤ë ˆë“œë“¤ì´ ê³„ì† ì‹¤í–‰ë˜ì–´ ë‚®ì€ ìš°ì„ ìˆœìœ„ ìŠ¤ë ˆë“œê°€ ì‹¤í–‰ë˜ì§€ ëª»í•˜ëŠ” ê²½ìš°ê°€ ëŒ€í‘œì ì…ë‹ˆë‹¤.

**ê°€ì‹œì„± (Visibility):**
í•œ ìŠ¤ë ˆë“œì—ì„œ ë³€ê²½í•œ ë©”ëª¨ë¦¬ ê°’ì´ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ì„œ ì–¸ì œ ë³´ì´ê²Œ ë˜ëŠ”ê°€ì˜ ë¬¸ì œì…ë‹ˆë‹¤. CPU ìºì‹œì™€ ì»´íŒŒì¼ëŸ¬ ìµœì í™” ë•Œë¬¸ì— ì¦‰ì‹œ ë³´ì´ì§€ ì•Šì„ ìˆ˜ ìˆì–´ì„œ ë©”ëª¨ë¦¬ ë°°ë¦¬ì–´ë‚˜ `volatile` í‚¤ì›Œë“œê°€ í•„ìš”í•©ë‹ˆë‹¤.

**False Sharing:**
ì„œë¡œ ë…ë¦½ì ì¸ ë‘ ë³€ìˆ˜ê°€ ê°™ì€ ìºì‹œ ë¼ì¸(ë³´í†µ 64ë°”ì´íŠ¸)ì— ìœ„ì¹˜í•  ë•Œ, í•œ ìŠ¤ë ˆë“œê°€ ë³€ìˆ˜ë¥¼ ìˆ˜ì •í•˜ë©´ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì˜ ìºì‹œ ë¼ì¸ê¹Œì§€ ë¬´íš¨í™”ë˜ì–´ ì„±ëŠ¥ì´ ì €í•˜ë˜ëŠ” í˜„ìƒì…ë‹ˆë‹¤. êµ¬ì¡°ì²´ ë©¤ë²„ë“¤ì„ ì ì ˆíˆ ë°°ì¹˜í•˜ê±°ë‚˜ íŒ¨ë”©ì„ ì‚¬ìš©í•´ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.