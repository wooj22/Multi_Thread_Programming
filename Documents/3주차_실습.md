# 3주차 실습  
  
## 과제 1: 기본 - 플레이어 체력 회복 시스템
`_beginthreadex`와 `WaitForSingleObject`의 기본 사용법을 익히고, 단일 스레드의 생명주기를 이해한다.
  
**문제**: 게임에서 플레이어가 데미지를 받은 후 시간이 지나면서 체력이 자동으로 회복되는 시스템을 구현하세요.

**요구사항**:
- `_beginthreadex`로 체력 회복 스레드 생성
- 메인 스레드에서 `WaitForSingleObject`로 회복 완료 대기
- 체력이 100%가 되면 스레드 종료

**해답**:
```cpp
#include <iostream>
#include <windows.h>
#include <process.h>

struct PlayerData 
{
    int health;
    int maxHealth;
    bool isHealing;
};

unsigned __stdcall HealthRecoveryThread(void* param) 
{
    PlayerData* player = (PlayerData*)param;
    
    std::cout << "체력 회복 시작! 현재 체력: " << player->health << "/" << player->maxHealth << std::endl;
    
    while (player->health < player->maxHealth) {
        Sleep(1000); // 1초 대기
        player->health += 10; // 10씩 회복
        if (player->health > player->maxHealth) {
            player->health = player->maxHealth;
        }
        
        std::cout << "체력 회복 중... " << player->health << "/" << player->maxHealth << std::endl;
    }
    
    player->isHealing = false;
    std::cout << "체력이 완전히 회복되었습니다!" << std::endl;
    return 0;
}

int main() 
{
    PlayerData player = { 30, 100, true }; // 현재 체력 30, 최대 체력 100
    
    // 체력 회복 스레드 생성
    HANDLE hThread = (HANDLE)_beginthreadex(
        NULL, 0, HealthRecoveryThread, &player, 0, NULL
    );
    
    if (hThread == NULL) {
        std::cout << "스레드 생성 실패!" << std::endl;
        return -1;
    }
    
    std::cout << "메인 게임 루프 실행 중..." << std::endl;
    
    // 체력 회복 완료까지 대기
    WaitForSingleObject(hThread, INFINITE);
    
    std::cout << "체력 회복이 완료되어 게임을 계속할 수 있습니다!" << std::endl;
    
    CloseHandle(hThread);
    return 0;
}
```

---

## 과제 2: 중간 - 여러 NPC 작업 관리 시스템
여러 스레드를 동시에 관리하고 `WaitForMultipleObjects`의 `bWaitAll = TRUE` 옵션을 사용하여 모든 작업 완료를 대기하는 방법을 학습한다.  

**문제**: 게임에서 여러 NPC가 동시에 각자 다른 작업(상점 운영, 경비, 제작)을 수행하는 시스템을 구현하세요.

**요구사항**:
- 3개의 NPC 스레드를 `_beginthreadex`로 생성
- `WaitForMultipleObjects`로 모든 NPC 작업 완료 대기
- 각 NPC는 서로 다른 시간에 작업 완료

**해답**:
```cpp
#include <iostream>
#include <windows.h>
#include <process.h>
#include <string>

struct NPCData {
    std::string name;
    std::string job;
    int workTime; // 작업 시간 (초)
};

unsigned __stdcall NPCWorkThread(void* param) {
    NPCData* npc = (NPCData*)param;
    
    std::cout << npc->name << "이(가) " << npc->job << " 작업을 시작합니다." << std::endl;
    
    for (int i = 1; i <= npc->workTime; ++i) {
        Sleep(1000);
        std::cout << npc->name << ": " << npc->job << " 진행 중... (" 
                  << i << "/" << npc->workTime << ")" << std::endl;
    }
    
    std::cout << npc->name << "이(가) " << npc->job << " 작업을 완료했습니다!" << std::endl;
    return 0;
}

int main() {
    // NPC 데이터 설정
    NPCData npcs[3] = {
        {"상인 앤", "상점 운영", 3},
        {"경비병 밥", "마을 경비", 5},
        {"대장장이 찰리", "무기 제작", 4}
    };
    
    HANDLE hThreads[3];
    
    // 모든 NPC 스레드 생성
    for (int i = 0; i < 3; ++i) {
        hThreads[i] = (HANDLE)_beginthreadex(
            NULL, 0, NPCWorkThread, &npcs[i], 0, NULL
        );
        
        if (hThreads[i] == NULL) {
            std::cout << "스레드 " << i << " 생성 실패!" << std::endl;
            return -1;
        }
    }
    
    std::cout << "모든 NPC가 작업을 시작했습니다. 완료를 기다리는 중..." << std::endl;
    
    // 모든 NPC 작업 완료까지 대기
    WaitForMultipleObjects(3, hThreads, TRUE, INFINITE);
    
    std::cout << "\n모든 NPC 작업이 완료되었습니다! 마을이 정상 운영됩니다." << std::endl;
    
    // 핸들 정리
    for (int i = 0; i < 3; ++i) {
        CloseHandle(hThreads[i]);
    }
    
    return 0;
}
```

---

## 과제 3: 고급 - 게임 리소스 로딩 시스템  
`WaitForMultipleObjects`의 `bWaitAll = FALSE` 옵션을 활용하여 우선순위가 있는 작업들을 효율적으로 관리하는 방법을 익힌다.  
  
**문제**: 게임 시작 시 여러 리소스(텍스처, 사운드, 맵 데이터)를 동시에 로딩하되, 필수 리소스가 먼저 로딩되면 게임을 시작할 수 있는 시스템을 구현하세요.

**요구사항**:
- 4개의 리소스 로딩 스레드 생성
- `WaitForMultipleObjects`의 `bWaitAll = FALSE` 옵션 활용
- 필수 리소스 로딩 완료 시 게임 시작, 나머지는 백그라운드에서 계속 로딩

**해답**:
```cpp
#include <iostream>
#include <windows.h>
#include <process.h>
#include <string>

struct ResourceData 
{
    std::string name;
    bool isEssential; // 필수 리소스 여부
    int loadTime;     // 로딩 시간 (초)
    bool isLoaded;    // 로딩 완료 여부
};

unsigned __stdcall ResourceLoadThread(void* param) 
{
    ResourceData* resource = (ResourceData*)param;
    
    std::cout << "[로딩 시작] " << resource->name;
    if (resource->isEssential) {
        std::cout << " (필수)";
    }
    std::cout << std::endl;
    
    for (int i = 1; i <= resource->loadTime; ++i) {
        Sleep(1000);
        std::cout << resource->name << " 로딩 중... (" 
                  << i << "/" << resource->loadTime << ")" << std::endl;
    }
    
    resource->isLoaded = true;
    std::cout << "[로딩 완료] " << resource->name << std::endl;
    return 0;
}

int main() 
{
    // 리소스 데이터 설정
    ResourceData resources[4] = {
        {"기본 텍스처", true, 2},    // 필수
        {"플레이어 모델", true, 3},   // 필수
        {"배경음악", false, 5},       // 선택적
        {"효과음", false, 4}          // 선택적
    };
    
    HANDLE hThreads[4];
    HANDLE hEssentialThreads[2]; // 필수 리소스만
    int essentialCount = 0;
    
    // 모든 리소스 로딩 스레드 생성
    for (int i = 0; i < 4; ++i) {
        hThreads[i] = (HANDLE)_beginthreadex(
            NULL, 0, ResourceLoadThread, &resources[i], 0, NULL
        );
        
        if (hThreads[i] == NULL) {
            std::cout << "스레드 " << i << " 생성 실패!" << std::endl;
            return -1;
        }
        
        // 필수 리소스 핸들 따로 저장
        if (resources[i].isEssential) {
            hEssentialThreads[essentialCount++] = hThreads[i];
        }
    }
    
    std::cout << "\n게임 리소스 로딩을 시작합니다..." << std::endl;
    std::cout << "필수 리소스 로딩 완료 시 게임이 시작됩니다.\n" << std::endl;
    
    // 필수 리소스만 완료되기를 대기 (bWaitAll = TRUE)
    WaitForMultipleObjects(essentialCount, hEssentialThreads, TRUE, INFINITE);
    
    std::cout << "\n=== 필수 리소스 로딩 완료! 게임을 시작합니다! ===" << std::endl;
    std::cout << "선택적 리소스는 백그라운드에서 계속 로딩됩니다...\n" << std::endl;
    
    // 게임 시뮬레이션 (3초)
    for (int i = 1; i <= 3; ++i) {
        Sleep(1000);
        std::cout << "게임 플레이 중... (" << i << "/3)" << std::endl;
    }
    
    std::cout << "\n모든 리소스 로딩 완료를 기다립니다..." << std::endl;
    
    // 나머지 모든 리소스 완료 대기
    WaitForMultipleObjects(4, hThreads, TRUE, INFINITE);
    
    std::cout << "\n모든 리소스 로딩이 완료되었습니다!" << std::endl;
    std::cout << "이제 모든 게임 기능을 사용할 수 있습니다." << std::endl;
    
    // 핸들 정리
    for (int i = 0; i < 4; ++i) {
        CloseHandle(hThreads[i]);
    }
    
    return 0;
}
```

## 과제 4: 고급 - 실시간 멀티플레이어 턴 기반 전투 시스템
다음을 학습한다:
- `WaitForMultipleObjects`의 타임아웃 기능 활용
- `WAIT_TIMEOUT` 처리를 통한 조건부 로직 구현
- 실시간 게임에서의 동기화 패턴
  
**문제**: 4명의 플레이어가 동시에 행동을 선택하고, 모든 플레이어가 선택을 완료하거나 제한 시간이 지나면 전투를 진행하는 시스템을 구현하세요.

**요구사항**:
- 각 플레이어는 별도 스레드에서 행동 선택 (1-5초 랜덤)
- 30초 제한 시간 내에 모든 플레이어가 선택하면 즉시 전투 진행
- 제한 시간 초과 시 선택하지 않은 플레이어는 기본 공격으로 처리
- `WaitForMultipleObjects`의 타임아웃 기능 활용

**해답**:
```cpp
#include <iostream>
#include <windows.h>
#include <process.h>
#include <string>
#include <cstdlib>
#include <ctime>

struct PlayerAction 
{
    int playerId;
    std::string playerName;
    std::string action;
    bool hasSelected;
    int thinkingTime; // 사고 시간 (초)
};

unsigned __stdcall PlayerThinkingThread(void* param) 
{
    PlayerAction* player = (PlayerAction*)param;
    
    std::cout << player->playerName << "이(가) 행동을 고민하고 있습니다..." << std::endl;
    
    // 랜덤한 사고 시간 (1-5초)
    Sleep(player->thinkingTime * 1000);
    
    // 랜덤 액션 선택
    std::string actions[] = {"공격", "방어", "스킬", "아이템", "도망"};
    player->action = actions[rand() % 5];
    player->hasSelected = true;
    
    std::cout << "[선택 완료] " << player->playerName << " -> " << player->action << std::endl;
    return 0;
}

int main() 
{
    srand((unsigned int)time(NULL));
    
    // 플레이어 데이터 설정
    PlayerAction players[4];
    std::string names[] = {"전사 아서", "마법사 멀린", "도적 로빈", "성기사 갈라하드"};
    
    for (int i = 0; i < 4; ++i) {
        players[i] = {i + 1, names[i], "", false, (rand() % 5) + 1};
    }
    
    HANDLE hThreads[4];
    
    std::cout << "=== 턴 기반 전투 시작! ===" << std::endl;
    std::cout << "제한 시간: 30초" << std::endl;
    std::cout << "모든 플레이어가 행동을 선택해주세요!\n" << std::endl;
    
    // 모든 플레이어 사고 스레드 시작
    for (int i = 0; i < 4; ++i) {
        hThreads[i] = (HANDLE)_beginthreadex(
            NULL, 0, PlayerThinkingThread, &players[i], 0, NULL
        );
        
        if (hThreads[i] == NULL) {
            std::cout << "플레이어 " << i + 1 << " 스레드 생성 실패!" << std::endl;
            return -1;
        }
    }
    
    // 30초 타임아웃으로 모든 플레이어 선택 대기
    DWORD waitResult = WaitForMultipleObjects(4, hThreads, TRUE, 30000); // 30초
    
    std::cout << "\n=== 선택 시간 종료! ===" << std::endl;
    
    if (waitResult == WAIT_OBJECT_0) {
        std::cout << "모든 플레이어가 시간 내에 행동을 선택했습니다!" << std::endl;
    } else if (waitResult == WAIT_TIMEOUT) {
        std::cout << "제한 시간이 초과되었습니다!" << std::endl;
        
        // 선택하지 않은 플레이어들 기본 행동 처리
        for (int i = 0; i < 4; ++i) {
            if (!players[i].hasSelected) {
                players[i].action = "기본 공격";
                std::cout << "[자동 선택] " << players[i].playerName << " -> 기본 공격" << std::endl;
            }
        }
    } else {
        std::cout << "대기 중 오류가 발생했습니다!" << std::endl;
    }
    
    // 전투 결과 출력
    std::cout << "\n=== 전투 진행 ===\n" << std::endl;
    for (int i = 0; i < 4; ++i) {
        std::cout << players[i].playerName << "의 행동: " << players[i].action << std::endl;
        Sleep(500); // 전투 연출
    }
    
    std::cout << "\n전투가 완료되었습니다!" << std::endl;
    
    // 핸들 정리
    for (int i = 0; i < 4; ++i) {
        CloseHandle(hThreads[i]);
    }
    
    return 0;
}
```

