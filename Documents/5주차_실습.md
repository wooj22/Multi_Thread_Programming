# 5주차 과제    
  

## 문제 1: 스레드 안전한 작업 카운터 만들기
**요구사항:**
여러 개의 스레드가 동시에 `Work()` 함수를 호출한다. `Work()` 함수는 시간이 걸리는 작업을 흉내 내기 위해 `Sleep()`을 사용한다. 전역 변수 `g_workCount`를 사용하여 현재 몇 개의 스레드가 `Work()` 함수를 실행 중인지 추적해야 한다. `Interlocked` 함수를 사용하여 `g_workCount`를 스레드에 안전하게 증가시키고 감소시킨다.

**실습 코드:**

```cpp
#include <windows.h>
#include <iostream>
#include <vector>

#define NUM_THREADS 10
#define MAX_CONCURRENT_WORKS 3 // 동시에 최대 3개까지만 작업 허용

LONG g_workCount = 0; // 현재 작업 중인 스레드 수

void Work() {
    // TODO 1: 현재 작업 중인 스레드 수를 원자적으로 1 증가시키고,
    // 그 결과(증가 후의 값)를 newCount 변수에 저장하세요.
    LONG newCount = 0; // 이 부분을 수정하세요.

    if (newCount > MAX_CONCURRENT_WORKS) {
        printf("[Thread %lu] 작업량이 많아 실행하지 못했습니다. (현재 %ld개 실행 중)\n", GetCurrentThreadId(), newCount);
    } else {
        printf("[Thread %lu] 작업 시작! (현재 %ld개 실행 중)\n", GetCurrentThreadId(), newCount);
        Sleep(100); // 작업을 흉내 냅니다.
        printf("[Thread %lu] 작업 완료!\n", GetCurrentThreadId());
    }

    // TODO 2: 작업이 끝났으므로, 현재 작업 중인 스레드 수를 원자적으로 1 감소시키세요.
    
}

DWORD WINAPI ThreadProc(LPVOID lpParam) {
    for (int i = 0; i < 5; ++i) {
        Work();
        Sleep(50);
    }
    return 0;
}

int main() {
    std::vector<HANDLE> hThreads;
    for (int i = 0; i < NUM_THREADS; ++i) {
        HANDLE hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);
        if (hThread) {
            hThreads.push_back(hThread);
        }
    }

    WaitForMultipleObjects(hThreads.size(), hThreads.data(), TRUE, INFINITE);

    for (HANDLE hThread : hThreads) {
        CloseHandle(hThread);
    }

    printf("모든 스레드 실행 완료. 최종 작업 카운트: %ld\n", g_workCount); // 최종적으로 0이 되어야 함
    return 0;
}
```

**정답 및 해설:**

```cpp
// ... (생략) ...

void Work() {
    // TODO 1: 현재 작업 중인 스레드 수를 원자적으로 1 증가시키고,
    // 그 결과(증가 후의 값)를 newCount 변수에 저장하세요.
    LONG newCount = InterlockedIncrement(&g_workCount);

    if (newCount > MAX_CONCURRENT_WORKS) {
        printf("[Thread %lu] 작업량이 많아 실행하지 못했습니다. (현재 %ld개 실행 중)\n", GetCurrentThreadId(), newCount);
    } else {
        printf("[Thread %lu] 작업 시작! (현재 %ld개 실행 중)\n", GetCurrentThreadId(), newCount);
        Sleep(100); // 작업을 흉내 냅니다.
        printf("[Thread %lu] 작업 완료!\n", GetCurrentThreadId());
    }

    // TODO 2: 작업이 끝났으므로, 현재 작업 중인 스레드 수를 원자적으로 1 감소시키세요.
    InterlockedDecrement(&g_workCount);
}

// ... (생략) ...
```

  * **해설**:
      * `InterlockedIncrement(&g_workCount)`: 여러 스레드가 동시에 접근해도 `g_workCount`를 안전하게 1 증가시킵니다. **연산 후의 값**을 반환하므로, 현재 몇 개의 작업이 실행 중인지 즉시 알 수 있습니다.
      * `InterlockedDecrement(&g_workCount)`: 작업이 끝난 후 카운트를 안전하게 1 감소시켜 다른 스레드가 진입할 수 있도록 합니다. 이 두 함수를 사용함으로써 `g_workCount`는 항상 정확한 값을 유지하게 됩니다.

-----
  

## 문제 2: 단 한번만 실행되는 초기화 구현하기

**요구사항:**
여러 스레드가 `InitializeResource()` 함수를 호출하지만, 실제 리소스 초기화 작업(`printf`로 대체)은 단 한 번만 수행되어야 한다. `Interlocked` 함수를 사용하여 첫 번째로 이 함수를 호출한 스레드만 초기화 코드를 실행하도록 만들자.

**실습 코드:**

```cpp
#include <windows.h>
#include <iostream>
#include <vector>

#define NUM_THREADS 5

LONG g_initialized = 0; // 0: 초기화 안됨, 1: 초기화 완료

void InitializeResource() {
    // TODO: g_initialized 값을 1로 바꾸되,
    // 오직 바꾸기 전의 값이 0이었던 스레드만 아래 "리소스 초기화" 코드를 실행하도록 만드세요.
    // 힌트: 값을 교환(Exchange)하고 이전 값을 반환하는 함수를 사용하세요.


    // if (이전 값이 0이었다면?) {
    //     printf("[Thread %lu] 리소스 초기화 수행!\n", GetCurrentThreadId());
    // } else {
    //     printf("[Thread %lu] 이미 다른 스레드가 초기화를 완료했습니다.\n", GetCurrentThreadId());
    // }
}

DWORD WINAPI ThreadProc(LPVOID lpParam) {
    InitializeResource();
    return 0;
}

int main() {
    std::vector<HANDLE> hThreads;
    for (int i = 0; i < NUM_THREADS; ++i) {
        HANDLE hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);
        if (hThread) {
            hThreads.push_back(hThread);
        }
    }

    WaitForMultipleObjects(hThreads.size(), hThreads.data(), TRUE, INFINITE);

    for (HANDLE hThread : hThreads) {
        CloseHandle(hThread);
    }
    return 0;
}
```

**정답 및 해설:**

```cpp
// ... (생략) ...

void InitializeResource() {
    // TODO: g_initialized 값을 1로 바꾸되,
    // 오직 바꾸기 전의 값이 0이었던 스레드만 아래 "리소스 초기화" 코드를 실행하도록 만드세요.
    if (InterlockedExchange(&g_initialized, 1) == 0) {
        printf("[Thread %lu] 리소스 초기화 수행!\n", GetCurrentThreadId());
    } else {
        printf("[Thread %lu] 이미 다른 스레드가 초기화를 완료했습니다.\n", GetCurrentThreadId());
    }
}

// ... (생략) ...
```

  * **해설**:
      * `InterlockedExchange(&g_initialized, 1)`는 `g_initialized`의 값을 원자적으로 `1`로 설정하고, **설정하기 전의 원래 값**을 반환합니다.
      * 가장 먼저 도착한 스레드는 `g_initialized`가 `0`이었으므로 `0`을 반환받아 `if`문 안의 초기화 코드를 실행합니다.
      * 그 뒤에 도착하는 스레드들은 `g_initialized`가 이미 `1`로 바뀐 상태이므로 `1`을 반환받아 `else` 문을 실행하게 됩니다.

-----
  

## 문제 3: CAS를 이용한 Lock-Free 데이터 업데이트

**요구사항:**
전역 변수 `g_value`가 있다. 스레드는 `g_value`가 특정 값(`expectedValue`)일 때만 새로운 값(`newValue`)으로 업데이트해야 한다. 이러한 '비교 후 교체' 연산을 `InterlockedCompareExchange` (CAS)를 사용하여 구현한다.

**실습 코드:**

```cpp
#include <windows.h>
#include <iostream>

LONG g_value = 100;

// g_value가 expectedValue와 같을 때만 newValue로 업데이트하는 함수
void UpdateValue(LONG newValue, LONG expectedValue) {
    LONG originalValue;

    // TODO: g_value의 현재 값이 expectedValue와 같으면 newValue로 교체하세요.
    // InterlockedCompareExchange 함수를 사용하고, 반환값(교체 전의 값)을 originalValue에 저장하세요.
    // originalValue = ...

    if (originalValue == expectedValue) {
        printf("[성공] 값이 %ld에서 %ld로 변경되었습니다.\n", originalValue, g_value);
    } else {
        printf("[실패] 값 변경 시도 실패. (기대값: %ld, 현재값: %ld)\n", expectedValue, originalValue);
    }
}

int main() {
    printf("초기값: %ld\n", g_value);

    // 성공 케이스: g_value가 100일 때 200으로 변경 시도
    UpdateValue(200, 100);

    // 실패 케이스: g_value가 100일 때 300으로 변경 시도 (기대값이 틀림)
    UpdateValue(300, 100); // 이 시점에서 g_value는 이미 200이므로 실패해야 함

    printf("최종값: %ld\n", g_value);
    return 0;
}
```

**정답 및 해설:**

```cpp
// ... (생략) ...

void UpdateValue(LONG newValue, LONG expectedValue) {
    LONG originalValue;

    // TODO: g_value의 현재 값이 expectedValue와 같으면 newValue로 교체하세요.
    originalValue = InterlockedCompareExchange(&g_value, newValue, expectedValue);

    if (originalValue == expectedValue) {
        printf("[성공] 값이 %ld에서 %ld로 변경되었습니다.\n", originalValue, g_value);
    } else {
        printf("[실패] 값 변경 시도 실패. (기대값: %ld, 현재값: %ld)\n", expectedValue, originalValue);
    }
}

// ... (생략) ...
```

  * **해설**:
      * `InterlockedCompareExchange(&g_value, newValue, expectedValue)`는 내부적으로 다음과 같이 동작합니다.
        1.  `g_value`의 현재 값을 읽는다.
        2.  이 값이 `expectedValue`(세 번째 인자)와 같은지 비교한다.
        3.  같으면 `g_value`를 `newValue`(두 번째 인자)로 업데이트한다.
        4.  **비교 결과와 상관없이 연산 전의 `g_value` 값**을 반환한다.
      * 따라서 반환된 `originalValue`와 내가 예상했던 `expectedValue`를 비교하면 CAS 연산의 성공 여부를 정확히 알 수 있습니다.

-----
  

## 문제 4: 스레드별 데이터 합산하기

**요구사항:**
여러 스레드가 각자 계산한 값(`localValue`)을 전역 합계 변수 `g_totalSum`에 누적한다. `InterlockedAdd` 또는 `InterlockedExchangeAdd`를 사용하여 이 과정을 스레드 세이프하게 만든다.

**실습 코드:**

```cpp
#include <windows.h>
#include <iostream>
#include <vector>

#define NUM_THREADS 10

LONGLONG g_totalSum = 0;

DWORD WINAPI ThreadProc(LPVOID lpParam) {
    LONGLONG localValue = 0;
    for (int i = 0; i < 10000; ++i) {
        localValue += (i + 1);
    }

    // TODO: 이 스레드에서 계산한 localValue를 전역 변수 g_totalSum에 원자적으로 더하세요.
    // 64비트 버전을 사용해야 합니다.

    printf("[Thread %lu] 로컬 합계 %lld를 더했습니다.\n", GetCurrentThreadId(), localValue);
    return 0;
}

int main() {
    std::vector<HANDLE> hThreads;
    for (int i = 0; i < NUM_THREADS; ++i) {
        HANDLE hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);
        if (hThread) {
            hThreads.push_back(hThread);
        }
    }

    WaitForMultipleObjects(hThreads.size(), hThreads.data(), TRUE, INFINITE);

    for (HANDLE hThread : hThreads) {
        CloseHandle(hThread);
    }

    // 1부터 10000까지의 합 = 50005000
    // 스레드 10개이므로 예상 결과 = 50005000 * 10 = 500050000
    printf("\n최종 합계: %lld (예상: 500050000)\n", g_totalSum);
    return 0;
}
```

**정답 및 해설:**

```cpp
// ... (생략) ...

DWORD WINAPI ThreadProc(LPVOID lpParam) {
    LONGLONG localValue = 0;
    for (int i = 0; i < 10000; ++i) {
        localValue += (i + 1);
    }

    // TODO: 이 스레드에서 계산한 localValue를 전역 변수 g_totalSum에 원자적으로 더하세요.
    // 64비트 버전을 사용해야 합니다.
    InterlockedAdd64(&g_totalSum, localValue);
    // 또는 InterlockedExchangeAdd64(&g_totalSum, localValue); 도 가능합니다.
    // 이 문제에서는 반환값이 필요 없으므로 둘 다 정답입니다.

    printf("[Thread %lu] 로컬 합계 %lld를 더했습니다.\n", GetCurrentThreadId(), localValue);
    return 0;
}

// ... (생략) ...
```

  * **해설**:
      * `g_totalSum`은 여러 스레드가 동시에 접근하여 수정하는 공유 자원입니다. `g_totalSum += localValue;` 와 같은 일반 연산은 원자적이지 않아 데이터 경쟁(Race Condition)을 일으키고 최종 합계가 틀리게 됩니다.
      * `InterlockedAdd64(&g_totalSum, localValue)`는 `g_totalSum`에 `localValue`를 더하는 과정을 원자적으로 처리하여 데이터 손실 없이 정확한 합계를 보장합니다. `LONGLONG` 타입이므로 64비트 버전인 `InterlockedAdd64`를 사용해야 합니다.

-----
  

## 문제 5: 비트 플래그를 이용한 스레드 상태 관리

**요구사항:**
하나의 정수 변수 `g_flags`를 사용하여 여러 상태를 비트마스크로 관리한다. `FLAG_A` (0x01), `FLAG_B` (0x02), `FLAG_C` (0x04) 세 가지 플래그가 있다. `Interlocked` 비트 연산 함수를 사용하여 스레드에 안전하게 플래그를 추가하고 제거하는 코드를 작성한다.

**실습 코드:**

```cpp
#include <windows.h>
#include <iostream>

LONG g_flags = 0; // 초기 상태는 0

#define FLAG_A 0x01 // 0001
#define FLAG_B 0x02 // 0010
#define FLAG_C 0x04 // 0100

// 플래그를 원자적으로 추가하는 함수
void AddFlag(LONG flag) {
    // TODO 1: g_flags에 flag를 원자적으로 추가(OR 연산)하세요.
}

// 플래그를 원자적으로 제거하는 함수
void RemoveFlag(LONG flag) {
    // TODO 2: g_flags에서 flag를 원자적으로 제거(AND 연산)하세요.
    // 힌트: 제거하려는 비트만 0으로 만들고 나머지는 1로 유지하는 마스크(~flag)를 사용해야 합니다.
}

void PrintFlags() {
    printf("현재 Flags: 0x%02lX\n", g_flags);
}

int main() {
    PrintFlags(); // 초기 상태: 0x00

    // 스레드 1이 FLAG_A와 FLAG_C를 추가한다고 가정
    AddFlag(FLAG_A | FLAG_C);
    PrintFlags(); // 예상: 0x05

    // 스레드 2가 FLAG_B를 추가한다고 가정
    AddFlag(FLAG_B);
    PrintFlags(); // 예상: 0x07

    // 스레드 3이 FLAG_A를 제거한다고 가정
    RemoveFlag(FLAG_A);
    PrintFlags(); // 예상: 0x06

    return 0;
}
```

**정답 및 해설:**

```cpp
// ... (생략) ...

// 플래그를 원자적으로 추가하는 함수
void AddFlag(LONG flag) {
    // TODO 1: g_flags에 flag를 원자적으로 추가(OR 연산)하세요.
    InterlockedOr(&g_flags, flag);
}

// 플래그를 원자적으로 제거하는 함수
void RemoveFlag(LONG flag) {
    // TODO 2: g_flags에서 flag를 원자적으로 제거(AND 연산)하세요.
    // 힌트: 제거하려는 비트만 0으로 만들고 나머지는 1로 유지하는 마스크(~flag)를 사용해야 합니다.
    InterlockedAnd(&g_flags, ~flag);
}

// ... (생략) ...
```

  * **해설**:
      * **플래그 추가**: `InterlockedOr(&g_flags, flag)`는 `g_flags |= flag` 연산을 원자적으로 수행합니다. 특정 비트를 `1`로 설정(추가)하는 데 사용됩니다.
      * **플래그 제거**: `InterlockedAnd(&g_flags, ~flag)`는 `g_flags &= ~flag` 연산을 원자적으로 수행합니다. `~flag`는 제거하려는 비트만 `0`이고 나머지는 `1`인 비트마스크를 만듭니다. 이 마스크와 `AND` 연산을 하면 원하는 비트만 `0`으로 설정(제거)할 수 있습니다.