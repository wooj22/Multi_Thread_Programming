# 8주차: C++ STL 스레드 프로그래밍 2

## 조건 변수와 스레드 통신

### std::condition_variable 기본 개념과 사용법
조건 변수(Condition Variable)는 특정 조건이 만족될 때까지 하나 이상의 스레드를 대기시키는 동기화 메커니즘이다. 뮤텍스와 함께 사용되어 스레드 간 효율적인 통신을 가능하게 한다.

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  Thread 1   │     │  Thread 2   │     │  Thread 3   │
└──────┬──────┘     └──────┬──────┘     └──────┬──────┘
       │                   │                   │
       │                   ▼                   ▼
       │            ┌─────────────┐     ┌─────────────┐
       │            │   wait()    │     │   wait()    │
       │            └──────┬──────┘     └──────┬──────┘
       │                   │                   │
       ▼                   ▼                   ▼
┌─────────────────────────────────────────────────────┐
│              Condition Variable                     │
│                                                     │
│  대기 중인 스레드들이 조건을 기다리는 곳                  │
└─────────────────────────────────────────────────────┘
       ▲
       │
┌──────┴──────┐
│notify_one() │
│notify_all() │
└─────────────┘
```
  

### std::condition_variable 클래스 멤버

**주요 멤버 함수:**
- `wait(unique_lock<mutex>& lock)`: 조건 변수에서 대기
- `wait(unique_lock<mutex>& lock, Predicate pred)`: 조건을 만족할 때까지 대기. 대기 후 깨어났을 때도 조건을 확인한다.
- `notify_one()`: 대기 중인 스레드 하나를 깨움
- `notify_all()`: 대기 중인 모든 스레드를 깨움
- `wait_for()`: 지정된 시간 동안 대기
- `wait_until()`: 특정 시점까지 대기
  
**기본 사용 예제:**

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <vector>

class SimpleSignal {
private:
    std::mutex mtx;
    std::condition_variable cv;
    bool ready = false;
    
public:
    void wait_for_signal() {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [this] { return ready; });
        std::cout << "Signal received! Thread ID: " 
                  << std::this_thread::get_id() << std::endl;
    }
    
    void send_signal() {
        {
            std::lock_guard<std::mutex> lock(mtx);
            ready = true;
        }
        cv.notify_all();
    }
};

int main() {
    SimpleSignal signal;
    std::vector<std::thread> threads;
    
    // 3개의 대기 스레드 생성
    for (int i = 0; i < 3; ++i) {
        threads.emplace_back(&SimpleSignal::wait_for_signal, &signal);
    }
    
    // 잠시 대기 후 신호 전송
    std::this_thread::sleep_for(std::chrono::seconds(1));
    std::cout << "Sending signal..." << std::endl;
    signal.send_signal();
    
    // 모든 스레드 종료 대기
    for (auto& t : threads) {
        t.join();
    }
    
    return 0;
}
```

`notify~` 와 `Wake~` 의 호출 상황 차이  
| 특징 | C++ `std::condition_variable` (pthreads) | Win32 API `CONDITION_VARIABLE` |
| --- | --- | --- |
| **권장 순서** | 1. 락 해제 <br> 2. `notify_all()` | 1. `WakeAllConditionVariable()` <br> 2. 락 해제 |
| **최적화 목표** | **경합(Contention) 방지** <br> (깨어난 스레드가 락 때문에 다시 대기하는 것 방지) | **쇄도 현상(Thundering Herd) 방지** <br> (커널이 스케줄링을 최적화하여 락을 넘겨줌) |
| **이식성** | **높음 (표준)** | **낮음 (Windows 종속)** |


### wait(), notify_one(), notify_all() 활용
  
#### wait() 함수의 동작 원리
`wait()` 함수는 다음과 같은 원자적 작업을 수행합니다:
1. 현재 스레드를 조건 변수의 대기 큐에 추가
2. 뮤텍스를 해제
3. 스레드를 블록 상태로 전환
4. 깨어나면 뮤텍스를 다시 획득

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <chrono>

class TaskQueue {
private:
    std::queue<std::string> tasks;
    std::mutex mtx;
    std::condition_variable cv;
    bool stop_requested = false;
    
public:
    void add_task(const std::string& task) {
        {
            std::lock_guard<std::mutex> lock(mtx);
            tasks.push(task);
        }
        cv.notify_one(); // 하나의 대기 스레드만 깨움
    }
    
    void stop() {
        {
            std::lock_guard<std::mutex> lock(mtx);
            stop_requested = true;
        }
        cv.notify_all(); // 모든 대기 스레드를 깨움
    }
    
    bool process_task(int worker_id) {
        std::unique_lock<std::mutex> lock(mtx);
        
        // 작업이 있거나 종료 요청이 있을 때까지 대기
        cv.wait(lock, [this] { 
            return !tasks.empty() || stop_requested; 
        });
        
        if (stop_requested && tasks.empty()) {
            return false;
        }
        
        std::string task = tasks.front();
        tasks.pop();
        lock.unlock(); // 작업 처리 전에 락 해제
        
        // 작업 처리 시뮬레이션
        std::cout << "Worker " << worker_id << " processing: " 
                  << task << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        
        return true;
    }
};

int main() {
    TaskQueue queue;
    std::vector<std::thread> workers;
    
    // 3개의 작업자 스레드 생성
    for (int i = 1; i <= 3; ++i) {
        workers.emplace_back([&queue, i]() {
            while (queue.process_task(i)) {
                // 계속 작업 처리
            }
            std::cout << "Worker " << i << " stopped." << std::endl;
        });
    }
    
    // 작업 추가
    for (int i = 1; i <= 10; ++i) {
        queue.add_task("Task " + std::to_string(i));
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
    }
    
    // 잠시 대기 후 종료
    std::this_thread::sleep_for(std::chrono::seconds(2));
    queue.stop();
    
    // 모든 작업자 스레드 종료 대기
    for (auto& w : workers) {
        w.join();
    }
    
    return 0;
}
```

#### Spurious Wakeup 문제와 해결 방법
Spurious wakeup은 조건 변수가 notify 없이도 깨어날 수 있는 현상이다. 이는 시스템 최적화나 신호 처리 등으로 인해 발생할 수 있다.

```
┌────────────────────────────────────────────────┐
│              Spurious Wakeup 발생               │
├────────────────────────────────────────────────┤
│                                                │
│  cv.wait(lock);  ← 잘못된 사용                   │
│                                                │
│  깨어났지만 조건이 만족되지 않을 수 있음!            │
│                                                │
├────────────────────────────────────────────────┤
│              올바른 해결 방법                    │
├────────────────────────────────────────────────┤
│                                                │
│  cv.wait(lock, []{ return condition; });       │
│                                                │
│  또는:                                          │
│  while (!condition) {                          │
│      cv.wait(lock);                            │
│  }                                             │
│                                                │
└────────────────────────────────────────────────┘
```
  
**안전한 조건 변수 사용 예제:**

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <atomic>

class SafeCounter {
private:
    int count = 0;
    int target = 0;
    std::mutex mtx;
    std::condition_variable cv;
    
public:
    void increment(int times) {
        for (int i = 0; i < times; ++i) {
            {
                std::lock_guard<std::mutex> lock(mtx);
                ++count;
                std::cout << "Count: " << count << std::endl;
            }
            cv.notify_all();
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
    }
    
    void wait_for_target(int target_value) {
        std::unique_lock<std::mutex> lock(mtx);
        target = target_value;
        
        // Spurious wakeup을 방지하는 올바른 방법
        cv.wait(lock, [this, target_value] { 
            return count >= target_value; 
        });
        
        std::cout << "Target " << target_value 
                  << " reached! Current count: " << count << std::endl;
    }
};

int main() {
    SafeCounter counter;
    
    // 증가 스레드
    std::thread incrementer(&SafeCounter::increment, &counter, 10);
    
    // 대기 스레드들
    std::thread waiter1(&SafeCounter::wait_for_target, &counter, 3);
    std::thread waiter2(&SafeCounter::wait_for_target, &counter, 7);
    std::thread waiter3(&SafeCounter::wait_for_target, &counter, 10);
    
    incrementer.join();
    waiter1.join();
    waiter2.join();
    waiter3.join();
    
    return 0;
}
```

                          
### 타임아웃이 있는 대기 (wait_for(), wait_until())
타임아웃을 사용하면 무한 대기를 방지하고 더 유연한 동기화를 구현할 수 있다.

#### wait_for()와 wait_until() 멤버 함수

**wait_for()**: 상대적 시간 동안 대기
```cpp
template<class Rep, class Period>
cv_status wait_for(unique_lock<mutex>& lock, 
                   const chrono::duration<Rep, Period>& rel_time);

template<class Rep, class Period, class Predicate>
bool wait_for(unique_lock<mutex>& lock,
              const chrono::duration<Rep, Period>& rel_time,
              Predicate pred);
```

**wait_until()**: 절대 시간까지 대기
```cpp
template<class Clock, class Duration>
cv_status wait_until(unique_lock<mutex>& lock,
                     const chrono::time_point<Clock, Duration>& abs_time);
```

**타임아웃 활용 예제:**
이 코드는 C++의 std::condition_variable (조건 변수)와 std::mutex를 사용하여 **"시간 제한이 있는 이벤트 대기"**를 구현한 예제이다.  
- wait_until: 지정된 **'절대 시간(deadline)'**까지 이벤트를 기다린다. (예: 5초 뒤인 10:00:05까지)
- wait_for: 지정된 '상대 시간(duration)' 동안 이벤트를 기다린다. (예: 지금부터 1초 동안)  
  
```cpp
// 필요한 C++ 표준 라이브러리 헤더들을 포함합니다.
#include <iostream> // 콘솔 입출력 (std::cout)
#include <thread>   // 스레드 (std::thread)
#include <mutex>    // 뮤텍스 (std::mutex, std::lock_guard, std::unique_lock)
#include <condition_variable> // 조건 변수 (std::condition_variable)
#include <chrono>   // 시간 관련 (std::chrono::*, steady_clock, system_clock)
#include <iomanip>  // 입출력 포맷팅 (여기서는 사용되지 않았지만 포함됨)

/**
 * @brief 타임아웃 기능이 있는 이벤트 핸들러 클래스
 * 한 스레드가 이벤트를 기다리고(wait), 다른 스레드가 이벤트를 발생(trigger)시킬 수 있습니다.
 */
class TimedEventHandler {
private:
    // 공유 데이터(event_occurred, event_data)를 보호하기 위한 뮤텍스
    std::mutex mtx;
    
    // 이벤트를 기다리거나(wait), 이벤트 발생을 알릴(notify) 때 사용하는 조건 변수
    std::condition_variable cv;
    
    // *** 대기 조건(Predicate) ***
    // 스레드가 기다리는 실제 조건. 이 값이 true가 되기를 기다립니다.
    bool event_occurred = false;
    
    // 이벤트와 함께 전달될 데이터
    std::string event_data;
    
public:
    /**
     * @brief [wait_until 사용 예]
     * 지정된 시간(timeout_ms) 동안 이벤트가 발생하기를 기다립니다.
     * @param timeout_ms 최대 대기 시간 (밀리초)
     * @param data [out] 이벤트 발생 시 데이터를 받아올 출력 파라미터
     * @return 이벤트가 발생하면 true, 타임아웃되면 false
     */
    bool wait_for_event(int timeout_ms, std::string& data) {
        // 조건 변수와 함께 사용하려면 반드시 std::unique_lock이 필요합니다.
        // wait 함수는 대기하는 동안 이 락을 자동으로 풀고(unlock),
        // 깨어날 때 다시 락을 잡습니다(lock).
        std::unique_lock<std::mutex> lock(mtx);
        
        // --- wait_until: '절대 시간' 기준 ---
        // 1. 현재 시간을 측정합니다.
        //    (steady_clock: 시스템 시간 변경에 영향을 받지 않는, 꾸준히 증가하는 시계)
        auto now = std::chrono::steady_clock::now();
        
        // 2. 타임아웃이 발생할 '절대 시간' (마감 시간)을 계산합니다.
        auto timeout_time = now + std::chrono::milliseconds(timeout_ms);
        
        // 3. cv.wait_until: 'timeout_time'이 될 때까지 대기합니다.
        //    람다 함수 [this] { return event_occurred; } 는 대기 조건입니다.
        //
        //    이 함수는 다음 3가지 경우에 깨어납니다:
        //    1) notify를 받고, 람다식이 'true'를 반환할 때 -> 'true'를 즉시 반환
        //    2) 'timeout_time'이 지났을 때 -> 'false'를 즉시 반환
        //    3) (드물게) Spurious Wakeup(가짜 깨어남) -> 람다식을 실행
        //       - 람다식이 true면: 1)과 동일하게 'true' 반환
        //       - 람다식이 false면: 다시 잠들어서 1) 또는 2)를 기다림
        bool result = cv.wait_until(lock, timeout_time, 
                                   [this] { return event_occurred; });
        
        // 'result'가 true라는 것은 notify를 받고 람다식도 true였다는 의미
        if (result) {
            data = event_data;        // 이벤트 데이터 복사
            event_occurred = false;   // 이벤트가 처리되었으므로 플래그 리셋
            return true;
        }
        
        // 'result'가 false라는 것은 타임아웃이 발생했다는 의미
        return false; // 타임아웃
    }
    
    /**
     * @brief 이벤트를 발생시키고, 대기 중인 스레드 하나를 깨웁니다.
     * @param data 이벤트와 함께 전달할 데이터
     */
    void trigger_event(const std::string& data) {
        {
            // 짧은 스코프 내에서 락을 잡고 공유 데이터를 수정합니다.
            std::lock_guard<std::mutex> lock(mtx);
            event_data = data;
            event_occurred = true; // *** 대기 조건을 true로 변경 ***
        } // <- 여기서 lock_guard가 소멸되며 락이 자동으로 해제됨
        
        // 락을 해제한 상태에서 notify를 호출하는 것이 좋습니다.
        // (깨어난 스레드가 락을 즉시 획득할 수 있어 성능에 유리)
        cv.notify_one(); // 대기 중인 스레드 중 '하나'를 깨움
    }
    
    /**
     * @brief [wait_for 사용 예]
     * 주기적으로(예: 1초마다) 작업을 확인하고,
     * 중간에 이벤트가 발생하면 즉시 반응하는 스레드 함수 예시
     */
    void periodic_check() {
        std::unique_lock<std::mutex> lock(mtx);
        
        while (true) {
            // --- wait_for: '상대 시간' 기준 ---
            // '1초' 동안 대기합니다.
            //
            // 이 함수는 다음 2가지 경우에 깨어납니다:
            // 1) 1초 이내에 notify를 받고 람다식이 'true'가 됨 -> 'true' 반환
            // 2) 1초가 지남 (타임아웃) -> 'false' 반환
            if (cv.wait_for(lock, std::chrono::seconds(1), 
                            [this] { return event_occurred; })) {
                
                // 1) 'true' 반환: 1초가 지나기 전에 이벤트가 발생함
                std::cout << "Event processed: " << event_data << std::endl;
                event_occurred = false; // 이벤트 처리 완료
            
            } else {
                // 2) 'false' 반환: 이벤트 없이 1초가 지남 (타임아웃)
                //    (system_clock: 현재 달력 시간)
                std::cout << "Periodic check at " 
                          << std::chrono::system_clock::now().time_since_epoch().count() 
                          << std::endl;
            }
            
            // 이 예제를 위한 종료 조건
            if (event_data == "quit") break;
        }
    }
};

int main() {
    TimedEventHandler handler;
    
    // --- 예제 1: wait_until (절대 시간) 테스트 ---
    std::cout << "--- wait_until (Timeout) Example ---" << std::endl;
    
    // [대기자 스레드] 5초 타임아웃으로 이벤트를 기다림
    std::thread waiter([&handler]() {
        std::string data;
        std::cout << "Waiting for event (5 second timeout)..." << std::endl;
        
        // wait_for_event는 5초 뒤의 '절대 시간'까지 대기
        if (handler.wait_for_event(5000, data)) {
            // 5초 이내에 이벤트 수신 성공
            std::cout << "Event received: " << data << std::endl;
        } else {
            // 5초 동안 이벤트가 오지 않아 타임아웃
            std::cout << "Timeout occurred!" << std::endl;
        }
    });
    
    // [이벤트 발생 스레드]
    std::thread trigger([&handler]() {
        // 이 스레드는 3초간 대기 (대기자의 타임아웃 5초보다 짧음)
        std::this_thread::sleep_for(std::chrono::seconds(3));
        std::cout << "(Triggering event now...)" << std::endl;
        handler.trigger_event("Important Event!");
    });
    
    // 두 스레드가 종료될 때까지 대기
    waiter.join();
    trigger.join();
    
    
    // --- 예제 2: wait_for (상대 시간) 테스트 ---
    std::cout << "\n--- wait_for (Periodic Check) Example ---" << std::endl;
    
    // [주기적 작업 스레드] 1초마다 체크 또는 이벤트 발생 시 즉시 반응
    std::thread periodic([&handler]() {
        handler.periodic_check();
    });
    
    // 메인 스레드가 2.5초 대기
    // (periodic 스레드는 1초, 2초 시점에 "Periodic check"를 2번 출력할 것임)
    std::this_thread::sleep_for(std::chrono::milliseconds(2500));
    
    // 2.5초 시점에 이벤트 발생
    // (periodic 스레드가 즉시 깨어나 "Event processed"를 출력할 것임)
    handler.trigger_event("First Event");
    
    // 1.5초 추가 대기 (총 4초 경과)
    // (periodic 스레드는 3.5초 시점에 "Periodic check"를 1번 출력할 것임)
    std::this_thread::sleep_for(std::chrono::milliseconds(1500));
    
    // 4초 시점에 "quit" 이벤트 발생
    // (periodic 스레드가 즉시 깨어나 "Event processed: quit"을 출력하고 종료)
    handler.trigger_event("quit");
    
    // 주기적 스레드가 종료될 때까지 대기
    periodic.join();
    
    return 0;
}
```
  

### 실습: Producer-Consumer 패턴 구현
Producer-Consumer 패턴은 조건 변수의 가장 대표적인 활용 사례이다. 생산자는 데이터를 생성하고, 소비자는 데이터를 처리한다.

```
┌─────────────────────────────────────────────────┐
│            Producer-Consumer Pattern            │
├─────────────────────────────────────────────────┤
│                                                 │
│  ┌──────────┐    ┌─────────┐    ┌──────────┐    │
│  │Producer 1│───▶│         │───▶│Consumer 1│   │
│  └──────────┘    │  Queue  │    └──────────┘    │
│                  │         │                    │
│  ┌──────────┐    │ [][][]  │    ┌──────────┐    │
│  │Producer 2│───▶│ [][][]  │──▶│Consumer 2│    │
│  └──────────┘    │         │    └──────────┘    │
│                  └─────────┘                    │
│                                                 │
│  조건 변수:                                      │
│  - not_empty: 큐가 비어있지 않음을 알림            │
│  - not_full: 큐가 가득차지 않음을 알림             │
│                                                 │
└─────────────────────────────────────────────────┘
```

**완전한 Producer-Consumer 구현:**
이 코드는 '생산자-소비자(Producer-Consumer)' 문제를 해결하기 위한 **'스레드 안전한, 크기 제한이 있는 큐(Thread-Safe Bounded Queue)'**를 C++로 구현한 예제이다.
- 생산자 (Producer): 데이터를 큐에 넣는(push) 스레드
- 소비자 (Consumer): 데이터를 큐에서 빼는(pop) 스레드
- Bounded Queue: 큐의 크기가 정해져 있어, 큐가 가득 차면 생산자가 대기하고, 큐가 비어 있으면 소비자가 대기해야 한다.  
  
```cpp
// 필요한 C++ 표준 라이브러리 헤더들을 포함합니다.
#include <iostream> // 콘솔 입출력 (std::cout)
#include <thread>   // 스레드 (std::thread)
#include <mutex>    // 뮤텍스 (std::mutex, std::lock_guard, std::unique_lock)
#include <condition_variable> // 조건 변수 (std::condition_variable)
#include <queue>    // 큐 자료구조 (std::queue)
#include <vector>   // 스레드 객체들을 저장하기 위한 벡터 (std::vector)
#include <chrono>   // 시간 관련 (std::chrono, sleep_for)
#include <random>   // 생산/소비 딜레이를 위한 난수 생성
#include <atomic>   // 원자적 연산 (std::atomic) - 큐 종료 플래그용

/**
 * @brief 스레드 안전(Thread-safe)하며, 크기가 제한된 큐 (Bounded Queue)
 * '생산자-소비자' 패턴에 사용됩니다.
 * @tparam T 큐에 저장할 아이템의 타입
 */
template<typename T>
class BoundedQueue {
private:
    std::queue<T> queue;      // 1. 실제 아이템을 저장할 내부 큐
    const size_t max_size;    // 2. 큐의 최대 크기 (용량)
    mutable std::mutex mtx;   // 3. 큐 접근(push, pop)을 보호하기 위한 뮤텍스
    
    // 4. 큐가 '비어있을 때' 소비자가 대기하기 위한 조건 변수
    std::condition_variable not_empty; 
    
    // 5. 큐가 '가득 찼을 때' 생산자가 대기하기 위한 조건 변수
    std::condition_variable not_full; 
    
    // 6. 큐를 안전하게 종료시키기 위한 플래그 (atomic으로 스레드 간 안전하게 공유)
    std::atomic<bool> shutdown{false}; 
    
public:
    /**
     * @brief 생성자: 큐의 최대 크기를 받아서 초기화
     * @param size 큐의 최대 용량
     */
    explicit BoundedQueue(size_t size) : max_size(size) {}
    
    /**
     * @brief 큐에 아이템을 추가 (생산자용)
     * @param item 큐에 추가할 아이템
     * @return 큐가 종료(shutdown)되지 않았으면 true, 종료되었으면 false
     */
    bool push(T item) {
        // unique_lock: 조건 변수(wait)와 함께 사용하기 위해 필요
        std::unique_lock<std::mutex> lock(mtx);
        
        // 람다 함수(Predicate)를 사용한 대기 (Spurious Wakeup 방지)
        // [조건]: 큐가 가득 차 있으면(queue.size() >= max_size) 대기
        // 1. 큐 크기가 max_size보다 작거나 (자리가 있거나)
        // 2. 큐가 종료(shutdown)되면
        //    wait 상태에서 깨어남
        not_full.wait(lock, [this] { 
            return queue.size() < max_size || shutdown; 
        });
        
        // 큐가 종료되어 깨어났다면, push를 중단하고 false 반환
        if (shutdown) return false;
        
        // 큐에 아이템 추가 (std::move로 소유권 이전)
        queue.push(std::move(item));
        
        // (선택적) 락 조기 해제: 
        // notify_one()을 호출하기 전에 락을 풀어주면,
        // 깨어난 소비자 스레드가 락을 즉시 획득할 수 있어 성능에 유리할 수 있음.
        lock.unlock(); 
        
        // 큐가 더 이상 '비어있지 않음'을 대기 중인 소비자 스레드 '하나'에게 알림
        not_empty.notify_one(); 
        return true;
    }
    
    /**
     * @brief 큐에서 아이템을 꺼냄 (소비자용)
     * @param item 꺼낸 아이템을 저장할 참조 변수
     * @return 아이템을 성공적으로 꺼냈으면 true, 
     * 큐가 종료(shutdown)되고 큐가 비어있으면 false
     */
    bool pop(T& item) {
        std::unique_lock<std::mutex> lock(mtx);
        
        // [조건]: 큐가 비어있으면(queue.empty()) 대기
        // 1. 큐가 비어있지 않거나 (아이템이 있거나)
        // 2. 큐가 종료(shutdown)되면
        //    wait 상태에서 깨어남
        not_empty.wait(lock, [this] { 
            return !queue.empty() || shutdown; 
        });
        
        // *** 중요: 종료 처리 ***
        // 큐가 종료(shutdown)되었더라도, 큐에 '남아있는' 아이템은
        // 모두 처리해야 함.
        // 따라서 'shutdown'이 true이고 'queue.empty()'도 true일 때만
        // pop을 중단하고 false를 반환.
        if (shutdown && queue.empty()) return false;
        
        // 큐에서 아이템 꺼내기
        item = std::move(queue.front());
        queue.pop();
        
        // 락 조기 해제 (push와 동일한 이유)
        lock.unlock(); 
        
        // 큐가 더 이상 '가득 차 있지 않음'을 대기 중인 생산자 스레드 '하나'에게 알림
        not_full.notify_one(); 
        return true;
    }
    
    /**
     * @brief 큐를 종료시킴. 모든 대기 중인 스레드를 깨움.
     */
    void stop() {
        {
            // shutdown 플래그를 true로 설정 (락으로 보호)
            std::lock_guard<std::mutex> lock(mtx);
            shutdown = true;
        }
        // wait()에서 대기 중인 모든 소비자 스레드를 깨움
        not_empty.notify_all();
        // wait()에서 대기 중인 모든 생산자 스레드를 깨움
        not_full.notify_all();
    }
    
    /**
     * @brief 현재 큐의 크기를 반환 (스레드 안전)
     */
    size_t size() const {
        std::lock_guard<std::mutex> lock(mtx);
        return queue.size();
    }
};

// 큐를 통해 전달될 데이터 구조체
struct DataItem {
    int producer_id; // 어떤 생산자가 만들었는지
    int sequence_num; // 몇 번째 아이템인지
    std::chrono::time_point<std::chrono::steady_clock> timestamp; // 생성된 시간 (대기 시간 측정용)
    
    // 생성자
    DataItem(int pid, int seq) 
        : producer_id(pid), sequence_num(seq), 
          timestamp(std::chrono::steady_clock::now()) {} // 생성 시점의 시간 기록
};

// 생산자 스레드 함수
void producer(BoundedQueue<DataItem>& queue, int id, int count) {
    // 스레드별로 독립적인 난수 생성기 (딜레이 시뮬레이션용)
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> delay(10, 100); // 10~100ms 딜레이
    
    for (int i = 0; i < count; ++i) {
        DataItem item(id, i); // 새 아이템 생성
        
        // 큐에 아이템을 push 시도 (큐가 가득 찼으면 여기서 블로킹됨)
        if (!queue.push(item)) {
            // push가 false를 반환하면 (큐가 종료됨)
            std::cout << "Producer " << id << " stopped early" << std::endl;
            break; // 루프 탈출
        }
        
        // (queue.size() 호출도 스레드 안전함)
        std::cout << "Producer " << id << " produced item " << i 
                  << " (queue size: " << queue.size() << ")" << std::endl;
        
        // 다음 아이템을 생산하기 전 랜덤 딜레이
        std::this_thread::sleep_for(std::chrono::milliseconds(delay(gen)));
    }
    
    std::cout << "Producer " << id << " finished" << std::endl;
}

// 소비자 스레드 함수
void consumer(BoundedQueue<DataItem>& queue, int id) {
    // 스레드별 난수 생성기 (소비 딜레이용)
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> delay(50, 150); // 50~150ms 딜레이
    
    int items_consumed = 0;
    
    // 큐가 종료되고 비어있을 때까지 무한 루프
    while (true) {
        DataItem item(0, 0); // 아이템을 받아올 빈 객체
        
        // 큐에서 아이템을 pop 시도 (큐가 비어있으면 여기서 블로킹됨)
        if (!queue.pop(item)) {
            // pop이 false를 반환하면 (큐가 종료되었고 큐가 비어있음)
            break; // 루프 탈출
        }
        
        // 대기 시간(latency) 계산: (현재 시간 - 아이템 생성 시간)
        auto now = std::chrono::steady_clock::now();
        auto latency = std::chrono::duration_cast<std::chrono::microseconds>
                       (now - item.timestamp).count();
        
        std::cout << "Consumer " << id << " consumed item " 
                  << item.sequence_num << " from Producer " 
                  << item.producer_id << " (latency: " 
                  << latency << "µs)" << std::endl;
        
        items_consumed++;
        // 아이템 소비(처리) 시간 시뮬레이션
        std::this_thread::sleep_for(std::chrono::milliseconds(delay(gen)));
    }
    
    std::cout << "Consumer " << id << " finished. Total consumed: " 
              << items_consumed << std::endl;
}

int main() {
    // 시뮬레이션 설정값
    const size_t queue_size = 5;         // 큐의 최대 크기
    const int num_producers = 3;       // 생산자 스레드 수
    const int num_consumers = 2;       // 소비자 스레드 수
    const int items_per_producer = 10; // 생산자당 만들 아이템 수
    
    // 크기가 5인 BoundedQueue 생성
    BoundedQueue<DataItem> queue(queue_size);
    // 모든 스레드를 관리하기 위한 벡터
    std::vector<std::thread> threads;
    
    // === 생산자 스레드 생성 및 시작 ===
    for (int i = 0; i < num_producers; ++i) {
        // emplace_back: 벡터에 스레드를 직접 생성하여 추가 (즉시 실행 시작)
        // std::ref(queue): 스레드에 큐의 '참조'를 전달 (복사 방지)
        threads.emplace_back(producer, std::ref(queue), i, items_per_producer);
    }
    
    // === 소비자 스레드 생성 및 시작 ===
    for (int i = 0; i < num_consumers; ++i) {
        threads.emplace_back(consumer, std::ref(queue), i);
    }
    
    // === 생산자 스레드 종료 대기 ===
    // 0번부터 (num_producers - 1)번까지의 스레드(생산자)가
    // 모두 작업을 마칠 때까지(join) 메인 스레드가 대기합니다.
    for (int i = 0; i < num_producers; ++i) {
        threads[i].join();
    }
    
    // 모든 생산자가 종료된 후, 소비자들이 큐에 남은 아이템을
    // 마저 처리할 수 있도록 잠시 시간을 줍니다.
    // (이것이 없으면 큐가 즉시 stop되어 남은 아이템이 처리되지 않을 수 있음)
    std::cout << "All producers finished. Waiting for consumers to clear queue..." << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(2));
    
    // === 큐 종료 신호 전송 ===
    // 모든 생산자가 작업을 마쳤으므로 큐를 종료합니다.
    // stop()은 대기 중인 모든 소비자(consumer)를 깨웁니다.
    std::cout << "Stopping queue..." << std::endl;
    queue.stop();
    
    // === 소비자 스레드 종료 대기 ===
    // (num_producers)번부터 끝까지의 스레드(소비자)가
    // 모두 종료될 때까지(join) 메인 스레드가 대기합니다.
    // 소비자들은 큐가 비고 stop()이 호출되었음을 확인하면 스스로 루프를 종료합니다.
    for (int i = num_producers; i < num_producers + num_consumers; ++i) {
        threads[i].join();
    }
    
    std::cout << "All threads finished. Remaining items in queue: " 
              << queue.size() << std::endl;
    
    return 0;
}
```
  
</br>    
    

## std::jthread와 협력적 취소

### C++20 std::jthread의 등장 배경과 std::thread와의 차이점
C++20에서 도입된 `std::jthread`는 "joinable thread"의 약자로, 기존 `std::thread`의 여러 문제점을 해결한다.

```
┌─────────────────────────────────────────────────┐
│         std::thread vs std::jthread             │
├─────────────────────────────────────────────────┤
│                                                 │
│  std::thread:                                   │
│  ✗ 소멸자에서 join() 호출 안함                    │
│  ✗ 중단 메커니즘 없음                             │
│  ✗ 수동으로 join/detach 필요                     │
│                                                 │
│  std::jthread:                                  │
│  ✓ 소멸자에서 자동 join()                         │
│  ✓ 협력적 중단 지원                               │
│  ✓ RAII 원칙 준수                                │
│  ✓ stop_token 자동 전달                          │
│                                                 │
└─────────────────────────────────────────────────┘
```

#### std::jthread 클래스 주요 멤버

**생성자:**
```cpp
jthread() noexcept;
template<class F, class... Args>
explicit jthread(F&& f, Args&&... args);
```

**멤버 함수:**
- `get_id()`: 스레드 ID 반환
- `joinable()`: join 가능 여부 확인
- `join()`: 스레드 종료 대기
- `detach()`: 스레드 분리
- `get_stop_source()`: stop_source 객체 반환
- `get_stop_token()`: stop_token 객체 반환
- `request_stop()`: 중단 요청

**기본 사용 예제:**

```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <vector>

// std::thread의 문제점 시연
void thread_problems() {
    std::cout << "=== std::thread Problems ===" << std::endl;
    
    // 문제 1: join을 잊으면 프로그램 종료
    {
        std::thread t([]() {
            std::this_thread::sleep_for(std::chrono::seconds(1));
            std::cout << "Thread finished" << std::endl;
        });
        // t.join(); // 이것을 잊으면 std::terminate() 호출!
        t.detach(); // 또는 detach 필요
    }
    
    // 문제 2: 예외 안전성 부족
    try {
        std::thread t([]() {
            std::this_thread::sleep_for(std::chrono::seconds(1));
        });
        
        // 예외 발생 시 join이 호출되지 않음
        throw std::runtime_error("Error!");
        
        t.join(); // 이 코드는 실행되지 않음
    } catch (...) {
        // 스레드가 join되지 않아 문제 발생
    }
}

// std::jthread의 해결책
void jthread_solutions() {
    std::cout << "\n=== std::jthread Solutions ===" << std::endl;
    
    // 해결책 1: 자동 join
    {
        std::jthread t([]() {
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            std::cout << "jthread automatically joined!" << std::endl;
        });
        // 소멸자에서 자동으로 join() 호출
    }
    
    // 해결책 2: 예외 안전성
    try {
        std::jthread t([]() {
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            std::cout << "jthread with exception safety" << std::endl;
        });
        
        throw std::runtime_error("Error!");
        
    } catch (...) {
        std::cout << "Exception caught, but jthread is safe!" << std::endl;
    }
    
    // 해결책 3: 협력적 중단
    {
        std::jthread t([](std::stop_token token) {
            while (!token.stop_requested()) {
                std::cout << "Working..." << std::endl;
                std::this_thread::sleep_for(std::chrono::milliseconds(200));
            }
            std::cout << "Stop requested, shutting down gracefully" << std::endl;
        });
        
        std::this_thread::sleep_for(std::chrono::milliseconds(600));
        t.request_stop(); // 중단 요청
    }
}

int main() {
    // thread_problems(); // 주의: 실제로 실행하면 문제 발생할 수 있음
    jthread_solutions();
    
    return 0;
}
```

### 자동 조인 기능과 중단 토큰 (std::stop_token)
`std::stop_token`은 스레드에 중단을 요청하는 협력적 취소 메커니즘을 제공한다.  
  
```
┌─────────────────────────────────────────────────┐
│           Stop Token Architecture               │
├─────────────────────────────────────────────────┤
│                                                 │
│  ┌──────────────┐                               │
│  │ stop_source  │◄─────┐                        │
│  └──────┬───────┘      │                        │
│         │              │                        │
│         ▼              │ get_stop_source()      │
│  ┌──────────────┐      │                        │
│  │ shared state │      │                        │
│  └──────┬───────┘      │                        │
│         │              │                        │
│         ▼              │                        │
│  ┌──────────────┐  ┌───┴────────┐               │
│  │ stop_token 1 │  │  jthread   │               │
│  └──────────────┘  └────────────┘               │
│  ┌──────────────┐                               │
│  │ stop_token 2 │                               │
│  └──────────────┘                               │
│                                                 │
└─────────────────────────────────────────────────┘
```

#### std::stop_token 클래스 멤버

**멤버 함수:**
- `stop_requested()`: 중단이 요청되었는지 확인
- `stop_possible()`: 중단이 가능한지 확인
- `swap()`: 다른 stop_token과 교환

**중단 토큰 활용 예제:**

```cpp
// C++ 표준 라이브러리 헤더 포함
#include <iostream> // 콘솔 입출력 (std::cout)
#include <thread>   // 스레드 관련 기능 (std::jthread, std::this_thread)
#include <chrono>   // 시간 관련 (std::chrono, sleep_for)
#include <atomic>   // 원자적 연산 (std::atomic) - 여러 스레드에서 안전하게 값을 읽고 쓰기 위함
#include <functional> // std::function (함수 객체 래퍼)

/**
 * @brief 중단 가능한 단일 작업을 캡슐화하는 클래스
 */
class InterruptibleTask {
private:
    // std::jthread: C++20에 도입된 스레드 래퍼.
    // 1. 소멸자에서 자동으로 join()을 호출 (스레드가 끝날 때까지 대기).
    // 2. 중단(stop_token) 기능을 내장하고 있음.
    std::jthread worker;
    
    // std::atomic<int>: 스레드 안전(thread-safe)한 정수.
    // 워커 스레드가 이 값을 '쓰고(write)', 메인 스레드가 '읽기(read)' 때문에
    // 데이터 경쟁(data race)을 피하기 위해 atomic을 사용해야 합니다.
    std::atomic<int> progress{0};
    
public:
    /**
     * @brief 워커 스레드를 시작시키는 함수
     */
    void start() {
        // jthread에 람다 함수를 전달하여 스레드를 생성하고 즉시 시작합니다.
        // [this]: 람다 함수 내에서 클래스 멤버(progress)에 접근하기 위해 캡처.
        // (std::stop_token token): jthread가 람다 함수에 자동으로 전달해주는 '중단 토큰'.
        worker = std::jthread([this](std::stop_token token) {
            std::cout << "Task started" << std::endl;
            
            // 100단계로 이루어진 긴 작업을 시뮬레이션
            for (int i = 0; i < 100; ++i) {
                
                // *** 핵심: 협력적 중단 ***
                // 스레드는 루프를 돌 때마다 'token'을 확인하여
                // 외부(메인 스레드)에서 중단 요청이 왔는지 스스로 검사합니다.
                if (token.stop_requested()) {
                    std::cout << "Task interrupted at " << i << "%" << std::endl;
                    // 중단 요청이 왔으면, 작업을 중단하고 스레드 함수를 종료합니다.
                    return;
                }
                
                // 실제 작업을 시뮬레이션 (예: 파일 다운로드, 복잡한 계산 등)
                std::this_thread::sleep_for(std::chrono::milliseconds(50));
                
                // 진행률 업데이트 (atomic 연산)
                progress = i + 1;
                
                // 10% 마다 진행 상황 출력
                if (progress % 10 == 0) {
                    std::cout << "Progress: " << progress << "%" << std::endl;
                }
            }
            
            // 루프가 중단 없이 완료된 경우
            std::cout << "Task completed!" << std::endl;
        });
    }
    
    /**
     * @brief 실행 중인 워커 스레드에 '중단'을 요청하는 함수
     */
    void stop() {
        // joinable(): 스레드가 현재 실행 중(결합 가능)인지 확인
        if (worker.joinable()) {
            // jthread에 중단을 요청합니다.
            // 이 호출로 인해 'worker' 스레드 내부의 'token'이
            // 'stop_requested()' 상태(true)가 됩니다.
            worker.request_stop();
        }
    }
    
    /**
     * @brief 현재 진행률을 (스레드 안전하게) 반환
     */
    int get_progress() const {
        // atomic 변수는 그냥 읽기만 해도 스레드 안전합니다.
        return progress;
    }
    
    /**
     * @brief 소멸자 (클래스 객체가 사라질 때 호출됨)
     */
    ~InterruptibleTask() {
        // 객체가 소멸될 때, 만약 스레드가 아직 실행 중이라면
        // 중단을 요청하여 안전하게 종료하도록 보장합니다.
        stop(); 
        
        // 이 함수가 끝난 후, 멤버 변수인 'worker'(jthread)의 소멸자가 호출됩니다.
        // jthread의 소멸자는 'request_stop()'을 다시 호출하고(무해함)
        // 스레드가 'join()' (완전히 종료)될 때까지 자동으로 대기합니다.
    }
};

/**
 * @brief 여러 개의 중단 가능한 작업을 관리하는 클래스
 */
class TaskManager {
private:
    // 실행 중인 jthread들을 저장하는 벡터
    std::vector<std::jthread> tasks;
    
public:
    /**
     * @brief stop_token을 인자로 받는 모든 종류의 작업을 추가합니다.
     * @param task_func (std::stop_token)을 인자로 받는 함수 객체(람다 등)
     */
    void add_task(std::function<void(std::stop_token)> task_func) {
        // emplace_back: 벡터 끝에 jthread 객체를 직접 생성하여 추가 (즉시 스레드 시작)
        tasks.emplace_back(task_func);
    }
    
    /**
     * @brief 지정된 주기(interval)마다 반복하는 작업을 추가하는 헬퍼 함수
     */
    void add_periodic_task(const std::string& name, int interval_ms) {
        // add_task를 사용하여 주기적 작업을 람다 함수로 정의
        add_task([name, interval_ms](std::stop_token token) {
            int count = 0;
            // 중단 요청이 오기 전까지 무한 반복
            while (!token.stop_requested()) {
                std::cout << name << " - Iteration " << ++count << std::endl;
                
                // *** 핵심: 중단 가능한 대기(sleep) ***
                // 단순히 sleep_for(interval_ms)를 호출하면
                // 그 시간 동안에는 'token.stop_requested()'를 확인할 수 없습니다. (블로킹)
                // 따라서 '작은 단위'로 'sleep'하며 'token'을 계속 확인해야 합니다.
                
                auto start = std::chrono::steady_clock::now();
                
                // 목표 시간(interval_ms)이 되거나, 중간에 중단 요청이 올 때까지
                // 10ms씩 짧게 자면서 계속 확인
                while (!token.stop_requested()) {
                    auto now = std::chrono::steady_clock::now();
                    auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>
                                (now - start).count();
                    
                    // 목표 대기 시간을 채웠으면 내부 루프 탈출
                    if (elapsed >= interval_ms) break;
                    
                    // 10ms 대기
                    std::this_thread::sleep_for(std::chrono::milliseconds(10));
                }
                // (외부 루프로 돌아가 다시 token.stop_requested() 확인)
            }
            // 외부 루프가 중단되면 (token.stop_requested() == true)
            std::cout << name << " stopped after " << count << " iterations" << std::endl;
        });
    }
    
    /**
     * @brief 관리 중인 모든 작업(스레드)에 중단을 요청
     */
    void stop_all() {
        std::cout << "Requesting stop for all tasks..." << std::endl;
        for (auto& task : tasks) {
            task.request_stop();
        }
    }
    
    /**
     * @brief TaskManager 소멸자
     */
    ~TaskManager() {
        // TaskManager 객체가 소멸될 때 모든 하위 작업을 중단시킵니다.
        stop_all();
        
        // 이 함수가 끝난 후 'tasks' 벡터가 소멸됩니다.
        // 벡터가 소멸되면 그 안의 모든 'jthread' 객체들이 소멸되고,
        // 각 'jthread'의 소멸자는 해당 스레드가 'join()'될 때까지 (완전히 끝날 때까지)
        // 자동으로 대기해줍니다.
    }
};

int main() {
    std::cout << "=== Interruptible Task Example ===" << std::endl;
    { // InterruptibleTask의 생명 주기를 제어하기 위한 스코프(Scope)
        InterruptibleTask task;
        task.start(); // 작업 시작
        
        // 메인 스레드는 3초간 대기
        std::this_thread::sleep_for(std::chrono::seconds(3));
        
        // 3초 후, 현재 진행 상황을 출력하고 중단 요청
        std::cout << "Requesting stop... (Progress: " 
                  << task.get_progress() << "%)" << std::endl;
        task.stop();
        
    } // <- 이 '}' 괄호를 만나면 'task' 객체가 소멸됩니다.
      // 'task'의 소멸자가 호출되고, 그 안의 jthread가 join()될 때까지
      // 메인 스레드는 여기서 대기합니다.
    
    std::cout << "\n=== Task Manager Example ===" << std::endl;
    { // TaskManager의 생명 주기를 위한 스코프
        TaskManager manager;
        
        // 서로 다른 주기를 가진 3개의 주기적 작업 추가
        manager.add_periodic_task("FastTask", 200);   // 0.2초마다
        manager.add_periodic_task("MediumTask", 500); // 0.5초마다
        manager.add_periodic_task("SlowTask", 1000);  // 1.0초마다
        
        // 3개의 스레드가 5초 동안 동시에 실행되도록 둠
        std::this_thread::sleep_for(std::chrono::seconds(5));
        
        // 5초 후, 모든 작업을 중단시킴
        manager.stop_all();
        
    } // <- 이 '}' 괄호를 만나면 'manager' 객체가 소멸됩니다.
      // 'manager'의 소멸자가 호출되고, 모든 jthread가 join()될 때까지
      // 메인 스레드는 여기서 대기합니다.
    
    return 0;
}
```
  

### std::stop_source
`std::stop_source`는 C++20 동시성 기능의 핵심 구성 요소로, **'중단 요청자'** 또는 **'신호 발신자'** 역할을 한다.  
    
간단히 말해, **"이제 그만 멈춰\!"**라는 신호를 보낼 수 있는 객체이다. 이 객체를 사용해 하나 이상의 스레드나 비동기 작업을 안전하고 깔끔하게 중단시킬 수 있다.  
  
작동 방식은 다음과 같다.    
1.  **`std::stop_source`**를 만든다. (신호를 보낼 '제어 장치')
2.  이 `source`로부터 **`std::stop_token`**을 얻는다. (`get_token()` 사용) (신호를 받을 '수신기')
3.  이 `token`을 중단시키고 싶은 스레드나 작업에 전달한다.
4.  작업을 중단시킬 때가 되면, `std::stop_source` 객체의 **`request_stop()`** 메서드를 호출한다.
5.  `token`을 가지고 있던 모든 스레드는 `token.stop_requested()`가 `true`가 된 것을 확인하고 스스로 작업을 정리하며 종료한다.  

#### 🧐 `std::stop_source`의 주요 기능

  * **`std::stop_source()` (생성자):** 새로운 '중단 상태'를 만든다.
  * **`get_token()`:** 이 `source`에 연결된 `std::stop_token`을 반환한다. 이 토큰을 여러 개 복사하여 여러 스레드에 전달할 수 있다.
  * **`request_stop()`:** **가장 중요한 메서드이다.** 이 `source`에 연결된 모든 `token`에게 중단 신호를 보낸다.
  * **`stop_requested()`:** `source` 자체가 중단 요청을 받았는지 확인한다. (여러 `source`를 연동할 때 사용)

#### 💻 간단한 사용 예제 코드
아래 예제는 메인 스레드가 `std::stop_source`를 사용해 워커 스레드(worker thread)를 3초 후에 중단시키는 과정을 보여준다.  

```cpp
#include <iostream>
#include <thread>         // std::jthread, std::this_thread
#include <stop_token>     // std::stop_source, std::stop_token
#include <chrono>         // std::chrono::*

/**
 * @brief 워커 스레드가 실행할 작업 함수
 * @param token 메인 스레드로부터 받은 중단 신호 수신기(token)
 */
void worker_task(std::stop_token token) {
    int counter = 0;
    
    // token.stop_requested()가 false인 동안 (즉, 중단 요청이 없는 동안)
    // 루프를 계속 실행합니다.
    while (!token.stop_requested()) {
        std::cout << "워커: 작업 중... (카운트: " << ++counter << ")\n";
        
        // 500ms 동안 대기하며 작업을 시뮬레이션
        // 이 시간 동안에도 중단 요청이 오면 루프 조건에서 감지됩니다.
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
    }
    
    // 루프를 빠져나왔다면, 중단 요청을 받은 것입니다.
    std::cout << "워커: 중단 요청을 감지! 정리 작업을 수행하고 종료합니다.\n";
}

int main() {
    std::cout << "메인: std::stop_source를 생성합니다.\n";
    // 1. 중단 신호를 보낼 '제어 장치'(source)를 생성
    std::stop_source source;

    // 2. source로부터 '신호 수신기'(token)를 얻음
    std::stop_token token = source.get_token();

    std::cout << "메인: 워커 스레드를 시작합니다. (토큰 전달)\n";
    // 3. 워커 스레드를 시작하며, 'token'을 전달
    //    (jthread는 예제를 간단히 하기 위해 사용, 소멸 시 자동 join)
    std::jthread worker(worker_task, token);

    std::cout << "메인: 3초간 대기합니다...\n";
    std::this_thread::sleep_for(std::chrono::seconds(3));

    std::cout << "\n메인: 3초 경과. source.request_stop()을 호출합니다!\n";
    
    // 4. "이제 그만 멈춰!"라고 신호를 보냄
    //    이 호출로 인해 'worker'가 가진 'token'의 stop_requested()가 true가 됨
    source.request_stop();

    // 5. jthread의 소멸자가 호출되면서,
    //    워커 스레드가 'worker_task' 함수를 완전히 종료할 때까지
    //    자동으로 기다려줍니다 (join).
    std::cout << "메인: 워커 스레드가 종료되기를 기다립니다...\n";
} // <- worker (jthread)가 여기서 소멸되며 join() 호출
```

#### 🖥️ 예상 실행 결과
(실행 환경에 따라 카운트 횟수는 약간 다를 수 있습니다.)
  
```
메인: std::stop_source를 생성합니다.
메인: 워커 스레드를 시작합니다. (토큰 전달)
워커: 작업 중... (카운트: 1)
메인: 3초간 대기합니다...
워커: 작업 중... (카운트: 2)
워커: 작업 중... (카운트: 3)
워커: 작업 중... (카운트: 4)
워커: 작업 중... (카운트: 5)
워커: 작업 중... (카운트: 6)

메인: 3초 경과. source.request_stop()을 호출합니다!
메인: 워커 스레드가 종료되기를 기다립니다...
워커: 중단 요청을 감지! 정리 작업을 수행하고 종료합니다.
```
  

### std::stop_callback 클래스
`std::stop_callback`은 C++20의 동시성 기능 중 하나로, `std::stop_token`과 함께 사용된다.  
  
이것의 핵심 기능은 **"std::stop_token에 중단 요청이 들어오면(또는 이미 들어와 있다면), 등록된 콜백(callback) 함수를 즉시 실행하라"** 는 일종의 '알림 구독' 장치이다.  
  
`while (!token.stop_requested()) { ... }`처럼 스레드가 루프를 돌며 중단 요청을 **주기적으로 확인(Polling)** 하는 방식과 달리, `std::stop_callback`은 중단 요청이라는 **이벤트가 발생했을 때 능동적으로(reactively) 특정 동작을 트리거** 할 수 있게 해준다.  

#### 🧐 `std::stop_callback` 이란?

  * `std::stop_token`과 **하나의 함수(콜백)**를 인자로 받아 생성된다.
  * **생성 시점**에 `stop_token`이 **이미 중단 요청을 받은 상태**라면, 콜백 함수는 `std::stop_callback` 생성자 내에서 **즉시 실행**된다.
  * `stop_token`이 아직 중단 요청을 받지 않았다면, 콜백 함수는 '등록' 상태가 된다.
  * 이후 해당 토큰에 연결된 `std::stop_source`에서 `request_stop()`이 호출되면, 등록되었던 콜백 함수가 **즉시 실행**된다. (보통 `request_stop()`을 호출한 스레드에서 실행된다.)

#### 💻 간략한 사용 예제 코드
아래 예제는 `std::stop_callback`이 어떻게 등록되고 언제 실행되는지 보여준다.

```cpp
#include <iostream>
#include <thread>         // std::jthread, std::this_thread, std::this_thread::get_id
#include <stop_token>     // std::stop_source, std::stop_token, std::stop_callback
#include <chrono>         // std::chrono::*
#include <functional>     // std::ref (참조를 전달하기 위해 필요)

// 콜백 함수: stopper_thread가 자신의 작업을 마치고
// source_for_callback.request_stop()을 호출할 때 실행됩니다.
void my_callback_function() {
    std::cout << "[콜백 함수 실행됨] : Stopper가 작업을 완료하고 중단 신호를 보냈습니다! (실행 스레드 ID: " 
              << std::this_thread::get_id() << ")\n";
}

/**
 * @brief 'while' 루프를 돌며 작업을 수행하는 스레드 함수
 * @param token_to_listen   (메인 스레드로부터 받음) 이 토큰이 활성화되면 'while' 루프를 중단합니다.
 * @param source_to_trigger (메인 스레드에 등록된 콜백) 루프가 중단된 후, 이 'source'를 트리거합니다.
 */
void stopper_thread_task(std::stop_token token_to_listen, std::stop_source& source_to_trigger) {
    std::cout << "[Stopper 스레드] 시작 (ID: " << std::this_thread::get_id() 
              << "). 메인의 중단 신호를 기다리며 루프 시작...\n";
    
    int counter = 0;

    // 1. 요청하신 'while' 루프입니다.
    //    메인 스레드가 'source_for_stopper'를 중단시킬 때까지 계속 돕니다.
    while (!token_to_listen.stop_requested()) {
        std::cout << "[Stopper 스레드] 작업 중... (" << ++counter << ")\n";
        
        // 500ms 마다 작업 수행
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
    }

    // 2. 루프가 중단됨 (메인 스레드가 'source_for_stopper.request_stop()' 호출)
    std::cout << "\n[Stopper 스레드] 'while' 루프 중단 감지!\n";
    std::cout << "[Stopper 스레드] 등록된 'my_callback_function'을 트리거합니다...\n";

    // 3. 자신의 작업(루프)이 끝났음을 알리기 위해, 'source_for_callback'을 트리거
    //    이 호출로 인해 메인 스레드(또는 콜백이 등록된 스레드)에서 'my_callback_function'이 실행됩니다.
    source_to_trigger.request_stop(); 

    std::cout << "[Stopper 스레드] 콜백 트리거 완료. 스레드 종료.\n";
}


int main() {
    std::cout << "메인 스레드 시작 (ID: " << std::this_thread::get_id() << ")\n";

    // === 2개의 '신호기' 세트 준비 ===

    // 세트 1: Stopper 스레드가 작업 완료 후 '콜백'을 트리거하기 위한 용도
    std::stop_source source_for_callback;
    std::stop_token token_for_callback = source_for_callback.get_token();

    // 세트 2: 메인 스레드가 Stopper 스레드의 'while 루프'를 중단시키기 위한 용도
    std::stop_source source_for_stopper;
    std::stop_token token_for_stopper = source_for_stopper.get_token();

    // ---------------------------------

    std::cout << "메인 스레드: 'token_for_callback'에 콜백을 등록합니다.\n";
    // '세트 1' 토큰에 콜백 함수를 등록
    std::stop_callback callback_handle(token_for_callback, my_callback_function);

    std::cout << "메인 스레드: Stopper 스레드를 시작시킵니다...\n";
    
    // 'jthread'를 시작
    // - token_for_stopper: 'while' 루프를 멈추기 위한 신호 수신기 (세트 2)
    // - source_for_callback: 'while' 루프가 멈춘 후 콜백을 부를 신호 발신기 (세트 1)
    std::jthread stopper(stopper_thread_task, 
                         token_for_stopper,               // (세트 2)
                         std::ref(source_for_callback)    // (세트 1)
                        );

    std::cout << "메인 스레드: 3초간 대기합니다...\n";
    std::this_thread::sleep_for(std::chrono::seconds(3));

    std::cout << "\n메인 스레드: 3초 경과. Stopper 스레드의 'while' 루프를 중단시킵니다!\n";
    
    // '세트 2'의 source를 사용해 Stopper 스레드의 'while' 루프를 중단시킴
    source_for_stopper.request_stop();

    std::cout << "메인 스레드: Stopper 스레드가 종료되기를 기다립니다 (jthread 자동 join)...\n";

    // 'stopper'(jthread)의 소멸자가 호출될 때 (main 함수 종료 시)
    // 'stopper_thread_task'가 완전히 종료될 때까지 자동으로 대기(join)합니다.

} // <- 'stopper' (jthread)가 여기서 소멸하며 join() 호출
  //    'stopper_thread_task'가 완전히 종료되고, 콜백도 모두 실행된 이후에
  //    프로그램이 실제로 종료됩니다.
```
  
🖥️ 예상 실행 결과  

(실행 환경에 따라 카운트 횟수는 약간 다를 수 있다.)

```
메인 스레드 시작 (ID: 0x1)
메인 스레드: 'token_for_callback'에 콜백을 등록합니다.
메인 스레드: Stopper 스레드를 시작시킵니다...
메인 스레드: 3초간 대기합니다...
[Stopper 스레드] 시작 (ID: 0x2). 메인의 중단 신호를 기다리며 루프 시작...
[Stopper 스레드] 작업 중... (1)
[Stopper 스레드] 작업 중... (2)
[Stopper 스레드] 작업 중... (3)
[Stopper 스레드] 작업 중... (4)
[Stopper 스레드] 작업 중... (5)
[Stopper 스레드] 작업 중... (6)

메인 스레드: 3초 경과. Stopper 스레드의 'while' 루프를 중단시킵니다!
메인 스레드: Stopper 스레드가 종료되기를 기다립니다 (jthread 자동 join)...

[Stopper 스레드] 'while' 루프 중단 감지!
[Stopper 스레드] 등록된 'my_callback_function'을 트리거합니다...
[콜백 함수 실행됨] : Stopper가 작업을 완료하고 중단 신호를 보냈습니다! (실행 스레드 ID: 0x2)
[Stopper 스레드] 콜백 트리거 완료. 스레드 종료.
```

**결과 분석:**
1.  메인 스레드(ID: 0x1)와 Stopper 스레드(ID: 0x2)가 동시에 실행된다.
2.  Stopper 스레드는 `!token_to_listen.stop_requested()` 조건으로 `while` 루프를 돈다.
3.  3초 후, 메인 스레드가 `source_for_stopper.request_stop()`을 호출한다.
4.  Stopper 스레드는 `token_to_listen.stop_requested()`가 `true`가 된 것을 감지하고 `while` 루프를 탈출한다.
5.  루프를 나온 Stopper 스레드는 `source_for_callback.request_stop()`을 호출한다.
6.  이 호출로 인해 등록되어 있던 `my_callback_function`이 **Stopper 스레드(ID: 0x2)**에서 실행된다.
7.  Stopper 스레드가 모든 작업을 마치고 종료되며, 메인 스레드도 종료된다.
  
  

### std::condition_variable과 std::stop_token 결합
조건 변수와 중단 토큰을 함께 사용하면 더욱 강력한 동기화 메커니즘을 구현할 수 있다.
  
소비자(consumer) 스레드가 큐에서 아이템을 기다리고 있을 때, 외부에서 이 스레드를 안전하게 중단시킬 수 있는 방법을 보여준다.  

```cpp
// 필요한 C++ 표준 라이브러리 헤더들을 포함합니다.
#include <iostream> // 콘솔 입출력 (std::cout)
#include <thread> // 스레드 지원 (std::jthread, std::this_thread)
#include <mutex> // 상호 배제 (std::mutex, std::lock_guard, std::unique_lock)
#include <condition_variable> // 조건 변수 (std::condition_variable)
#include <queue> // 큐 자료구조 (std::queue)
#include <optional> // 값이 있을 수도, 없을 수도 있음을 나타냄 (std::optional)
#include <chrono> // 시간 관련 (std::chrono)

/**
 * @brief 조건 변수(cv)를 기다리되, 중단 토큰(token)을 주기적으로 확인하는 함수
 *
 * @tparam Predicate 대기 조건을 확인하는 함수 객체 (e.g., 람다 함수)
 * @param cv 대기할 조건 변수
 * @param lock cv와 연결된 unique_lock (뮤텍스 소유권 필요)
 * @param token 중단 요청을 확인할 스탑 토큰
 * @param pred 대기 조건을 검사하는 함수. true를 반환하면 대기 종료.
 * @return pred()가 true를 반환하면 true, 중단되면(stop_requested) false
 */
template<typename Predicate>
bool interruptible_wait(std::condition_variable& cv,
                          std::unique_lock<std::mutex>& lock,
                          std::stop_token token,
                          Predicate pred) {
    // 중단 요청이 들어오지 않는 동안 계속 반복
    while (!token.stop_requested()) {
        // 1. 실제 조건(pred)을 먼저 확인합니다.
        //    (e.g., 큐가 비어있지 않은지 확인)
        if (pred()) return true; // 조건 만족 시 즉시 true 반환

        // 2. 조건이 만족되지 않으면, CV를 기다립니다.
        //    단, 영원히 기다리면(cv.wait) 중단 요청에 반응할 수 없습니다.
        //    따라서 'wait_for'를 사용해 최대 100ms만 대기합니다.
        //    100ms가 지나거나, (가짜) 알림이 오면 깨어납니다.
        cv.wait_for(lock, std::chrono::milliseconds(100));

        // 3. 루프의 처음으로 돌아가 'token.stop_requested()'를 다시 확인합니다.
        //    이것이 '중단 가능성'을 보장하는 핵심입니다.
    }
    // 루프를 빠져나왔다면 중단 요청이 들어온 것이므로 false 반환
    return false;
}

/**
 * @brief 중단 가능한(Interruptible) 스레드 안전 큐 템플릿 클래스
 * @tparam T 큐에 저장할 아이템의 타입
 */
template<typename T>
class InterruptibleQueue {
private:
    std::queue<T> queue; // 실제 데이터를 저장할 큐
    mutable std::mutex mtx; // 큐 접근을 보호할 뮤텍스
    std::condition_variable cv; // 큐가 비었을 때 대기하기 위한 조건 변수

public:
    /**
     * @brief 큐에 아이템을 추가 (Push)
     * @param value 큐에 추가할 아이템
     */
    void push(T value) {
        {
            // lock_guard를 사용해 뮤텍스를 잠급니다.
            // 이 블록을 벗어나면 자동으로 잠금 해제됩니다.
            std::lock_guard<std::mutex> lock(mtx);
            // std::move를 사용해 값의 소유권을 큐로 효율적으로 이전합니다.
            queue.push(std::move(value));
        } // <- 여기서 mtx 잠금 해제
        
        // 큐에 아이템이 추가되었으니,
        // 혹시 대기 중인 소비자(consumer)가 있다면 하나를 깨웁니다.
        cv.notify_one();
    }

    /**
     * @brief 큐에서 아이템을 꺼냄 (Pop) - 중단 가능
     * 아이템이 없으면 큐에 아이템이 들어오거나 중단될 때까지 대기합니다.
     * @param token 중단 요청을 감지할 스탑 토큰
     * @return 아이템을 성공적으로 꺼내면 std::optional<T>(value),
     * 중단되면 std::nullopt (비어있는 optional)
     */
    std::optional<T> pop(std::stop_token token) {
        // unique_lock을 사용합니다.
        // condition_variable::wait 계열 함수는 unique_lock을 요구합니다.
        // (대기 중에 락을 풀고, 깨어날 때 다시 락을 잡아야 하므로)
        std::unique_lock<std::mutex> lock(mtx);

        // interruptible_wait 헬퍼 함수를 호출합니다.
        // 대기 조건(Predicate)은 "[this] { return !queue.empty(); }" (큐가 비어있지 않음) 입니다.
        bool has_value = interruptible_wait(cv, lock, token,
                                          [this] { return !queue.empty(); });

        // interruptible_wait가 false를 반환했다면, 중단되었다는 의미입니다.
        if (!has_value) {
            return std::nullopt; // 비어있는 optional 반환
        }

        // has_value가 true라면, 큐에 아이템이 있고 우리는 락을 소유한 상태입니다.
        T value = std::move(queue.front()); // 아이템을 꺼냅니다.
        queue.pop();
        return value; // 아이템을 optional로 감싸서 반환
    }

    /**
     * @brief 큐에서 아이템을 꺼냄 (Pop) - 타임아웃 및 중단 지원
     * 지정된 timeout 시간 동안만 대기하며, 중간에 중단될 수도 있습니다.
     * @param token 중단 요청을 감지할 스탑 토큰
     * @param timeout 최대 대기 시간
     * @return 성공 시 std::optional<T>(value),
     * 중단 또는 타임아웃 시 std::nullopt
     */
    std::optional<T> pop_with_timeout(std::stop_token token,
                                          std::chrono::milliseconds timeout) {
        std::unique_lock<std::mutex> lock(mtx);

        // 타임아웃 기준이 될 '절대 시간' (마감 시간)을 계산합니다.
        auto deadline = std::chrono::steady_clock::now() + timeout;

        // 중단 요청이 없는 동안 반복
        while (!token.stop_requested()) {
            // 1. 큐에 데이터가 있는지 확인
            if (!queue.empty()) {
                T value = std::move(queue.front());
                queue.pop();
                return value; // 성공
            }

            // 2. 타임아웃 확인
            auto now = std::chrono::steady_clock::now();
            if (now >= deadline) {
                return std::nullopt; // 타임아웃
            }

            // 3. 대기
            // 남은 시간(remaining)과 주기적 중단 확인 시간(100ms) 중
            // 더 *짧은* 시간만큼만 대기합니다.
            auto remaining = deadline - now;
            cv.wait_for(lock, std::min(remaining,
                                      std::chrono::milliseconds(100)));
            // 깨어난 후 루프 처음으로 돌아가 중단/데이터/타임아웃을 다시 확인
        }

        return std::nullopt; // 중단됨
    }

    /**
     * @brief 현재 큐의 크기를 반환 (스레드 안전)
     */
    size_t size() const {
        std::lock_guard<std::mutex> lock(mtx);
        return queue.size();
    }
};

// 사용 예제 함수
void demonstration() {
    std::cout << "=== Interruptible Queue Example ===" << std::endl;
    {
        InterruptibleQueue<int> queue;

        // [생산자 스레드]
        // std::jthread는 C++20에 도입되었으며, 소멸자에서 자동으로 join()을 호출합니다.
        std::jthread producer([&queue]() {
            for (int i = 1; i <= 10; ++i) {
                queue.push(i);
                std::cout << "Produced: " << i << std::endl;
                // 300ms 마다 하나씩 생산
                std::this_thread::sleep_for(std::chrono::milliseconds(300));
            }
        });

        // [소비자 스레드]
        // jthread의 람다 인자로 std::stop_token을 받으면,
        // 이 스레드와 연결된 스탑 토큰이 자동으로 전달됩니다.
        std::jthread consumer([&queue](std::stop_token token) {
            while (true) {
                // 큐에서 아이템을 기다림 (중단 가능)
                auto value = queue.pop(token);

                // pop()이 std::nullopt를 반환했는지 확인
                if (!value) {
                    // 큐가 비어서가 아니라, 중단 요청(request_stop) 때문에 반환된 것임
                    std::cout << "Consumer interrupted" << std::endl;
                    break; // 루프 탈출
                }
                // value.has_value()가 true이므로, *value로 실제 값에 접근
                std::cout << "Consumed: " << *value << std::endl;
            }
        });

        // 메인 스레드는 2초간 대기
        std::this_thread::sleep_for(std::chrono::seconds(2));
        
        // 2초 후, 소비자(consumer) 스레드에게 중단을 요청합니다.
        // 이 호출로 인해 consumer 스레드의 'token'이 'stop_requested' 상태가 됩니다.
        consumer.request_stop();

        // 이 블록 '}'을 빠져나갈 때,
        // producer와 consumer (jthread)의 소멸자가 호출되고,
        // 각 스레드가 종료될 때까지 자동으로 join() (대기) 합니다.
    }
}

int main() {
    demonstration();
    return 0;
}
```


### 실습: stop_token을 사용한 협력적 취소 상세 예시
다음 코드는 디렉터리 내 모든 일반 파일을 순회하며 **각 파일을 4KB 청크 단위로 읽어 간단한 XOR(0x42) 변환을 적용**하고, 결과를 **동일 경로의 임시 파일(`.tmp`)에 쓴 뒤 원본 파일로 교체**하는 대용량 파일 처리기다. 처리 도중 **중단 요청(std::stop_token)** 이 들어오면 원본 파일을 손상시키지 않도록 임시 파일을 정리하고 안전하게 빠져나오도록 설계돼 있다.

* 입력: 최상위 디렉터리 경로
* 동작: 하위 모든 파일을 모아 순차 처리 → 각 파일을 XOR 0x42로 변환 → 임시 파일에 기록 후 `rename`으로 교체
* 중단: 디렉터리 수집 중 또는 파일 처리 중 **중단 신호에 반응**하며, 미완성 임시 파일은 즉시 삭제한다
* 통계: 처리 파일 수, 처리 바이트 수, 오류 수, 소요 시간, 처리량(MB/s) 출력한다

#### 작동 흐름
1. **프로세스 시작/통계 초기화**

   * 시작 시각을 기록하고 예외를 포착해 로그로 남긴다.

2. **Phase 1: 파일 목록 수집**

   * `recursive_directory_iterator`로 하위 디렉터리를 모두 훑어 **일반 파일 경로만 벡터에 수집**한다.
   * 수집 중 `token.stop_requested()`가 참이면 “수집 중단”을 출력하고 즉시 반환한다.

3. **Phase 2: 파일 처리**

   * 수집된 파일들을 순회하며 처리한다. 새 파일에 착수하기 전 중단 요청이 있으면 **현재 파일 이후가 아니라, “현재 파일 착수 자체를 중단”**한다.
   * `process_single_file`:

     * 처리 시작 로그를 남기고 **임시 경로(원본 + `.tmp`)** 를 만든다.
     * `std::stop_callback`을 등록해 **처리 중 중단되면 임시 파일을 삭제**하도록 한다.
     * 원본을 바이너리로 읽고, 임시 파일에 바이너리로 쓴다.
     * 반복 루프에서 최대 4KB씩 읽어 **각 바이트에 `^ 0x42`(XOR)** 를 적용한 뒤 임시 파일에 기록한다.
     * 누적 바이트와 전역 통계를 **원자적 카운터**로 업데이트한다.
     * 대용량 파일에서 매 `4096 * 100` 바이트(≈400KB)마다 중단 요청을 확인한다. 요청이 있으면 **임시 파일을 삭제하고 안전히 반환**한다. 원본은 교체되지 않으므로 **손상되지 않는다**.
     * 파일을 끝까지 처리하면 스트림을 닫고 **`std::filesystem::rename(temp, original)`로 원자적 교체**를 시도한다(동일 파일시스템 내에서 사실상 원자적이다).
     * 성공 시 파일 수 증가 및 완료 로그, 실패/예외 시 오류 카운트와 에러 로그를 남긴다.

4. **최종 통계 출력**

   * 총 파일 수, 총 바이트(단위 MB), 오류 수, 소요 시간(초), 그리고 **평균 처리량(MB/s)** 을 출력한다.

#### 중단/복구 전략

* **디렉터리 수집 단계**: 즉시 중단 가능하다.
* **파일 처리 단계**:

  * 새 파일 시작 전 중단 신호가 있으면 그 파일을 건너뛴다.
  * **처리 중** 중단 신호가 오면 루프에서 감지해 **임시 파일을 삭제**하고 반환한다.
  * 원본 파일은 **완료 시점에만** 교체되므로 **부분 처리로 인한 손상 위험이 없다**.

#### 설계 포인트

* `std::atomic`으로 **멀티스레드 안전한 통계 집계**가 가능하다(현재 코드는 단일 스레드 처리지만 확장 용이하다).
* 임시 파일 → `rename` 전략으로 **원자적(동일 파티션 기준) 교체**를 구현해 중간 실패에도 원본 보존을 보장한다.
* `std::stop_token`과 `std::stop_callback`을 활용해 **협력적 취소(cooperative cancellation)** 와 **자원 정리**를 구현한다.

#### 주의/개선 사항

* `rename`의 원자성은 **동일 파일시스템 내**일 때에 한해 보장된다. 다른 볼륨으로 이동되는 경우 원자적이지 않을 수 있다.
* 처리량 계산에서 바이트→MB 변환과 정수 나눗셈으로 인해 **소수점 손실**이 발생한다. 부동소수 계산을 쓰면 더 정확한 처리량을 보여줄 수 있다.
* 매우 큰 디렉터리의 경우 **전체 경로를 먼저 벡터에 모으는 방식**은 메모리 사용량이 커질 수 있다. **스트리밍 처리(수집과 처리 병행)** 로 바꿀 여지가 있다.
* XOR 0x42는 **보안 목적의 암호화가 아니며 단순 변환**에 불과하다.

#### 사용 예시(개략)

```cpp
std::jthread worker([&](std::stop_token st){
    FileProcessor fp;
    fp.process_directory("/path/to/dir", st);
});

// 나중에 중단하고 싶을 때
worker.request_stop();
worker.join();
```

위와 같이 `std::jthread`의 `stop_token`을 전달해 안전하게 시작/중단하는 파일 변환 파이프라인으로 사용할 수 있다.


#### 코드  
  
```cpp
// 필요한 표준 라이브러리 헤더들을 포함합니다.
#include <iostream>     // 콘솔 입출력 (std::cout, std::endl)
#include <thread>       // 스레딩 관련 기능 (std::stop_token, std::stop_callback, std::stop_source)
#include <filesystem>   // 파일 시스템 경로 및 디렉터리 탐색 (std::filesystem::path, ::recursive_directory_iterator)
#include <fstream>      // 파일 입출력 스트림 (std::ifstream, std::ofstream)
#include <vector>       // 동적 배열 (std::vector)
#include <atomic>       // 원자적 연산을 위한 타입 (std::atomic<size_t>)
#include <chrono>       // 시간 측정 (std::chrono::steady_clock)

// 대용량 파일 처리를 담당하는 클래스
class FileProcessor {
private:
    // 파일 처리 통계를 저장하는 내부 구조체
    struct ProcessingStats {
        // 멀티스레드 환경에서도 안전하게 값을 증가시키기 위해 std::atomic 사용
        std::atomic<size_t> files_processed{0}; // 처리 완료된 파일 수
        std::atomic<size_t> bytes_processed{0}; // 처리 완료된 총 바이트 수
        std::atomic<size_t> errors{0};          // 처리 중 발생한 오류 수
        
        // 처리 시작 시간을 기록하기 위한 time_point
        std::chrono::steady_clock::time_point start_time;
    };
    
    // 통계 구조체 인스턴스
    ProcessingStats stats;
    
public:
    /**
     * @brief 디렉터리 처리를 시작하는 공개 메서드 (안전한 중단 지원)
     * @param dir_path 처리할 대상 디렉터리 경로
     * @param token C++20의 중단 토큰. 외부에서 이 처리를 중단시킬 수 있게 함.
     */
    void process_directory(const std::filesystem::path& dir_path, 
                           std::stop_token token) {
        // 처리 시작 시간 기록
        stats.start_time = std::chrono::steady_clock::now();
        
        try {
            // 실제 처리 로직을 구현한 내부 메서드 호출
            process_directory_impl(dir_path, token);
        } catch (const std::exception& e) {
            // 디렉터리 탐색 등 최상위 레벨에서 예외 발생 시 처리
            std::cout << "Processing error: " << e.what() << std::endl;
        }
        
        // 모든 처리가 완료되거나 중단된 후 최종 통계 출력
        print_final_stats();
    }
    
private:
    /**
     * @brief 디렉터리 처리의 실제 구현부
     * @param dir_path 처리할 대상 디렉터리 경로
     * @param token 중단 토큰
     */
    void process_directory_impl(const std::filesystem::path& dir_path,
                                std::stop_token token) {
        
        std::vector<std::filesystem::path> files_to_process; // 처리할 파일 목록을 담을 벡터
        
        // --- Phase 1: 파일 목록 수집 (중단 가능) ---
        // 이 단계는 디렉터리가 매우 클 경우 오래 걸릴 수 있으므로 중단 확인이 필요합니다.
        std::cout << "Collecting files from " << dir_path << "..." << std::endl;
        
        // std::filesystem::recursive_directory_iterator를 사용해 하위 디렉터리까지 모두 탐색
        for (const auto& entry : std::filesystem::recursive_directory_iterator(dir_path)) {
            // 파일 목록 수집 중에 중단 요청이 왔는지 확인
            if (token.stop_requested()) {
                std::cout << "File collection interrupted" << std::endl;
                return; // 함수 즉시 종료
            }
            
            // 일반 파일(regular file)인 경우에만 목록에 추가
            if (entry.is_regular_file()) {
                files_to_process.push_back(entry.path());
            }
        }
        
        std::cout << "Found " << files_to_process.size() << " files" << std::endl;
        
        // --- Phase 2: 파일 처리 (각 파일은 원자적으로 처리) ---
        // 수집된 파일 목록을 순회하며 하나씩 처리
        for (const auto& file_path : files_to_process) {
            // *중요*: 새 파일 처리를 시작하기 *전*에 중단 요청 확인
            if (token.stop_requested()) {
                std::cout << "\nProcessing interrupted. Safely stopping." << std::endl;
                // 이미 진행 중인 파일은 완료되었거나 정리되었을 것이므로,
                // 여기서는 새 파일 처리를 시작하지 않고 루프를 빠져나갑니다.
                break; 
            }
            
            // 개별 파일 처리 함수 호출
            process_single_file(file_path, token);
        }
    }
    
    /**
     * @brief 단일 파일을 처리하는 메서드 (파일 처리 중에도 중단 가능)
     * @param file_path 처리할 파일의 경로
     * @param token 중단 토큰
     */
    void process_single_file(const std::filesystem::path& file_path,
                             std::stop_token token) {
        
        std::cout << "Processing: " << file_path.filename() << " ";
        
        // 처리 중인 데이터를 쓸 임시 파일 경로 생성 (원본 파일 보호)
        std::filesystem::path temp_path = file_path.string() + ".tmp";
        
        // --- 중단 콜백 설정 (C++20 std::stop_callback) ---
        // 이 콜백은 'token'이 중단 요청을 받을 때 *자동으로* 호출됩니다.
        // 주로 리소스 정리를 위해 사용됩니다.
        std::stop_callback cleanup(token, [&temp_path]() {
            // 람다 함수: 중단 시 실행될 코드
            if (std::filesystem::exists(temp_path)) {
                std::cout << "\n[Cleanup] Removing temporary file: " 
                          << temp_path << std::endl;
                // 중단되었으므로, 불완전한 임시 파일을 삭제합니다.
                std::filesystem::remove(temp_path);
            }
        });
        
        try {
            // 원본 파일 열기 (바이너리 모드)
            std::ifstream input(file_path, std::ios::binary);
            if (!input) { // 파일 열기 실패
                stats.errors++;
                std::cout << "[ERROR: Could not open input]" << std::endl;
                return; // 이 파일 처리 종료
            }
            
            // 임시 파일 열기 (바이너리 모드)
            std::ofstream output(temp_path, std::ios::binary);
            if (!output) { // 임시 파일 생성 실패
                stats.errors++;
                std::cout << "[ERROR: Could not create temp file]" << std::endl;
                return; // 이 파일 처리 종료
            }
            
            // 청크(Chunk) 단위로 파일을 읽고 쓰기 위한 설정
            const size_t CHUNK_SIZE = 4096; // 4KB 버퍼
            std::vector<char> buffer(CHUNK_SIZE);
            size_t total_bytes = 0; // 이 파일에서 처리한 바이트 수
            
            // 파일 끝에 도달할 때까지 청크 단위로 읽기
            // input.read()는 읽기에 성공하면 true를 반환.
            // input.gcount() > 0 는 파일의 마지막 부분이 CHUNK_SIZE보다 작을 경우를 처리.
            while (input.read(buffer.data(), CHUNK_SIZE) || input.gcount() > 0) {
                size_t bytes_read = input.gcount(); // 실제로 읽은 바이트 수
                
                // --- 실제 데이터 처리 로직 (시뮬레이션) ---
                // (예: 간단한 XOR 암호화)
                for (size_t i = 0; i < bytes_read; ++i) {
                    buffer[i] ^= 0x42; // 0x42와 XOR 연산
                }
                // --- 데이터 처리 끝 ---
                
                // 처리된 데이터를 임시 파일에 쓰기
                output.write(buffer.data(), bytes_read);
                
                total_bytes += bytes_read;
                stats.bytes_processed += bytes_read; // 전체 통계(atomic)에 반영
                
                // (선택적) 매우 큰 파일의 경우, 처리 *중*에도 중단 확인
                // 약 4MB(4096 * 100)마다 한 번씩 확인
                if (total_bytes % (CHUNK_SIZE * 100) == 0) {
                    if (token.stop_requested()) {
                        std::cout << "[INTERRUPTED at " 
                                  << (total_bytes / 1024) << "KB]" << std::endl;
                        
                        // 여기서 return하면, 함수가 종료되고,
                        // 이 함수의 시작 부분에 등록된 'stop_callback' (cleanup)이
                        // *자동으로* 호출되어 temp_path를 삭제합니다.
                        return; 
                    }
                }
            }
            
            // --- 파일 처리 성공 ---
            input.close();
            output.close();
            
            // *중요*: 처리가 성공적으로 완료되었을 때만
            // 원본 파일을 임시 파일로 원자적(atomic)하게 교체합니다.
            std::filesystem::rename(temp_path, file_path);
            
            stats.files_processed++; // 성공한 파일 수 증가
            std::cout << "[OK] " << (total_bytes / 1024) << "KB" << std::endl;
            
        } catch (const std::exception& e) {
            // 파일 I/O 등 개별 파일 처리 중 예외 발생 시
            stats.errors++;
            std::cout << "[ERROR: " << e.what() << "]" << std::endl;
            // 예외가 발생해도 temp_path는 남아있을 수 있지만,
            // 이 함수가 종료되면 (catch 블록 이후) 'cleanup' 객체가 소멸됩니다.
            // 하지만 'stop_requested()'가 호출되지 않았으므로 콜백은 실행되지 않습니다.
            // 따라서 임시 파일을 수동으로 정리해주는 것이 좋습니다.
            if (std::filesystem::exists(temp_path)) {
                std::filesystem::remove(temp_path);
            }
        }
    }
    
    /**
     * @brief 작업 완료 후 최종 통계를 출력하는 헬퍼 함수
     */
    void print_final_stats() {
        auto end_time = std::chrono::steady_clock::now(); // 종료 시간
        // 시작 시간과 종료 시간의 차이를 초 단위로 계산
        auto duration = std::chrono::duration_cast<std::chrono::seconds>
                          (end_time - stats.start_time);
        
        std::cout << "\n=== Processing Statistics ===" << std::endl;
        std::cout << "Files processed: " << stats.files_processed << std::endl;
        std::cout << "Bytes processed: " << stats.bytes_processed / (1024*1024) << " MB" << std::endl;
        std::cout << "Errors: " << stats.errors << std::endl;
        std::cout << "Duration: " << duration.count() << " seconds" << std::endl;
        
        // 0으로 나누기 방지
        if (duration.count() > 0) {
            std::cout << "Throughput: " 
                      // 초당 처리량 (MB/s) 계산
                      << (stats.bytes_processed / (1024*1024)) / duration.count() 
                      << " MB/s" << std::endl;
        }
    }
};
```  
  
main 함수 예시   
이 예제는 'test_dir'라는 디렉터리를 만들고 5개의 더미 파일을 생성한 후, FileProcessor를 별도 스레드에서 실행하고 2초 후에 중단시킨다.    
```  
// main 함수를 위한 추가 헤더
#include <random> // 더미 파일 생성을 위한 난수

// 테스트 디렉터리 및 더미 파일 생성 함수
void setup_test_directory(const std::string& dir_name, int num_files, int file_size_kb) {
    std::filesystem::create_directory(dir_name);
    
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, 255);

    for (int i = 0; i < num_files; ++i) {
        std::filesystem::path file_path = std::filesystem::path(dir_name) / ("file_" + std::to_string(i) + ".dat");
        std::ofstream outfile(file_path, std::ios::binary);
        std::vector<char> buffer(1024); // 1KB
        for (int k = 0; k < file_size_kb; ++k) {
            for(size_t j = 0; j < buffer.size(); ++j) {
                buffer[j] = static_cast<char>(dis(gen));
            }
            outfile.write(buffer.data(), buffer.size());
        }
        outfile.close();
    }
    std::cout << "Created " << num_files << " dummy files in '" << dir_name << "'" << std::endl;
}


int main() {
    const std::string TEST_DIR = "test_dir";
    
    // 테스트 환경 설정: 5개의 파일, 각 10MB (10 * 1024 KB)
    setup_test_directory(TEST_DIR, 5, 10 * 1024); 

    FileProcessor processor;
    
    // C++20 중단 요청을 보내기 위한 소스
    std::stop_source stop_source;
    
    // FileProcessor를 실행할 JThread 생성
    // std::jthread는 소멸 시 자동으로 join되며, stop_token을 생성자에 전달합니다.
    std::jthread processing_thread([&processor, &TEST_DIR](std::stop_token token) {
        processor.process_directory(TEST_DIR, token);
    }, stop_source.get_token()); // 스레드에 stop_token 전달

    std::cout << "\nStarting processing... Will request stop in 2 seconds.\n" << std::endl;
    
    // 메인 스레드에서 2초간 대기
    std::this_thread::sleep_for(std::chrono::seconds(2));
    
    // 2초 후, 처리 스레드에 중단 요청
    std::cout << "\n*** Requesting stop ***\n" << std::endl;
    stop_source.request_stop();
    
    // jthread는 여기서 main 함수가 종료될 때 자동으로 join됩니다.
    // (일반 std::thread였다면 processing_thread.join()이 필요합니다.)

    return 0;
}
```   