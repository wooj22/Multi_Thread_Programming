# 9주차 실습 
  
## 문제 1: 스레드 안전한 카운터 만들기

**문제:**
10개의 스레드를 생성하여 각 스레드가 100,000번씩 카운터를 증가시키는 프로그램을 작성하세요. `std::atomic<int>`를 사용하여 데이터 레이스(data race) 없이 최종 결과가 정확히 1,000,000이 나오도록 보장하세요.

**힌트:**
일반 `int` 대신 `std::atomic<int>` 타입의 변수를 선언하고, 각 스레드에서 이 변수의 `++` 연산자를 호출하면 됩니다.

**답안:**


-----

## 문제 2: 간단한 생산자-소비자 플래그

**문제:**
`std::atomic<bool>`을 사용하여 간단한 생산자-소비자 시나리오를 구현하세요.

1.  생산자(Producer) 스레드는 1초간 대기 후, `data` (일반 `int`) 변수에 100을 쓰고 `ready` 플래그를 `true`로 설정합니다.
2.  소비자(Consumer) 스레드는 `ready` 플래그가 `true`가 될 때까지 `load()`를 호출하며 대기(spinning)합니다.
3.  `ready`가 `true`가 되면, `data` 값을 읽어 "데이터: [값]"을 출력합니다.

**힌트:**
소비자 스레드에서 `while` 루프를 사용하여 `ready.load()`가 `true`를 반환할 때까지 기다리세요. 생산자 스레드에서는 데이터를 쓴 후 `ready.store(true)`를 호출하세요.

**답안:**


-----

## 문제 3: 작업 교환(exchange)

**문제:**
단 하나의 작업(task)을 나타내는 `std::atomic<int> task_id{100}` 변수가 있습니다. 여러 개의 워커(worker) 스레드가 이 작업을 가져가려고 시도합니다. `exchange()`를 사용하여, 단 하나의 스레드만 원래 값(100)을 가져가고, `task_id`를 0 (작업 완료)으로 설정하도록 구현하세요. 작업을 가져간 스레드는 "스레드 [ID]가 작업 [작업 ID]를 가져감"을 출력하고, 나머지는 "스레드 [ID]가 작업에 실패함"을 출력하세요.

**힌트:**
`task_id.exchange(0)`을 호출하면 현재 값을 0으로 바꾸고 *이전* 값을 반환합니다. 반환된 값이 100인 스레드가 작업을 획득한 스레드입니다.

**답안:**


-----

## 문제 4: Compare-And-Swap (CAS)으로 값 갱신

**문제:**
`std::atomic<int> value{10}`가 있습니다. 스레드에서 `value`의 현재 값이 10일 경우에만 20으로 갱신하는 코드를 작성하세요. `compare_exchange_strong()`을 사용하세요.

1.  값이 10이어서 갱신에 성공하면 "성공: 10 -\> 20"을 출력하세요.
2.  다른 스레드가 값을 먼저 변경(예: 15)하여 갱신에 실패하면, "실패: 현재 값 [실제 값]"을 출력하세요.

**힌트:**
`compare_exchange_strong(expected, desired)`는 `expected` 변수를 인자로 받습니다. `expected`에 예상 값(10)을, `desired`에 새 값(20)을 넣으세요. 함수가 `false`를 반환하면 `expected` 변수는 `value`의 실제 값으로 갱신됩니다.

**답안:**


-----

## 문제 5: 은행 계좌 입출금 시뮬레이션

**문제:**
`std::atomic<long> balance{1000}`로 은행 계좌 잔액을 나타냅니다. 5개의 "입금" 스레드와 5개의 "출금" 스레드를 만드세요.

  * 각 입금 스레드는 100씩 10번 입금합니다 (`fetch_add`).
  * 각 출금 스레드는 50씩 10번 출금합니다 (`fetch_sub`).
    모든 스레드 종료 후 최종 잔액을 출력하세요. (초기 1000 + (5 \* 100 \* 10) - (5 \* 50 \* 10) = 3500)

**힌트:**
입금 스레드는 `balance.fetch_add(100)`을, 출금 스레드는 `balance.fetch_sub(50)`을 루프 안에서 호출하면 됩니다.

**답안:**


-----

## 문제 6: `std::atomic_flag`로 스핀락 구현

**문제:**
문서에 나온 `Spinlock` 클래스는 `std::atomic<bool>`과 `exchange`를 사용했습니다. C++에서 스핀락 구현을 위해 특별히 제공되는 `std::atomic_flag`를 사용하여 `Spinlock` 클래스를 다시 구현해 보세요. `atomic_flag`는 `test_and_set()`과 `clear()` 멤버 함수를 가집니다.

**힌트:**

  * `std::atomic_flag`는 `ATOMIC_FLAG_INIT`로 초기화해야 합니다 (기본값은 'clear' 상태).
  * `lock()`: `test_and_set()`이 `true` (이미 set 되어 있었음)를 반환하는 동안 `while` 루프를 돕니다.
  * `unlock()`: `clear()`를 호출하여 플래그를 0(clear) 상태로 되돌립니다.

**답안:**



-----
  
## 문제 7: 최신 값 발행(Publishing)

**문제:**
하나의 "발행(Publisher)" 스레드와 여러 개의 "구독(Subscriber)" 스레드가 있습니다.

  * `std::atomic<int> latest_value{0}` 변수를 사용합니다.
  * 발행 스레드는 1초마다 `latest_value`를 `store()`를 통해 1씩 증가시킵니다 (총 5번).
  * 구독 스레드(3개)들은 500ms마다 `latest_value`를 `load()`하여 현재 값을 출력합니다.

**힌트:**
발행 스레드와 구독 스레드에 각각 다른 `sleep_for` 주기를 주어 비동기적으로 값이 갱신되고 읽히는 것을 관찰하세요.

**답안 (예시 코드):**



