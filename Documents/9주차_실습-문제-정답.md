# 9주차 실습 
  
## 문제 1: 스레드 안전한 카운터 만들기

**문제:**
10개의 스레드를 생성하여 각 스레드가 100,000번씩 카운터를 증가시키는 프로그램을 작성하세요. `std::atomic<int>`를 사용하여 데이터 레이스(data race) 없이 최종 결과가 정확히 1,000,000이 나오도록 보장하세요.

**힌트:**
일반 `int` 대신 `std::atomic<int>` 타입의 변수를 선언하고, 각 스레드에서 이 변수의 `++` 연산자를 호출하면 됩니다.

**답안 (예시 코드):**

```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <atomic>

// 스레드간 공유될 원자적 카운터
std::atomic<int> counter{0};

void increment() {
    for (int i = 0; i < 100000; ++i) {
        // ++ 연산자가 원자적으로 동작합니다.
        ++counter;
    }
}

int main() {
    std::vector<std::thread> threads;
    
    // 10개의 스레드 생성
    for (int i = 0; i < 10; ++i) {
        threads.emplace_back(increment);
    }
    
    // 모든 스레드가 종료될 때까지 대기
    for (auto& t : threads) {
        t.join();
    }
    
    std::cout << "예상 결과: " << 1000000 << "\n";
    // counter.load()를 사용하거나 암시적 변환을 통해 값을 읽을 수 있습니다.
    std::cout << "실제 결과: " << counter << "\n";
    
    return 0;
}
```

-----

## 문제 2: 간단한 생산자-소비자 플래그

**문제:**
`std::atomic<bool>`을 사용하여 간단한 생산자-소비자 시나리오를 구현하세요.

1.  생산자(Producer) 스레드는 1초간 대기 후, `data` (일반 `int`) 변수에 100을 쓰고 `ready` 플래그를 `true`로 설정합니다.
2.  소비자(Consumer) 스레드는 `ready` 플래그가 `true`가 될 때까지 `load()`를 호출하며 대기(spinning)합니다.
3.  `ready`가 `true`가 되면, `data` 값을 읽어 "데이터: [값]"을 출력합니다.

**힌트:**
소비자 스레드에서 `while` 루프를 사용하여 `ready.load()`가 `true`를 반환할 때까지 기다리세요. 생산자 스레드에서는 데이터를 쓴 후 `ready.store(true)`를 호출하세요.

**답안 (예시 코드):**

```cpp
#include <iostream>
#include <thread>
#include <atomic>
#include <chrono>

std::atomic<bool> ready{false};
int data = 0;

void producer() {
    // 작업을 시뮬레이션
    std::this_thread::sleep_for(std::chrono::seconds(1));
    
    data = 100; // 데이터 준비
    ready.store(true); // 데이터가 준비되었음을 알림
}

void consumer() {
    // ready 플래그가 true가 될 때까지 대기
    while (!ready.load()) {
        // CPU 자원 낭비를 줄이기 위해 잠시 멈춤 (선택 사항)
        std::this_thread::yield(); 
    }
    
    // 데이터 읽기
    std::cout << "데이터: " << data << "\n";
}

int main() {
    std::thread t1(producer);
    std::thread t2(consumer);
    
    t1.join();
    t2.join();
    
    return 0;
}
```

-----

## 문제 3: 작업 교환(exchange)

**문제:**
단 하나의 작업(task)을 나타내는 `std::atomic<int> task_id{100}` 변수가 있습니다. 여러 개의 워커(worker) 스레드가 이 작업을 가져가려고 시도합니다. `exchange()`를 사용하여, 단 하나의 스레드만 원래 값(100)을 가져가고, `task_id`를 0 (작업 완료)으로 설정하도록 구현하세요. 작업을 가져간 스레드는 "스레드 [ID]가 작업 [작업 ID]를 가져감"을 출력하고, 나머지는 "스레드 [ID]가 작업에 실패함"을 출력하세요.

**힌트:**
`task_id.exchange(0)`을 호출하면 현재 값을 0으로 바꾸고 *이전* 값을 반환합니다. 반환된 값이 100인 스레드가 작업을 획득한 스레드입니다.

**답안 (예시 코드):**

```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <atomic>

std::atomic<int> task_id{100}; // 초기 작업 ID

void worker_thread() {
    // 0으로 값을 교환하고 이전 값을 반환받음
    int old_task = task_id.exchange(0);
    
    if (old_task == 100) {
        std::cout << "스레드 " << std::this_thread::get_id() 
                  << "가 작업 " << old_task << "를 가져감\n";
    } else {
        std::cout << "스레드 " << std::this_thread::get_id() 
                  << "가 작업에 실패함\n";
    }
}

int main() {
    std::vector<std::thread> threads;
    for (int i = 0; i < 5; ++i) {
        threads.emplace_back(worker_thread);
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    return 0;
}
```

-----

## 문제 4: Compare-And-Swap (CAS)으로 값 갱신

**문제:**
`std::atomic<int> value{10}`가 있습니다. 스레드에서 `value`의 현재 값이 10일 경우에만 20으로 갱신하는 코드를 작성하세요. `compare_exchange_strong()`을 사용하세요.

1.  값이 10이어서 갱신에 성공하면 "성공: 10 -\> 20"을 출력하세요.
2.  다른 스레드가 값을 먼저 변경(예: 15)하여 갱신에 실패하면, "실패: 현재 값 [실제 값]"을 출력하세요.

**힌트:**
`compare_exchange_strong(expected, desired)`는 `expected` 변수를 인자로 받습니다. `expected`에 예상 값(10)을, `desired`에 새 값(20)을 넣으세요. 함수가 `false`를 반환하면 `expected` 변수는 `value`의 실제 값으로 갱신됩니다.

**답안 (예시 코드):**

```cpp
#include <iostream>
#include <atomic>
#include <thread>

std::atomic<int> value{10};

void update_value() {
    int expected = 10;
    int desired = 20;
    
    // value.compare_exchange_strong(expected, desired)
    // 1. value == expected (10 == 10) 인지 비교
    // 2. 같으면: value = desired (20) 로 바꾸고 true 반환
    // 3. 다르면: expected = value (실제 값) 로 바꾸고 false 반환
    
    if (value.compare_exchange_strong(expected, desired)) {
        std::cout << "성공: 10 -> " << desired << "\n";
    } else {
        // 이 시점에서 expected 변수는 value의 현재 값(10이 아닌 값)으로 
        // 갱신되었습니다.
        std::cout << "실패: 현재 값 " << expected << "\n";
    }
}

int main() {
    std::thread t1(update_value);
    t1.join();
    
    // 실패 케이스 테스트 (선택 사항)
    // value.store(15); // 값을 미리 변경
    // std::thread t2(update_value);
    // t2.join(); 
    
    return 0;
}
```

-----

## 문제 5: 은행 계좌 입출금 시뮬레이션

**문제:**
`std::atomic<long> balance{1000}`로 은행 계좌 잔액을 나타냅니다. 5개의 "입금" 스레드와 5개의 "출금" 스레드를 만드세요.

  * 각 입금 스레드는 100씩 10번 입금합니다 (`fetch_add`).
  * 각 출금 스레드는 50씩 10번 출금합니다 (`fetch_sub`).
    모든 스레드 종료 후 최종 잔액을 출력하세요. (초기 1000 + (5 \* 100 \* 10) - (5 \* 50 \* 10) = 3500)

**힌트:**
입금 스레드는 `balance.fetch_add(100)`을, 출금 스레드는 `balance.fetch_sub(50)`을 루프 안에서 호출하면 됩니다.

**답안 (예시 코드):**

```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <atomic>

std::atomic<long> balance{1000};

void deposit() {
    for (int i = 0; i < 100; ++i) {
        balance.fetch_add(10); // 10씩 100번 = 1000 입금
    }
}

void withdraw() {
    for (int i = 0; i < 50; ++i) {
        balance.fetch_sub(10); // 10씩 50번 = 500 출금
    }
}

int main() {
    std::vector<std::thread> threads;
    
    // 입금 스레드 5개 (총 +5000)
    for (int i = 0; i < 5; ++i) {
        threads.emplace_back(deposit);
    }
    
    // 출금 스레드 5개 (총 -2500)
    for (int i = 0; i < 5; ++i) {
        threads.emplace_back(withdraw);
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    // 1000 + 5000 - 2500 = 3500
    std::cout << "최종 잔액: " << balance.load() << "\n";
    
    return 0;
}
```

-----

## 문제 6: `std::atomic_flag`로 스핀락 구현

**문제:**
문서에 나온 `Spinlock` 클래스는 `std::atomic<bool>`과 `exchange`를 사용했습니다. C++에서 스핀락 구현을 위해 특별히 제공되는 `std::atomic_flag`를 사용하여 `Spinlock` 클래스를 다시 구현해 보세요. `atomic_flag`는 `test_and_set()`과 `clear()` 멤버 함수를 가집니다.

**힌트:**

  * `std::atomic_flag`는 `ATOMIC_FLAG_INIT`로 초기화해야 합니다 (기본값은 'clear' 상태).
  * `lock()`: `test_and_set()`이 `true` (이미 set 되어 있었음)를 반환하는 동안 `while` 루프를 돕니다.
  * `unlock()`: `clear()`를 호출하여 플래그를 0(clear) 상태로 되돌립니다.

**답안 (예시 코드):**

```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <atomic>

class Spinlock {
private:
    // ATOMIC_FLAG_INIT는 atomic_flag를 
    // 'clear' (false, 0) 상태로 초기화합니다.
    std::atomic_flag locked = ATOMIC_FLAG_INIT;

public:
    void lock() {
        // test_and_set():
        // 1. 플래그를 'set' (true, 1) 상태로 바꿉니다.
        // 2. 'set'으로 바뀌기 *이전*의 값을 반환합니다.
        
        // 이전 값이 'set'(true)이었다면 (다른 스레드가 락을 잡고 있음)
        // 루프를 계속 돕니다.
        while (locked.test_and_set()) {
            std::this_thread::yield(); // CPU 양보
        }
        // 이전 값이 'clear'(false)였다면 (내가 락을 획득)
        // 루프를 탈출합니다.
    }

    void unlock() {
        // 플래그를 'clear' (false, 0) 상태로 되돌립니다.
        locked.clear();
    }
};

Spinlock spinlock;
int shared_counter = 0;

void increment_with_spinlock() {
    for (int i = 0; i < 10000; ++i) {
        spinlock.lock();
        ++shared_counter;  // 보호된 영역
        spinlock.unlock();
    }
}

int main() {
    std::vector<std::thread> threads;
    
    for (int i = 0; i < 10; ++i) {
        threads.emplace_back(increment_with_spinlock);
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    std::cout << "결과: " << shared_counter << "\n";  // 100000
    
    return 0;
}
```

-----
  
## 문제 7: 최신 값 발행(Publishing)

**문제:**
하나의 "발행(Publisher)" 스레드와 여러 개의 "구독(Subscriber)" 스레드가 있습니다.

  * `std::atomic<int> latest_value{0}` 변수를 사용합니다.
  * 발행 스레드는 1초마다 `latest_value`를 `store()`를 통해 1씩 증가시킵니다 (총 5번).
  * 구독 스레드(3개)들은 500ms마다 `latest_value`를 `load()`하여 현재 값을 출력합니다.

**힌트:**
발행 스레드와 구독 스레드에 각각 다른 `sleep_for` 주기를 주어 비동기적으로 값이 갱신되고 읽히는 것을 관찰하세요.

**답안 (예시 코드):**

```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <atomic>
#include <chrono>

std::atomic<int> latest_value{0};
std::atomic<bool> running{true}; // 프로그램 종료 플래그

void publisher() {
    for (int i = 1; i <= 5; ++i) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
        latest_value.store(i);
        std::cout << "[발행] 새 값: " << i << "\n";
    }
    running.store(false); // 실행 종료
}

void subscriber(int id) {
    while (running.load()) {
        int current_value = latest_value.load();
        std::cout << "[구독 " << id << "] 현재 값: " 
                  << current_value << "\n";
        
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
    }
}

int main() {
    std::vector<std::thread> threads;
    
    // 발행 스레드 1개
    threads.emplace_back(publisher);
    
    // 구독 스레드 3개
    for (int i = 0; i < 3; ++i) {
        threads.emplace_back(subscriber, i + 1);
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    return 0;
}
```


