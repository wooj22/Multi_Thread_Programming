# 2ì£¼ì°¨: ìš´ì˜ì²´ì œì™€ ë©€í‹°ì“°ë ˆë“œ ê¸°ì´ˆ

## í•™ìŠµ ëª©í‘œ
- ìš´ì˜ì²´ì œì˜ ê¸°ë³¸ ê°œë…ê³¼ ì»¤ë„ì˜ ì—­í• ì„ ì´í•´í•œë‹¤
- í”„ë¡œì„¸ìŠ¤ì™€ ìŠ¤ë ˆë“œì˜ ì°¨ì´ì ì„ ëª…í™•íˆ êµ¬ë¶„í•  ìˆ˜ ìˆë‹¤
- ë©€í‹°í”„ë¡œì„¸ìŠ¤ì™€ ë©€í‹°ìŠ¤ë ˆë“œì˜ ì¥ë‹¨ì ì„ ë¹„êµ ë¶„ì„í•  ìˆ˜ ìˆë‹¤
- ê°„ë‹¨í•œ ë©€í‹°ìŠ¤ë ˆë“œ í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ê³  ì„±ëŠ¥ì„ ì¸¡ì •í•  ìˆ˜ ìˆë‹¤

---

## ì»¤ë„(Kernel) 

### 1. ì»¤ë„(Kernel)ì˜ ì •ì˜ì™€ í•µì‹¬ ê°œë…

#### 1.1 ì»¤ë„ì´ë€?
ì»¤ë„(Kernel)ì€ ìš´ì˜ì²´ì œì˜ í•µì‹¬ êµ¬ì„±ìš”ì†Œë¡œ, ì»´í“¨í„°ì˜ í•˜ë“œì›¨ì–´ì™€ ì†Œí”„íŠ¸ì›¨ì–´ ì‚¬ì´ì—ì„œ ì¤‘ê°œì ì—­í• ì„ ìˆ˜í–‰í•œë‹¤. ë§ˆì¹˜ í˜¸í…”ì˜ ì»¨ì‹œì–´ì§€ì²˜ëŸ¼, ëª¨ë“  ìš”ì²­ì„ ë°›ì•„ì„œ ì ì ˆí•œ ìì›ê³¼ ì—°ê²°í•´ì£¼ëŠ” ì—­í• ì„ í•œë‹¤.

**ì»¤ë„ì˜ í•µì‹¬ íŠ¹ì§•:**
- **ë…ì ì  í•˜ë“œì›¨ì–´ ì ‘ê·¼**: ì˜¤ì§ ì»¤ë„ë§Œì´ í•˜ë“œì›¨ì–´ì— ì§ì ‘ ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤
- **ìì› ê´€ë¦¬ì**: CPU, ë©”ëª¨ë¦¬, ì €ì¥ì¥ì¹˜, ë„¤íŠ¸ì›Œí¬ ë“± ëª¨ë“  ì‹œìŠ¤í…œ ìì›ì„ ê´€ë¦¬
- **ë³´ì•ˆ ê²Œì´íŠ¸í‚¤í¼**: ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ëª¨ë“  ì‹œìŠ¤í…œ ìš”ì²­ì„ ê²€ì¦í•˜ê³  ì œì–´
- **ì„œë¹„ìŠ¤ ì œê³µì**: ì‹œìŠ¤í…œ ì½œì„ í†µí•´ í‘œì¤€í™”ëœ ì„œë¹„ìŠ¤ë¥¼ ì œê³µ

#### 1.2 ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ì—ì„œì˜ ì»¤ë„ ìœ„ì¹˜

<pre>
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ì‚¬ìš©ì ì• í”Œë¦¬ì¼€ì´ì…˜                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚   ê²Œì„ í´ë¼  â”‚ â”‚   ì›¹ ë¸Œë¼ìš°ì €â”‚ â”‚      ê°œë°œ ë„êµ¬            â”‚ â”‚
â”‚  â”‚   ì´ì–¸íŠ¸     â”‚ â”‚             â”‚ â”‚                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â† ìœ ì € ëª¨ë“œ/ì»¤ë„ ëª¨ë“œ ê²½ê³„
â”‚                        ì»¤ë„ ê³µê°„                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ í”„ë¡œì„¸ìŠ¤     â”‚ â”‚   ë©”ëª¨ë¦¬     â”‚ â”‚     íŒŒì¼ ì‹œìŠ¤í…œ           â”‚ â”‚
â”‚  â”‚ ê´€ë¦¬ì       â”‚ â”‚   ê´€ë¦¬ì     â”‚ â”‚     ê´€ë¦¬ì               â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ ë„¤íŠ¸ì›Œí¬     â”‚ â”‚ ë””ë°”ì´ìŠ¤     â”‚ â”‚     ìŠ¤ì¼€ì¤„ëŸ¬              â”‚ â”‚
â”‚  â”‚ ìŠ¤íƒ         â”‚ â”‚ ë“œë¼ì´ë²„     â”‚ â”‚                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      í•˜ë“œì›¨ì–´ ê³„ì¸µ                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚     CPU     â”‚ â”‚    ë©”ëª¨ë¦¬   â”‚ â”‚       ì €ì¥ì¥ì¹˜            â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ ë„¤íŠ¸ì›Œí¬     â”‚ â”‚   ê·¸ë˜í”½    â”‚ â”‚      ê¸°íƒ€ ì¥ì¹˜             â”‚ â”‚
â”‚  â”‚ ì¸í„°í˜ì´ìŠ¤   â”‚ â”‚   ì¹´ë“œ      â”‚ â”‚                           â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</pre>

#### 1.3 ì»¤ë„ì˜ ì£¼ìš” ì—­í• ê³¼ ê¸°ëŠ¥

**1) í”„ë¡œì„¸ìŠ¤ ë° ìŠ¤ë ˆë“œ ê´€ë¦¬**
- í”„ë¡œì„¸ìŠ¤ ìƒì„±, ì¢…ë£Œ, ìŠ¤ì¼€ì¤„ë§
- ìŠ¤ë ˆë“œ ê°„ ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­
- ìš°ì„ ìˆœìœ„ ê¸°ë°˜ CPU í• ë‹¹

**2) ë©”ëª¨ë¦¬ ê´€ë¦¬**
- ê°€ìƒ ë©”ëª¨ë¦¬ ì‹œìŠ¤í…œ ìš´ì˜
- í˜ì´ì§€ êµì²´ ì•Œê³ ë¦¬ì¦˜ ì‹¤í–‰
- ë©”ëª¨ë¦¬ ë³´í˜¸ ë° ê²©ë¦¬

**3) íŒŒì¼ ì‹œìŠ¤í…œ ê´€ë¦¬**
- íŒŒì¼ ìƒì„±, ì½ê¸°, ì“°ê¸°, ì‚­ì œ
- ë””ë ‰í† ë¦¬ êµ¬ì¡° ê´€ë¦¬
- ì ‘ê·¼ ê¶Œí•œ ì œì–´

**4) ë„¤íŠ¸ì›Œí¬ ê´€ë¦¬**
- ì†Œì¼“ ìƒì„± ë° ê´€ë¦¬
- í”„ë¡œí† ì½œ ìŠ¤íƒ ìš´ì˜
- íŒ¨í‚· ë¼ìš°íŒ…

**5) ë””ë°”ì´ìŠ¤ ê´€ë¦¬**
- í•˜ë“œì›¨ì–´ ì¶”ìƒí™”
- ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬
- ë””ë°”ì´ìŠ¤ ë“œë¼ì´ë²„ ì¸í„°í˜ì´ìŠ¤
  

### 2. ê²Œì„ ì„œë²„ ê´€ì ì—ì„œ ë³´ëŠ” ì»¤ë„ì˜ ì—­í• 
ê²Œì„ ì„œë²„ëŠ” ìˆ˜ë§ì€ í´ë¼ì´ì–¸íŠ¸ì™€ ì‹¤ì‹œê°„ìœ¼ë¡œ í†µì‹ í•˜ë©´ì„œ ê²Œì„ ìƒíƒœë¥¼ ê´€ë¦¬í•´ì•¼ í•œë‹¤. ì´ ê³¼ì •ì—ì„œ ì»¤ë„ì˜ ë‹¤ì–‘í•œ ê¸°ëŠ¥ì„ í™œìš©í•œë‹¤.

#### 2.1 ë„¤íŠ¸ì›Œí¬ íŒ¨í‚· ì²˜ë¦¬ë¥¼ ìœ„í•œ ì†Œì¼“ ê´€ë¦¬

```cpp
// ê²Œì„ ì„œë²„ì˜ ë„¤íŠ¸ì›Œí¬ ì²˜ë¦¬ ì˜ˆì‹œ
#include <WinSock2.h>
#include <iostream>
#include <thread>
#include <vector>

class GameNetworkManager {
private:
    SOCKET listenSocket;
    std::vector<SOCKET> clientSockets;
    
public:
    bool initializeNetwork(int port) {
        // 1. Winsock ì´ˆê¸°í™” (ì»¤ë„ì˜ ë„¤íŠ¸ì›Œí¬ ì„œë¹„ìŠ¤ í™œì„±í™”)
        WSADATA wsaData;
        if (WSAStartup(MAKEWORD(2,2), &wsaData) != 0) {
            std::cout << "WSAStartup ì‹¤íŒ¨" << std::endl;
            return false;
        }
        
        // 2. ì†Œì¼“ ìƒì„± (ì»¤ë„ì— ë„¤íŠ¸ì›Œí¬ ì—”ë“œí¬ì¸íŠ¸ ìš”ì²­)
        listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (listenSocket == INVALID_SOCKET) {
            std::cout << "ì†Œì¼“ ìƒì„± ì‹¤íŒ¨: " << WSAGetLastError() << std::endl;
            WSACleanup();
            return false;
        }
        
        // 3. ì£¼ì†Œ ë°”ì¸ë”© (ì»¤ë„ì— í¬íŠ¸ í• ë‹¹ ìš”ì²­)
        sockaddr_in serverAddr;
        serverAddr.sin_family = AF_INET;
        serverAddr.sin_addr.s_addr = INADDR_ANY;
        serverAddr.sin_port = htons(port);
        
        if (bind(listenSocket, (sockaddr*)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) {
            std::cout << "ë°”ì¸ë”© ì‹¤íŒ¨: " << WSAGetLastError() << std::endl;
            closesocket(listenSocket);
            WSACleanup();
            return false;
        }
        
        // 4. ë¦¬ìŠ¤ë‹ ì‹œì‘ (ì»¤ë„ì— ì—°ê²° ëŒ€ê¸° ìš”ì²­)
        if (listen(listenSocket, SOMAXCONN) == SOCKET_ERROR) {
            std::cout << "ë¦¬ìŠ¤ë‹ ì‹¤íŒ¨: " << WSAGetLastError() << std::endl;
            closesocket(listenSocket);
            WSACleanup();
            return false;
        }
        
        std::cout << "ê²Œì„ ì„œë²„ê°€ í¬íŠ¸ " << port << "ì—ì„œ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤." << std::endl;
        return true;
    }
    
    void acceptClients() {
        while (true) {
            // í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ìˆ˜ë½ (ì»¤ë„ì´ TCP í•¸ë“œì…°ì´í¬ ì²˜ë¦¬)
            SOCKET clientSocket = accept(listenSocket, nullptr, nullptr);
            if (clientSocket != INVALID_SOCKET) {
                clientSockets.push_back(clientSocket);
                std::cout << "ìƒˆ í´ë¼ì´ì–¸íŠ¸ ì—°ê²°ë¨. ì´ í´ë¼ì´ì–¸íŠ¸ ìˆ˜: " 
                         << clientSockets.size() << std::endl;
                
                // ê° í´ë¼ì´ì–¸íŠ¸ë¥¼ ìœ„í•œ ë³„ë„ ìŠ¤ë ˆë“œ ìƒì„±
                std::thread clientThread(&GameNetworkManager::handleClient, this, clientSocket);
                clientThread.detach();
            }
        }
    }
    
private:
    void handleClient(SOCKET clientSocket) {
        char buffer[1024];
        while (true) {
            // ë°ì´í„° ìˆ˜ì‹  (ì»¤ë„ì˜ ë„¤íŠ¸ì›Œí¬ ë²„í¼ì—ì„œ ì½ê¸°)
            int bytesReceived = recv(clientSocket, buffer, sizeof(buffer), 0);
            if (bytesReceived > 0) {
                buffer[bytesReceived] = '\0';
                std::cout << "ìˆ˜ì‹ ëœ ë°ì´í„°: " << buffer << std::endl;
                
                // ì—ì½” ì‘ë‹µ (ì»¤ë„ì„ í†µí•´ ë„¤íŠ¸ì›Œí¬ë¡œ ì „ì†¡)
                send(clientSocket, buffer, bytesReceived, 0);
            } else {
                // ì—°ê²° ì¢…ë£Œ
                std::cout << "í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ì¢…ë£Œ" << std::endl;
                break;
            }
        }
        closesocket(clientSocket);
    }
};
```  
  
**ì»¤ë„ì˜ ì—­í•  ë¶„ì„:**
- **ì†Œì¼“ ìƒì„±**: ì»¤ë„ì´ ë„¤íŠ¸ì›Œí¬ ì¸í„°í˜ì´ìŠ¤ì™€ ì—°ê²°ëœ ì†Œì¼“ êµ¬ì¡°ì²´ ìƒì„±
- **í¬íŠ¸ ë°”ì¸ë”©**: ì»¤ë„ì´ íŠ¹ì • í¬íŠ¸ë¥¼ í•´ë‹¹ í”„ë¡œì„¸ìŠ¤ì— í• ë‹¹
- **ì—°ê²° ê´€ë¦¬**: ì»¤ë„ì´ TCP í•¸ë“œì…°ì´í¬, íŒ¨í‚· ìˆœì„œ ë³´ì¥, ì¬ì „ì†¡ ì²˜ë¦¬
- **ë²„í¼ ê´€ë¦¬**: ì»¤ë„ì´ ì†¡ìˆ˜ì‹  ë²„í¼ë¥¼ ê´€ë¦¬í•˜ì—¬ ë°ì´í„° ì„ì‹œ ì €ì¥
   
  
#### 2.2 ê²Œì„ ë°ì´í„° ì €ì¥ì„ ìœ„í•œ íŒŒì¼ ì‹œìŠ¤í…œ ì ‘ê·¼

```cpp
// ê²Œì„ ë°ì´í„° ì €ì¥ ë° ë¡œë“œ ì‹œìŠ¤í…œ
#include <windows.h>
#include <iostream>
#include <string>
#include <vector>

class GameDataManager {
private:
    std::string dataPath;
    
public:
    GameDataManager(const std::string& path) : dataPath(path) {
        // ë°ì´í„° ë””ë ‰í† ë¦¬ ìƒì„± (ì»¤ë„ì˜ íŒŒì¼ ì‹œìŠ¤í…œ ì„œë¹„ìŠ¤ ì‚¬ìš©)
        CreateDirectory(dataPath.c_str(), NULL);
    }
    
    bool savePlayerData(int playerId, const std::string& data) {
        std::string filename = dataPath + "\\player_" + std::to_string(playerId) + ".dat";
        
        // íŒŒì¼ ìƒì„±/ì—´ê¸° (ì»¤ë„ì— íŒŒì¼ í•¸ë“¤ ìš”ì²­)
        HANDLE fileHandle = CreateFile(
            filename.c_str(),
            GENERIC_WRITE,
            0,                    // ê³µìœ  ëª¨ë“œ ì—†ìŒ
            NULL,                 // ë³´ì•ˆ ì†ì„±
            CREATE_ALWAYS,        // í•­ìƒ ìƒˆë¡œ ìƒì„±
            FILE_ATTRIBUTE_NORMAL,
            NULL
        );
        
        if (fileHandle == INVALID_HANDLE_VALUE) {
            std::cout << "íŒŒì¼ ìƒì„± ì‹¤íŒ¨: " << GetLastError() << std::endl;
            return false;
        }
        
        // ë°ì´í„° ì“°ê¸° (ì»¤ë„ì˜ íŒŒì¼ ì‹œìŠ¤í…œì„ í†µí•´ ë””ìŠ¤í¬ì— ì €ì¥)
        DWORD bytesWritten;
        bool success = WriteFile(
            fileHandle,
            data.c_str(),
            data.length(),
            &bytesWritten,
            NULL
        );
        
        CloseHandle(fileHandle);  // ì»¤ë„ì— íŒŒì¼ í•¸ë“¤ ë°˜í™˜
        
        if (success) {
            std::cout << "í”Œë ˆì´ì–´ " << playerId << " ë°ì´í„° ì €ì¥ ì™„ë£Œ (" 
                     << bytesWritten << " bytes)" << std::endl;
        }
        
        return success;
    }
    
    std::string loadPlayerData(int playerId) {
        std::string filename = dataPath + "\\player_" + std::to_string(playerId) + ".dat";
        
        // íŒŒì¼ ì—´ê¸° (ì»¤ë„ì— ì½ê¸° ì „ìš© íŒŒì¼ í•¸ë“¤ ìš”ì²­)
        HANDLE fileHandle = CreateFile(
            filename.c_str(),
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
        );
        
        if (fileHandle == INVALID_HANDLE_VALUE) {
            std::cout << "íŒŒì¼ ì—´ê¸° ì‹¤íŒ¨: " << GetLastError() << std::endl;
            return "";
        }
        
        // íŒŒì¼ í¬ê¸° í™•ì¸ (ì»¤ë„ì˜ íŒŒì¼ ì‹œìŠ¤í…œ ë©”íƒ€ë°ì´í„° ì¡°íšŒ)
        DWORD fileSize = GetFileSize(fileHandle, NULL);
        if (fileSize == INVALID_FILE_SIZE) {
            CloseHandle(fileHandle);
            return "";
        }
        
        // ë°ì´í„° ì½ê¸° (ì»¤ë„ì´ ë””ìŠ¤í¬ì—ì„œ ë©”ëª¨ë¦¬ë¡œ ë°ì´í„° ë³µì‚¬)
        std::vector<char> buffer(fileSize + 1);
        DWORD bytesRead;
        
        bool success = ReadFile(
            fileHandle,
            buffer.data(),
            fileSize,
            &bytesRead,
            NULL
        );
        
        CloseHandle(fileHandle);
        
        if (success) {
            buffer[bytesRead] = '\0';
            std::cout << "í”Œë ˆì´ì–´ " << playerId << " ë°ì´í„° ë¡œë“œ ì™„ë£Œ (" 
                     << bytesRead << " bytes)" << std::endl;
            return std::string(buffer.data());
        }
        
        return "";
    }
    
    void demonstrateAsyncFileIO() {
        std::cout << "\n=== ë¹„ë™ê¸° íŒŒì¼ I/O ë°ëª¨ ===" << std::endl;
        
        // ì—¬ëŸ¬ í”Œë ˆì´ì–´ ë°ì´í„°ë¥¼ ë³‘ë ¬ë¡œ ì €ì¥
        std::vector<std::thread> saveThreads;
        
        for (int i = 0; i < 5; ++i) {
            saveThreads.emplace_back([this, i]() {
                std::string data = "í”Œë ˆì´ì–´ " + std::to_string(i) + "ì˜ ê²Œì„ ë°ì´í„°\n"
                                 + "ë ˆë²¨: " + std::to_string(i * 10) + "\n"
                                 + "ê²½í—˜ì¹˜: " + std::to_string(i * 1000) + "\n";
                savePlayerData(i, data);
            });
        }
        
        // ëª¨ë“  ì €ì¥ ì‘ì—… ì™„ë£Œ ëŒ€ê¸°
        for (auto& t : saveThreads) {
            t.join();
        }
        
        // ì €ì¥ëœ ë°ì´í„° ë‹¤ì‹œ ë¡œë“œ
        for (int i = 0; i < 5; ++i) {
            std::string loadedData = loadPlayerData(i);
            std::cout << "ë¡œë“œëœ ë°ì´í„°:\n" << loadedData << std::endl;
        }
    }
};
```
  

#### 2.3 ë©”ëª¨ë¦¬ í’€ ê´€ë¦¬

```cpp
// ê²Œì„ ì„œë²„ìš© ë©”ëª¨ë¦¬ í’€ êµ¬í˜„
#include <windows.h>
#include <iostream>
#include <vector>
#include <mutex>

class GameMemoryPool {
private:
    void* poolMemory;
    size_t poolSize;
    size_t blockSize;
    std::vector<void*> freeBlocks;
    std::mutex poolMutex;
    
public:
    GameMemoryPool(size_t totalSize, size_t blockSize) 
        : poolSize(totalSize), blockSize(blockSize) {
        
        // ì»¤ë„ì—ê²Œ ëŒ€ìš©ëŸ‰ ë©”ëª¨ë¦¬ ë¸”ë¡ ìš”ì²­
        poolMemory = VirtualAlloc(
            NULL,                    // ì‹œìŠ¤í…œì´ ì£¼ì†Œ ê²°ì •
            poolSize,               // í• ë‹¹í•  í¬ê¸°
            MEM_COMMIT | MEM_RESERVE, // ë¬¼ë¦¬ ë©”ëª¨ë¦¬ ì¦‰ì‹œ í• ë‹¹
            PAGE_READWRITE          // ì½ê¸°/ì“°ê¸° ê¶Œí•œ
        );
        
        if (poolMemory == NULL) {
            throw std::runtime_error("ë©”ëª¨ë¦¬ í’€ í• ë‹¹ ì‹¤íŒ¨");
        }
        
        // ë©”ëª¨ë¦¬ ë¸”ë¡ë“¤ì„ ììœ  ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€
        char* ptr = static_cast<char*>(poolMemory);
        size_t numBlocks = poolSize / blockSize;
        
        for (size_t i = 0; i < numBlocks; ++i) {
            freeBlocks.push_back(ptr + i * blockSize);
        }
        
        std::cout << "ë©”ëª¨ë¦¬ í’€ ìƒì„±: " << totalSize << " bytes, "
                  << numBlocks << "ê°œ ë¸”ë¡ (ê° " << blockSize << " bytes)" << std::endl;
    }
    
    void* allocate() {
        std::lock_guard<std::mutex> lock(poolMutex);
        
        if (freeBlocks.empty()) {
            std::cout << "ë©”ëª¨ë¦¬ í’€ ê³ ê°ˆ!" << std::endl;
            return nullptr;
        }
        
        void* block = freeBlocks.back();
        freeBlocks.pop_back();
        
        return block;
    }
    
    void deallocate(void* ptr) {
        if (ptr == nullptr) return;
        
        std::lock_guard<std::mutex> lock(poolMutex);
        freeBlocks.push_back(ptr);
    }
    
    void printStatus() {
        std::lock_guard<std::mutex> lock(poolMutex);
        size_t usedBlocks = (poolSize / blockSize) - freeBlocks.size();
        std::cout << "ë©”ëª¨ë¦¬ í’€ ìƒíƒœ: " << usedBlocks << " ì‚¬ìš©ì¤‘, "
                  << freeBlocks.size() << " ì‚¬ìš©ê°€ëŠ¥" << std::endl;
    }
    
    ~GameMemoryPool() {
        if (poolMemory) {
            // ì»¤ë„ì—ê²Œ ë©”ëª¨ë¦¬ ë°˜í™˜
            VirtualFree(poolMemory, 0, MEM_RELEASE);
        }
    }
};

// ê²Œì„ ì˜¤ë¸Œì íŠ¸ ì˜ˆì‹œ
struct GameObject {
    int id;
    float x, y, z;
    char data[256];  // ê²Œì„ ì˜¤ë¸Œì íŠ¸ ë°ì´í„°
    
    GameObject(int id) : id(id), x(0), y(0), z(0) {
        std::cout << "GameObject " << id << " ìƒì„±ë¨" << std::endl;
    }
    
    ~GameObject() {
        std::cout << "GameObject " << id << " ì†Œë©¸ë¨" << std::endl;
    }
};
```
  

### ì‹¤ìŠµ 1: ì»¤ë„ ì„œë¹„ìŠ¤ ëª¨ë‹ˆí„°ë§ 
ì»¤ë„ì´ ì œê³µí•˜ëŠ” ì„œë¹„ìŠ¤ë“¤ì„ ì‹¤ì œë¡œ ê´€ì°°í•´ë³´ì.  

`KernelServiceMonitor`  

```cpp
// KernelMonitor.cpp
#include <windows.h>
#include <iostream>
#include <thread>
#include <psapi.h>

class KernelServiceMonitor {
public:
    static void monitorMemoryUsage() {
        PROCESS_MEMORY_COUNTERS_EX pmc;
        
        while (true) {
            if (GetProcessMemoryInfo(GetCurrentProcess(), 
                                   (PROCESS_MEMORY_COUNTERS*)&pmc, sizeof(pmc))) {
                
                std::cout << "\n=== ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ (ì»¤ë„ ê´€ë¦¬) ===" << std::endl;
                std::cout << "ë¬¼ë¦¬ ë©”ëª¨ë¦¬ ì‚¬ìš©: " << pmc.WorkingSetSize / 1024 << " KB" << std::endl;
                std::cout << "ê°€ìƒ ë©”ëª¨ë¦¬ ì‚¬ìš©: " << pmc.PrivateUsage / 1024 << " KB" << std::endl;
                std::cout << "í˜ì´ì§€ í´íŠ¸ ìˆ˜: " << pmc.PageFaultCount << std::endl;
            }
            
            std::this_thread::sleep_for(std::chrono::seconds(2));
        }
    }
    
    static void monitorThreads() {
        DWORD currentProcessId = GetCurrentProcessId();
        
        while (true) {
            HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
            if (snapshot == INVALID_HANDLE_VALUE) continue;
            
            THREADENTRY32 threadEntry;
            threadEntry.dwSize = sizeof(THREADENTRY32);
            
            int threadCount = 0;
            if (Thread32First(snapshot, &threadEntry)) {
                do {
                    if (threadEntry.th32OwnerProcessID == currentProcessId) {
                        threadCount++;
                    }
                } while (Thread32Next(snapshot, &threadEntry));
            }
            
            CloseHandle(snapshot);
            
            std::cout << "í˜„ì¬ í”„ë¡œì„¸ìŠ¤ì˜ ìŠ¤ë ˆë“œ ìˆ˜: " << threadCount << std::endl;
            std::this_thread::sleep_for(std::chrono::seconds(3));
        }
    }
};
```
  

### ì‹¤ìŠµ 2: ì‹œìŠ¤í…œ ì½œ ì„±ëŠ¥ ì¸¡ì • 
ë‹¤ì–‘í•œ ì‹œìŠ¤í…œ ì½œì˜ ì„±ëŠ¥ì„ ì¸¡ì •í•´ë³´ì.  
  
`SystemCallBenchmark`    

```cpp
// SystemCallBenchmark.cpp
#include <windows.h>
#include <iostream>
#include <chrono>
#include <vector>

class SystemCallBenchmark 
{
public:
    static void benchmarkFileOperations() {
        const int iterations = 1000;
        std::vector<double> times;
        
        std::cout << "íŒŒì¼ ì‹œìŠ¤í…œ ì½œ ë²¤ì¹˜ë§ˆí¬ ì‹œì‘..." << std::endl;
        
        for (int i = 0; i < iterations; ++i) {
            auto start = std::chrono::high_resolution_clock::now();
            
            // íŒŒì¼ ìƒì„± ì‹œìŠ¤í…œ ì½œ
            HANDLE file = CreateFile(
                "test_file.tmp",
                GENERIC_WRITE,
                0,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE,
                NULL
            );
            
            if (file != INVALID_HANDLE_VALUE) {
                CloseHandle(file);  // íŒŒì¼ ë‹«ê¸° ì‹œìŠ¤í…œ ì½œ
            }
            
            auto end = std::chrono::high_resolution_clock::now();
            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
            times.push_back(duration.count());
        }
        
        // í†µê³„ ê³„ì‚°
        double total = 0;
        for (double time : times) {
            total += time;
        }
        double average = total / times.size();
        
        std::cout << "í‰ê·  íŒŒì¼ ìƒì„±/ì‚­ì œ ì‹œê°„: " << average << " Î¼s" << std::endl;
    }
    
    static void benchmarkMemoryOperations() {
        const int iterations = 10000;
        const size_t allocSize = 1024 * 1024;  // 1MB
        
        std::cout << "ë©”ëª¨ë¦¬ ì‹œìŠ¤í…œ ì½œ ë²¤ì¹˜ë§ˆí¬ ì‹œì‘..." << std::endl;
        
        auto start = std::chrono::high_resolution_clock::now();
        
        for (int i = 0; i < iterations; ++i) {
            // ë©”ëª¨ë¦¬ í• ë‹¹ ì‹œìŠ¤í…œ ì½œ
            void* ptr = VirtualAlloc(NULL, allocSize, MEM_COMMIT, PAGE_READWRITE);
            if (ptr) {
                // ë©”ëª¨ë¦¬ í•´ì œ ì‹œìŠ¤í…œ ì½œ
                VirtualFree(ptr, 0, MEM_RELEASE);
            }
        }
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        
        std::cout << iterations << "íšŒ ë©”ëª¨ë¦¬ í• ë‹¹/í•´ì œ ì‹œê°„: " << duration.count() << " ms" << std::endl;
        std::cout << "í‰ê·  ì‹œê°„: " << (double)duration.count() / iterations << " ms" << std::endl;
    }
    
    static void benchmarkThreadOperations() {
        const int iterations = 100;
        
        std::cout << "ìŠ¤ë ˆë“œ ì‹œìŠ¤í…œ ì½œ ë²¤ì¹˜ë§ˆí¬ ì‹œì‘..." << std::endl;
        
        auto start = std::chrono::high_resolution_clock::now();
        
        for (int i = 0; i < iterations; ++i) {
            // ìŠ¤ë ˆë“œ ìƒì„± ì‹œìŠ¤í…œ ì½œ
            HANDLE thread = CreateThread(NULL, 0, [](LPVOID) -> DWORD {
                return 0;  // ì¦‰ì‹œ ì¢…ë£Œ
            }, NULL, 0, NULL);
            
            if (thread) {
                WaitForSingleObject(thread, INFINITE);  // ìŠ¤ë ˆë“œ ëŒ€ê¸° ì‹œìŠ¤í…œ ì½œ
                CloseHandle(thread);  // í•¸ë“¤ ë‹«ê¸° ì‹œìŠ¤í…œ ì½œ
            }
        }
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        
        std::cout << iterations << "ê°œ ìŠ¤ë ˆë“œ ìƒì„±/ì¢…ë£Œ ì‹œê°„: " << duration.count() << " ms" << std::endl;
        std::cout << "í‰ê·  ì‹œê°„: " << (double)duration.count() / iterations << " ms" << std::endl;
    }
};
```
  
  
### ì •ë¦¬
ì»¤ë„ì€ ê²Œì„ ì„œë²„ ê°œë°œì—ì„œ ì—†ì–´ì„œëŠ” ì•ˆ ë  í•µì‹¬ ìš”ì†Œë‹¤. ë„¤íŠ¸ì›Œí¬ í†µì‹ , ë©”ëª¨ë¦¬ ê´€ë¦¬, íŒŒì¼ ì‹œìŠ¤í…œ, ìŠ¤ë ˆë“œ ê´€ë¦¬ ë“± ëª¨ë“  ì‹œìŠ¤í…œ ìì›ì— ëŒ€í•œ ì ‘ê·¼ì€ ì»¤ë„ì„ í†µí•´ ì´ë£¨ì–´ì§„ë‹¤. 
íš¨ìœ¨ì ì¸ ê²Œì„ ì„œë²„ë¥¼ ê°œë°œí•˜ë ¤ë©´ ì»¤ë„ì˜ ë™ì‘ ë°©ì‹ì„ ì´í•´í•˜ê³ , ì ì ˆí•œ ì‹œìŠ¤í…œ ì½œì„ ì„ íƒí•˜ì—¬ ì„±ëŠ¥ì„ ìµœì í™”í•´ì•¼ í•œë‹¤. ë‹¤ìŒ ì‹œê°„ì—ëŠ” ìœ ì € ëª¨ë“œì™€ ì»¤ë„ ëª¨ë“œì˜ ì „í™˜ ê³¼ì •ê³¼ ê·¸ì— ë”°ë¥¸ ì„±ëŠ¥ ì˜í–¥ì„ ë” ìì„¸íˆ ì‚´í´ë³´ê² ë‹¤.

-----  
  

## ìœ ì € ëª¨ë“œ vs ì»¤ë„ ëª¨ë“œ

### ê¸°ë³¸ ê°œë…
í˜„ëŒ€ ìš´ì˜ì²´ì œëŠ” ë³´ì•ˆê³¼ ì•ˆì •ì„±ì„ ìœ„í•´ **ê¶Œí•œ ë ˆë²¨**ì„ êµ¬ë¶„í•´ì„œ ë™ì‘í•œë‹¤. ì´ëŠ” ë§ˆì¹˜ íšŒì‚¬ì—ì„œ ì¼ë°˜ ì§ì›ê³¼ ê´€ë¦¬ìì˜ ê¶Œí•œì„ êµ¬ë¶„í•˜ëŠ” ê²ƒê³¼ ë¹„ìŠ·í•´.

**ìœ ì € ëª¨ë“œ (User Mode)**
- ì¼ë°˜ì ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ë“¤ì´ ì‹¤í–‰ë˜ëŠ” ëª¨ë“œ
- í•˜ë“œì›¨ì–´ì— ì§ì ‘ ì ‘ê·¼í•  ìˆ˜ ì—†ìŒ
- ë©”ëª¨ë¦¬ ì ‘ê·¼ì´ ì œí•œë¨ (ê°€ìƒ ë©”ëª¨ë¦¬ ì˜ì—­ë§Œ)
- CPUì˜ íŠ¹ê¶Œ ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŒ
- ì•ˆì „í•˜ì§€ë§Œ ì œí•œì ì¸ í™˜ê²½

**ì»¤ë„ ëª¨ë“œ (Kernel Mode)**
- ìš´ì˜ì²´ì œ ì»¤ë„ê³¼ ë””ë°”ì´ìŠ¤ ë“œë¼ì´ë²„ê°€ ì‹¤í–‰ë˜ëŠ” ëª¨ë“œ
- í•˜ë“œì›¨ì–´ì— ì§ì ‘ ì ‘ê·¼ ê°€ëŠ¥
- ëª¨ë“  ë©”ëª¨ë¦¬ ì˜ì—­ì— ì ‘ê·¼ ê°€ëŠ¥
- CPUì˜ ëª¨ë“  ëª…ë ¹ì–´ ì‚¬ìš© ê°€ëŠ¥
- ê°•ë ¥í•˜ì§€ë§Œ ìœ„í—˜í•œ í™˜ê²½
 

### ì‹œìŠ¤í…œ êµ¬ì¡° ê°œë…ë„

<pre>
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           ì• í”Œë¦¬ì¼€ì´ì…˜ ì˜ì—­                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚ â† ìœ ì € ëª¨ë“œ
â”‚  â”‚ê²Œì„í´ë¼  â”‚ â”‚ë¸Œë¼ìš°ì €   â”‚ â”‚í…ìŠ¤íŠ¸    â”‚    â”‚
â”‚  â”‚ì´ì–¸íŠ¸    â”‚ â”‚         â”‚ â”‚ì—ë””í„°    â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚ 
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              ì‹œìŠ¤í…œ ì½œ ì¸í„°í˜ì´ìŠ¤          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           ìš´ì˜ì²´ì œ ì»¤ë„ ì˜ì—­               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â† ì»¤ë„ ëª¨ë“œ
â”‚  â”‚  ìŠ¤ì¼€ì¤„ëŸ¬, ë©”ëª¨ë¦¬ê´€ë¦¬, íŒŒì¼ì‹œìŠ¤í…œ        â”‚ â”‚
â”‚  â”‚  ë„¤íŠ¸ì›Œí¬, ë””ë°”ì´ìŠ¤ ë“œë¼ì´ë²„            â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              í•˜ë“œì›¨ì–´ ì˜ì—­                 â”‚
â”‚    CPU, ë©”ëª¨ë¦¬, ë””ìŠ¤í¬, ë„¤íŠ¸ì›Œí¬            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</pre>
  

### ëª¨ë“œ ì „í™˜ ê³¼ì •
ìœ ì € ëª¨ë“œì—ì„œ ì»¤ë„ ëª¨ë“œë¡œ ì „í™˜ë˜ëŠ” ê²½ìš°ë“¤:
- **ì‹œìŠ¤í…œ ì½œ í˜¸ì¶œ**: íŒŒì¼ ì½ê¸°, ë„¤íŠ¸ì›Œí¬ í†µì‹  ë“±
- **í•˜ë“œì›¨ì–´ ì¸í„°ëŸ½íŠ¸**: í‚¤ë³´ë“œ ì…ë ¥, íƒ€ì´ë¨¸ ë“±
- **ì˜ˆì™¸ ë°œìƒ**: ë©”ëª¨ë¦¬ ì ‘ê·¼ ìœ„ë°˜, 0ìœ¼ë¡œ ë‚˜ëˆ„ê¸° ë“±



### ë©€í‹°ìŠ¤ë ˆë“œì™€ ëª¨ë“œ ì „í™˜

#### ìŠ¤ë ˆë“œ ìƒì„±ê³¼ ê´€ë¦¬
ë©€í‹°ìŠ¤ë ˆë“œ í”„ë¡œê·¸ë˜ë°ì—ì„œ ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ê³  ê´€ë¦¬í•˜ëŠ” ì‘ì—…ì€ ëŒ€ë¶€ë¶„ **ì»¤ë„ì˜ ë„ì›€**ì´ í•„ìš”í•˜ë‹¤. Windowsì—ì„œ ìŠ¤ë ˆë“œë¥¼ ë§Œë“¤ ë•Œ ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–¤ ì¼ì´ ë²Œì–´ì§€ëŠ”ì§€ ì‚´í´ë³´ì.

```cpp
// C++20 í‘œì¤€ ìŠ¤ë ˆë“œ ìƒì„±
#include <thread>
#include <iostream>

void worker_function(int id) {
    std::cout << "Worker " << id << " running in user mode\n";
    // ì´ í•¨ìˆ˜ëŠ” ìœ ì € ëª¨ë“œì—ì„œ ì‹¤í–‰ë¨
}

int main() {
    // ìŠ¤ë ˆë“œ ìƒì„± - ë‚´ë¶€ì ìœ¼ë¡œ ì»¤ë„ ëª¨ë“œ ì „í™˜ ë°œìƒ
    std::thread worker1(worker_function, 1);
    std::thread worker2(worker_function, 2);
    
    // ìŠ¤ë ˆë“œ ì¢…ë£Œ ëŒ€ê¸° - ì—­ì‹œ ì»¤ë„ ëª¨ë“œ ì „í™˜ ë°œìƒ  
    worker1.join();
    worker2.join();
    
    return 0;
}
```

ìœ„ ì½”ë“œì—ì„œ `std::thread` ìƒì„±ìì™€ `join()` í•¨ìˆ˜ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ Windows API(`CreateThread`, `WaitForSingleObject` ë“±)ë¥¼ í˜¸ì¶œí•˜ê³ , ì´ëŠ” ì‹œìŠ¤í…œ ì½œì„ í†µí•´ ì»¤ë„ ëª¨ë“œë¡œ ì „í™˜ëœë‹¤.
  

### ë™ê¸°í™” ê°ì²´ì™€ ëª¨ë“œ ì „í™˜
ë™ê¸°í™” ê°ì²´ë“¤ë„ ìœ ì € ëª¨ë“œì™€ ì»¤ë„ ëª¨ë“œì—ì„œ ë‹¤ë¥´ê²Œ ë™ì‘í•œë‹¤.

```cpp
#include <mutex>
#include <shared_mutex>
#include <atomic>
#include <thread>
#include <chrono>

class GameServer {
private:
    std::mutex user_data_mutex;           // ìœ ì € ëª¨ë“œ + ì»¤ë„ ëª¨ë“œ
    std::atomic<int> online_users{0};     // ìˆœìˆ˜ ìœ ì € ëª¨ë“œ
    std::shared_mutex config_mutex;       // ìœ ì € ëª¨ë“œ + ì»¤ë„ ëª¨ë“œ
    
public:
    // ê°€ë²¼ìš´ ì—°ì‚° - ì£¼ë¡œ ìœ ì € ëª¨ë“œì—ì„œ ì²˜ë¦¬
    void increment_online_users() {
        online_users.fetch_add(1, std::memory_order_relaxed);
        // atomic ì—°ì‚°ì€ CPU ìˆ˜ì¤€ì—ì„œ ì²˜ë¦¬ë˜ì–´ ë¹ ë¦„
    }
    
    // ë¬´ê±°ìš´ ì—°ì‚° - ê²½í•© ì‹œ ì»¤ë„ ëª¨ë“œ ì „í™˜
    void update_user_data(int user_id, const std::string& data) {
        std::lock_guard<std::mutex> lock(user_data_mutex);
        // ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ì´ë¯¸ ë½ì„ ì¡ê³  ìˆë‹¤ë©´
        // ì»¤ë„ ëª¨ë“œë¡œ ì „í™˜ë˜ì–´ ìŠ¤ë ˆë“œê°€ ë¸”ë¡ë¨
        
        // ì‹¤ì œ ë°ì´í„° ì—…ë°ì´íŠ¸ ë¡œì§
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }
    
    // ì½ê¸° ì „ìš© ì—°ì‚° - shared_mutex í™œìš©
    std::string read_config() {
        std::shared_lock<std::shared_mutex> lock(config_mutex);
        // ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ì½ê¸° ê°€ëŠ¥
        return "config_data";
    }
};
```


### ì‹¤ìš©ì ì¸ ì˜ˆì œ: ê²Œì„ ì„œë²„ íŒ¨í‚· ì²˜ë¦¬ê¸°
ì‹¤ì œ ê²Œì„ ì„œë²„ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” íŒ¨í‚· ì²˜ë¦¬ ì‹œìŠ¤í…œì„ ë§Œë“¤ì–´ë³´ì. ì´ ì˜ˆì œë¥¼ í†µí•´ ìœ ì € ëª¨ë“œì™€ ì»¤ë„ ëª¨ë“œì˜ ì°¨ì´ë¥¼ ì²´ê°í•  ìˆ˜ ìˆë‹¤.

```cpp
#include <iostream>
#include <thread>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <atomic>
#include <vector>
#include <chrono>
#include <functional>

// íŒ¨í‚· êµ¬ì¡°ì²´
struct Packet 
{
    int user_id;
    int packet_type;
    std::vector<char> data;
    
    Packet(int uid, int type, const std::vector<char>& d) 
        : user_id(uid), packet_type(type), data(d) {}
};

class PacketProcessor 
{
private:
    // ìœ ì € ëª¨ë“œì—ì„œ ì£¼ë¡œ ë™ì‘í•˜ëŠ” ë¶€ë¶„ë“¤
    std::atomic<bool> running{true};
    std::atomic<long long> processed_count{0};
    
    // ì»¤ë„ ëª¨ë“œ ì „í™˜ì´ í•„ìš”í•œ ë¶€ë¶„ë“¤
    std::queue<Packet> packet_queue;
    std::mutex queue_mutex;
    std::condition_variable queue_cv;
    
    // ì›Œì»¤ ìŠ¤ë ˆë“œë“¤
    std::vector<std::thread> workers;
    
public:
    PacketProcessor(int worker_count = 4) {
        // ì›Œì»¤ ìŠ¤ë ˆë“œë“¤ ìƒì„± (ì»¤ë„ ëª¨ë“œ ì „í™˜ ë°œìƒ)
        for (int i = 0; i < worker_count; ++i) {
            workers.emplace_back(&PacketProcessor::worker_thread, this, i);
        }
    }
    
    ~PacketProcessor() {
        stop();
    }
    
    // íŒ¨í‚· ì¶”ê°€ - ë¹ ë¥¸ ìœ ì € ëª¨ë“œ ì—°ì‚° + í•„ìš”ì‹œ ì»¤ë„ ëª¨ë“œ ì „í™˜
    void enqueue_packet(const Packet& packet) {
        {
            std::lock_guard<std::mutex> lock(queue_mutex);
            packet_queue.push(packet);
        }
        // ëŒ€ê¸° ì¤‘ì¸ ì›Œì»¤ ìŠ¤ë ˆë“œ ê¹¨ìš°ê¸° (ì»¤ë„ ëª¨ë“œ ì „í™˜)
        queue_cv.notify_one();
    }
    
    // í†µê³„ ì¡°íšŒ - ìˆœìˆ˜ ìœ ì € ëª¨ë“œ ì—°ì‚° (ë§¤ìš° ë¹ ë¦„)
    long long get_processed_count() const {
        return processed_count.load(std::memory_order_relaxed);
    }
    
    void stop() {
        running.store(false);
        queue_cv.notify_all();
        
        for (auto& worker : workers) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }
    
private:
    void worker_thread(int worker_id) {
        std::cout << "Worker " << worker_id << " started\n";
        
        while (running.load()) {
            Packet packet{0, 0, {}};
            bool has_packet = false;
            
            // íŒ¨í‚· íì—ì„œ ê°€ì ¸ì˜¤ê¸°
            {
                std::unique_lock<std::mutex> lock(queue_mutex);
                
                // íŒ¨í‚·ì´ ì—†ìœ¼ë©´ ëŒ€ê¸° (ì»¤ë„ ëª¨ë“œë¡œ ì „í™˜ë˜ì–´ ë¸”ë¡)
                queue_cv.wait(lock, [this] { 
                    return !packet_queue.empty() || !running.load(); 
                });
                
                if (!packet_queue.empty()) {
                    packet = packet_queue.front();
                    packet_queue.pop();
                    has_packet = true;
                }
            }
            
            if (has_packet) {
                // íŒ¨í‚· ì²˜ë¦¬ (ìœ ì € ëª¨ë“œì—ì„œ ì‹¤í–‰)
                process_packet(packet);
                
                // ì²˜ë¦¬ ì™„ë£Œ ì¹´ìš´íŠ¸ ì¦ê°€ (ìœ ì € ëª¨ë“œ, ë§¤ìš° ë¹ ë¦„)
                processed_count.fetch_add(1, std::memory_order_relaxed);
            }
        }
        
        std::cout << "Worker " << worker_id << " terminated\n";
    }
    
    void process_packet(const Packet& packet) {
        // ì‹¤ì œ íŒ¨í‚· ì²˜ë¦¬ ë¡œì§ (ìœ ì € ëª¨ë“œì—ì„œ ì‹¤í–‰)
        switch (packet.packet_type) {
            case 1: // ì´ë™ íŒ¨í‚·
                // í”Œë ˆì´ì–´ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                break;
            case 2: // ì±„íŒ… íŒ¨í‚·  
                // ì±„íŒ… ë©”ì‹œì§€ ì²˜ë¦¬
                break;
            case 3: // ì „íˆ¬ íŒ¨í‚·
                // ì „íˆ¬ ê³„ì‚°
                break;
        }
        
        // ì²˜ë¦¬ ì‹œê°„ ì‹œë®¬ë ˆì´ì…˜
        std::this_thread::sleep_for(std::chrono::microseconds(100));
    }
};

// ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ í•¨ìˆ˜
void performance_test() {
    PacketProcessor processor(4);
    
    // íŒ¨í‚· ìƒì„± ìŠ¤ë ˆë“œ
    std::thread packet_generator([&processor] {
        for (int i = 0; i < 10000; ++i) {
            std::vector<char> data(100, 'A' + (i % 26));
            Packet packet(i % 100, i % 3 + 1, data);
            processor.enqueue_packet(packet);
            
            // íŒ¨í‚· ìƒì„± ì†ë„ ì¡°ì ˆ
            std::this_thread::sleep_for(std::chrono::microseconds(50));
        }
    });
    
    // í†µê³„ ì¶œë ¥ ìŠ¤ë ˆë“œ (ìœ ì € ëª¨ë“œ ì—°ì‚° í™œìš©)
    std::thread stats_printer([&processor] {
        auto start_time = std::chrono::steady_clock::now();
        
        for (int i = 0; i < 10; ++i) {
            std::this_thread::sleep_for(std::chrono::seconds(1));
            
            auto current_time = std::chrono::steady_clock::now();
            auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(
                current_time - start_time).count();
            
            long long processed = processor.get_processed_count();
            std::cout << "Time: " << elapsed << "s, Processed: " << processed 
                      << " packets, Rate: " << (processed / elapsed) << " pps\n";
        }
    });
    
    packet_generator.join();
    stats_printer.join();
}

int main() {
    std::cout << "=== ê²Œì„ ì„œë²„ íŒ¨í‚· ì²˜ë¦¬ê¸° í…ŒìŠ¤íŠ¸ ===\n";
    performance_test();
    return 0;
}
```  

<pre>
ë§¤ë²ˆ queue_cv.notify_one(); ì„ í˜¸ì¶œí•˜ëŠ” ê²ƒì€ ë¬¸ì œê°€ ì—†ì„ê¹Œ?

**ì „í˜€ ë¬¸ì œê°€ ì—†ìœ¼ë©° ì˜¤íˆë ¤ ì§€ê¸ˆì²˜ëŸ¼ ë§¤ë²ˆ ê¹¨ìš°ëŠ” ê²ƒì´ ê°€ì¥ ì•ˆì „í•˜ê³  í‘œì¤€ì ì¸ ë°©ë²•**ì´ë‹¤. ğŸ‘

1. 'ì‹ í˜¸(Notify)'ëŠ” ì ìëŠ” ìŠ¤ë ˆë“œì—ê²Œë§Œ ì˜ë¯¸ê°€ ìˆë‹¤

`queue_cv.notify_one()`ì€ ë¹„ìœ í•˜ìë©´ 'í˜¹ì‹œ ê¸°ë‹¤ë¦¬ëŠ” ì‚¬ëŒ ìˆìœ¼ë©´ ì¼ì–´ë‚˜ì„¸ìš”!'ë¼ê³  ì™¸ì¹˜ëŠ” ê²ƒê³¼ ê°™ë‹¤.

- ì†Œë¹„ì ìŠ¤ë ˆë“œê°€ ìê³  ìˆì„ ë•Œ (wait ìƒíƒœì¼ ë•Œ): ì´ ì™¸ì¹¨ì„ ë“£ê³  ì ì—ì„œ ê¹¨ì–´ë‚˜ ì‘ì—…ì„ í™•ì¸í•œë‹¤. 
- ì†Œë¹„ì ìŠ¤ë ˆë“œê°€ ì•ˆ ìê³  ìˆì„ ë•Œ (ì—´ì‹¬íˆ ì¼í•˜ëŠ” ì¤‘ì¼ ë•Œ): ì™¸ì¹¨ì€ ê·¸ëƒ¥ í—ˆê³µì— ì‚¬ë¼ì§ˆ ë¿, ì¼í•˜ê³  ìˆëŠ” ìŠ¤ë ˆë“œì—ê²ŒëŠ” ì•„ë¬´ëŸ° ì˜í–¥ì„ ì£¼ì§€ ì•ŠëŠ”ë‹¤. ì´ ì‹ í˜¸ë¥¼ ë°›ëŠ”ë‹¤ê³  í•´ì„œ ì‘ì—…ì´ ì¤‘ë‹¨ë˜ê±°ë‚˜ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ì§€ ì•ŠëŠ”ë‹¤.

ì¦‰, ë¶ˆí•„ìš”í•œ í˜¸ì¶œì˜ ë¹„ìš©ì€ ê±°ì˜ 0ì— ê°€ê¹ë‹¤. ìš´ì˜ì²´ì œ ì»¤ë„ì—ì„œ ì´ ì‹ í˜¸ëŠ” ë§¤ìš° ê°€ë³ê²Œ ì²˜ë¦¬ë˜ë¯€ë¡œ ì„±ëŠ¥ì— ë¯¸ì¹˜ëŠ” ì˜í–¥ë„ ë¯¸ë¯¸í•˜ë‹¤.


2. ë§¤ë²ˆ ê¹¨ìš°ì§€ 'ì•Šìœ¼ë ¤ê³ ' í•˜ë©´ í›¨ì”¬ ë” ìœ„í—˜í•œ ë¬¸ì œê°€ ë°œìƒí•œë‹¤
ì´ê²ƒì´ í•µì‹¬ì ì¸ ì´ìœ ì´ë‹¤. ë§Œì•½ ìš°ë¦¬ê°€ "ì†Œë¹„ìê°€ ì˜ ë•Œë§Œ ê¹¨ì›Œì•¼ì§€"ë¼ëŠ” ìƒê°ìœ¼ë¡œ ì½”ë“œë¥¼ ìˆ˜ì •í•˜ë ¤ í•˜ë©´, **ê²½ìŸ ìƒíƒœ(Race Condition)**ë¼ëŠ” ì‹¬ê°í•œ ë²„ê·¸ê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤.

âš ï¸ ìœ„í—˜í•œ ì‹œë‚˜ë¦¬ì˜¤
ë§Œì•½ ì•„ë˜ì™€ ê°™ì´ 'ìŠ¤ìŠ¤ë¡œ ë˜‘ë˜‘í•˜ê²Œ' ë™ì‘í•˜ëŠ” ì½”ë“œë¥¼ ìƒìƒí•´ ë³´ê² ë‹¤.

1.  ìƒì‚°ì ìŠ¤ë ˆë“œ: (íŒ¨í‚·ì„ ë„£ê¸° ì „) "ì†Œë¹„ìê°€ ìê³  ìˆë‚˜?" í™•ì¸í•œë‹¤. -> "ì•„ë‹ˆ, ì§€ê¸ˆ ì¼í•˜ê³  ìˆë„¤."
2.  ì´ë•Œ ìš´ì˜ì²´ì œê°€ CPU ì œì–´ê¶Œì„ ì†Œë¹„ì ìŠ¤ë ˆë“œë¡œ ë„˜ê¸´ë‹¤.
3.  ì†Œë¹„ì ìŠ¤ë ˆë“œ: í•˜ë˜ ì¼ì„ ë§ˆì € ëë‚´ê³  íë¥¼ í™•ì¸í•œë‹¤. -> "ì–´, íê°€ ë¹„ì—ˆë„¤. ì´ì œ ìì•¼ê² ë‹¤." í•˜ê³  `queue_cv.wait()`ë¥¼ í˜¸ì¶œí•˜ì—¬ ì ì´ ë“ ë‹¤.
4.  ë‹¤ì‹œ CPU ì œì–´ê¶Œì´ ìƒì‚°ì ìŠ¤ë ˆë“œë¡œ ëŒì•„ì˜¨ë‹¤.
5.  ìƒì‚°ì ìŠ¤ë ˆë“œ: (1ë²ˆì—ì„œ ì†Œë¹„ìê°€ ê¹¨ì–´ìˆë‹¤ê³  íŒë‹¨í–ˆìœ¼ë¯€ë¡œ) "ê¹¨ì–´ìˆìœ¼ë‹ˆ ê¹¨ìš¸ í•„ìš” ì—†ê² ì§€?" ìƒê°í•˜ê³  íŒ¨í‚·ë§Œ íì— ë„£ê³  `notify_one()`ì„ í˜¸ì¶œí•˜ì§€ ì•ŠëŠ”ë‹¤.

ê²°ê³¼: íì—ëŠ” ì²˜ë¦¬í•´ì•¼ í•  íŒ¨í‚·ì´ ë“¤ì–´ì™”ì§€ë§Œ, ì†Œë¹„ì ìŠ¤ë ˆë“œëŠ” ê·¸ ì‚¬ì‹¤ì„ ëª¨ë¥¸ ì±„ ì˜ì›íˆ ì ë“œëŠ” 'êµì°© ìƒíƒœ(Deadlock)'**ì— ë¹ ì§€ê²Œ ëœë‹¤.


âœ… ê²°ë¡ 
ì´ëŸ¬í•œ ê²½ìŸ ìƒíƒœ ë¬¸ì œë¥¼ ì›ì²œì ìœ¼ë¡œ ì°¨ë‹¨í•˜ê¸° ìœ„í•´ ë™ê¸°í™” ë¡œì§ì€ í•­ìƒ ë‹¨ìˆœí•˜ê³  ë³´ìˆ˜ì ìœ¼ë¡œ ì„¤ê³„í•œë‹¤.

> "ìƒíƒœë¥¼ í™•ì¸í•˜ê³  í–‰ë™í•˜ì§€ ë§ê³ , ê·¸ëƒ¥ í–‰ë™í•˜ë¼."

ì¦‰, "ì†Œë¹„ìê°€ ìê³  ìˆëŠ”ì§€ í™•ì¸í•˜ê³  ê¹¨ìš´ë‹¤"ê°€ ì•„ë‹ˆë¼ "ì¼ë‹¨ íì— ë°ì´í„°ê°€ ì¶”ê°€ë˜ì—ˆìœ¼ë‹ˆ, í˜¹ì‹œ ìê³  ìˆì„ì§€ë„ ëª¨ë¥´ëŠ” ìŠ¤ë ˆë“œë¥¼ ë¬´ì¡°ê±´ ê¹¨ìš´ë‹¤"ëŠ” í˜„ì¬ì˜ ë°©ì‹ì´ ê°€ì¥ ê°„ë‹¨í•˜ê³ , ì•ˆì „í•˜ë©°, íš¨ìœ¨ì ì¸ ìµœì„ ì˜ ë°©ë²•ì´ë‹¤.
</pre>
  

### ëª¨ë“œ ì „í™˜ì˜ ì„±ëŠ¥ ì˜í–¥

#### ì„±ëŠ¥ ì¸¡ì • ì˜ˆì œ
ìœ ì € ëª¨ë“œì™€ ì»¤ë„ ëª¨ë“œ ì „í™˜ì˜ ì„±ëŠ¥ ì°¨ì´ë¥¼ ì§ì ‘ ì¸¡ì •í•´ë³´ì.  
  
`PerformanceComparison`    

```cpp
#include <chrono>
#include <iostream>
#include <atomic>
#include <mutex>
#include <thread>

class PerformanceComparison {
private:
    std::atomic<long long> atomic_counter{0};
    long long normal_counter = 0;
    std::mutex counter_mutex;
    
public:
    // ìˆœìˆ˜ ìœ ì € ëª¨ë“œ ì—°ì‚° (ë§¤ìš° ë¹ ë¦„)
    void test_atomic_operations(int iterations) {
        auto start = std::chrono::high_resolution_clock::now();
        
        for (int i = 0; i < iterations; ++i) {
            atomic_counter.fetch_add(1, std::memory_order_relaxed);
        }
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
            end - start).count();
            
        std::cout << "Atomic operations: " << duration 
                  << " microseconds for " << iterations << " operations\n";
    }
    
    // ì»¤ë„ ëª¨ë“œ ì „í™˜ì´ ë°œìƒí•  ìˆ˜ ìˆëŠ” ì—°ì‚° (ìƒëŒ€ì ìœ¼ë¡œ ëŠë¦¼)
    void test_mutex_operations(int iterations) {
        auto start = std::chrono::high_resolution_clock::now();
        
        for (int i = 0; i < iterations; ++i) {
            std::lock_guard<std::mutex> lock(counter_mutex);
            normal_counter++;
        }
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
            end - start).count();
            
        std::cout << "Mutex operations: " << duration 
                  << " microseconds for " << iterations << " operations\n";
    }
    
    // ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œì˜ ê²½í•© í…ŒìŠ¤íŠ¸
    void test_contention(int thread_count, int iterations_per_thread) {
        std::cout << "\n=== ë©€í‹°ìŠ¤ë ˆë“œ ê²½í•© í…ŒìŠ¤íŠ¸ ===\n";
        
        // Atomic í…ŒìŠ¤íŠ¸
        atomic_counter.store(0);
        auto start = std::chrono::high_resolution_clock::now();
        
        std::vector<std::thread> atomic_threads;
        for (int i = 0; i < thread_count; ++i) {
            atomic_threads.emplace_back([this, iterations_per_thread] {
                for (int j = 0; j < iterations_per_thread; ++j) {
                    atomic_counter.fetch_add(1, std::memory_order_relaxed);
                }
            });
        }
        
        for (auto& t : atomic_threads) {
            t.join();
        }
        
        auto end = std::chrono::high_resolution_clock::now();
        auto atomic_duration = std::chrono::duration_cast<std::chrono::microseconds>(
            end - start).count();
        
        // Mutex í…ŒìŠ¤íŠ¸
        normal_counter = 0;
        start = std::chrono::high_resolution_clock::now();
        
        std::vector<std::thread> mutex_threads;
        for (int i = 0; i < thread_count; ++i) {
            mutex_threads.emplace_back([this, iterations_per_thread] {
                for (int j = 0; j < iterations_per_thread; ++j) {
                    std::lock_guard<std::mutex> lock(counter_mutex);
                    normal_counter++;
                }
            });
        }
        
        for (auto& t : mutex_threads) {
            t.join();
        }
        
        end = std::chrono::high_resolution_clock::now();
        auto mutex_duration = std::chrono::duration_cast<std::chrono::microseconds>(
            end - start).count();
        
        std::cout << "Atomic (" << thread_count << " threads): " 
                  << atomic_duration << " microseconds\n";
        std::cout << "Mutex (" << thread_count << " threads): " 
                  << mutex_duration << " microseconds\n";
        std::cout << "Performance ratio: " 
                  << (static_cast<double>(mutex_duration) / atomic_duration) 
                  << "x slower with mutex\n";
    }
};

void run_performance_tests() 
{
    PerformanceComparison perf;
    
    std::cout << "=== ë‹¨ì¼ ìŠ¤ë ˆë“œ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ===\n";
    perf.test_atomic_operations(1000000);
    perf.test_mutex_operations(1000000);
    
    perf.test_contention(2, 500000);
    perf.test_contention(4, 250000);
    perf.test_contention(8, 125000);
}
```
  

### ë¬¸ì œ 1: ê¸°ë³¸ ê°œë… í™•ì¸
ë‹¤ìŒ ì½”ë“œì—ì„œ ìœ ì € ëª¨ë“œì™€ ì»¤ë„ ëª¨ë“œ ì „í™˜ì´ ë°œìƒí•˜ëŠ” ì§€ì ì„ ì°¾ì•„ë³´ì.

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <fstream>

std::mutex file_mutex;
int global_counter = 0;

void worker_function(int id) {
    // A ì§€ì : ë³€ìˆ˜ í• ë‹¹
    int local_var = id * 2;
    
    // B ì§€ì : ë®¤í…ìŠ¤ ë½ íšë“
    std::lock_guard<std::mutex> lock(file_mutex);
    
    // C ì§€ì : ì „ì—­ ë³€ìˆ˜ ìˆ˜ì •  
    global_counter++;
    
    // D ì§€ì : íŒŒì¼ ì“°ê¸°
    std::ofstream file("output.txt", std::ios::app);
    file << "Worker " << id << " executed\n";
}

int main() {
    // E ì§€ì : ìŠ¤ë ˆë“œ ìƒì„±
    std::thread t1(worker_function, 1);
    std::thread t2(worker_function, 2);
    
    // F ì§€ì : ìŠ¤ë ˆë“œ ì¢…ë£Œ ëŒ€ê¸°
    t1.join();
    t2.join();
    
    return 0;
}
```

<details open>
<summary>ì •ë‹µê³¼ ì„¤ëª…:</summary>

- A ì§€ì : ìœ ì € ëª¨ë“œ (ë‹¨ìˆœ ë³€ìˆ˜ í• ë‹¹)
- B ì§€ì : ê²½í•© ì‹œ ì»¤ë„ ëª¨ë“œ ì „í™˜ (ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ë½ì„ ì¡ê³  ìˆë‹¤ë©´)
- C ì§€ì : ìœ ì € ëª¨ë“œ (ë©”ëª¨ë¦¬ ì ‘ê·¼)
- D ì§€ì : ì»¤ë„ ëª¨ë“œ ì „í™˜ (íŒŒì¼ ì‹œìŠ¤í…œ ì ‘ê·¼)
- E ì§€ì : ì»¤ë„ ëª¨ë“œ ì „í™˜ (ìŠ¤ë ˆë“œ ìƒì„±)
- F ì§€ì : ì»¤ë„ ëª¨ë“œ ì „í™˜ (ìŠ¤ë ˆë“œ ì¢…ë£Œ ëŒ€ê¸°)


#### join()ì´ ì»¤ë„ëª¨ë“œë¡œ ì „í™˜ë˜ëŠ” ì´ìœ 

**1. ì‹œìŠ¤í…œ ì½œ í•„ìš”ì„±**
```cpp
t1.join();  // ì´ í•œ ì¤„ì´ ë‚´ë¶€ì ìœ¼ë¡œ ì»¤ë„ ì‹œìŠ¤í…œ ì½œì„ í˜¸ì¶œ
```

**2. ë‚´ë¶€ ë™ì‘ ê³¼ì •**
```
ì‚¬ìš©ì ëª¨ë“œ â†’ ì»¤ë„ ëª¨ë“œ ì „í™˜
â”œâ”€â”€ WaitForSingleObject() ì‹œìŠ¤í…œ ì½œ í˜¸ì¶œ
â”œâ”€â”€ ì»¤ë„ì—ì„œ ìŠ¤ë ˆë“œ ìƒíƒœ í™•ì¸
â”œâ”€â”€ ìŠ¤ë ˆë“œê°€ ì•„ì§ ì‹¤í–‰ ì¤‘ì´ë©´ í˜„ì¬ ìŠ¤ë ˆë“œë¥¼ ëŒ€ê¸° ìƒíƒœë¡œ ë³€ê²½
â””â”€â”€ ëŒ€ìƒ ìŠ¤ë ˆë“œ ì¢…ë£Œ ì‹œ ëŒ€ê¸° ì¤‘ì¸ ìŠ¤ë ˆë“œë¥¼ ê¹¨ì›€
```

#### í”Œë«í¼ë³„ êµ¬í˜„

**Windowsì—ì„œì˜ join() ë‚´ë¶€**
```cpp
// std::thread::join() ë‚´ë¶€ êµ¬í˜„ (ê°„ì†Œí™”)
void join() {
    if (_Thr._Id != id{}) {
        // ì—¬ê¸°ì„œ ì»¤ë„ëª¨ë“œë¡œ ì „í™˜!
        WaitForSingleObject(_Thr._Hnd, INFINITE);
        _Thr = {};
    }
}
```

**Linuxì—ì„œì˜ join() ë‚´ë¶€**
```cpp
// pthread_join() ì‹œìŠ¤í…œ ì½œ í˜¸ì¶œ
int pthread_join(pthread_t thread, void **retval) {
    // ì»¤ë„ëª¨ë“œ ì „í™˜í•˜ì—¬ ìŠ¤ë ˆë“œ ìƒíƒœ í™•ì¸
    return syscall(SYS_futex, ...);
}
```

#### ì™œ ì»¤ë„ëª¨ë“œ ì „í™˜ì´ í•„ìš”í•œê°€?

1. **ìŠ¤ë ˆë“œ ìƒíƒœ í™•ì¸**: ì»¤ë„ë§Œì´ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì˜ ì‹¤í–‰ ìƒíƒœë¥¼ ì•Œ ìˆ˜ ìˆìŒ
2. **ë™ê¸°í™” ë©”ì»¤ë‹ˆì¦˜**: ìŠ¤ë ˆë“œ ê°„ ë™ê¸°í™”ëŠ” ì»¤ë„ì˜ ìŠ¤ì¼€ì¤„ëŸ¬ê°€ ê´€ë¦¬
3. **ë¸”ë¡œí‚¹ ì—°ì‚°**: ëŒ€ìƒ ìŠ¤ë ˆë“œê°€ ì¢…ë£Œë  ë•Œê¹Œì§€ í˜„ì¬ ìŠ¤ë ˆë“œë¥¼ ëŒ€ê¸° ìƒíƒœë¡œ ë³€ê²½

</details open>  
     
  
### ìš”ì•½
1. **ìœ ì € ëª¨ë“œ**ëŠ” ì•ˆì „í•˜ì§€ë§Œ ì œí•œì ì´ê³ , **ì»¤ë„ ëª¨ë“œ**ëŠ” ê°•ë ¥í•˜ì§€ë§Œ ì „í™˜ ë¹„ìš©ì´ ìˆì–´
2. **Atomic ì—°ì‚°**ì€ ì£¼ë¡œ ìœ ì € ëª¨ë“œì—ì„œ ì²˜ë¦¬ë˜ì–´ ë¹ ë¥´ê³ , **ë®¤í…ìŠ¤ ê²½í•©**ì€ ì»¤ë„ ëª¨ë“œ ì „í™˜ì„ ìœ ë°œí•´
3. **ì‹œìŠ¤í…œ ì½œ**ê³¼ **I/O ì‘ì—…**ì€ í•­ìƒ ì»¤ë„ ëª¨ë“œ ì „í™˜ì„ í•„ìš”ë¡œ í•´
4. ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•´ì„œëŠ” ë¶ˆí•„ìš”í•œ **ëª¨ë“œ ì „í™˜ì„ ìµœì†Œí™”**í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•´
  

-----  
  
<br>    
  

## í”„ë¡œì„¸ìŠ¤ì™€ ìŠ¤ë ˆë“œ

### í”„ë¡œì„¸ìŠ¤ (Process)
í”„ë¡œì„¸ìŠ¤ëŠ” ì‹¤í–‰ ì¤‘ì¸ í”„ë¡œê·¸ë¨ì˜ ì¸ìŠ¤í„´ìŠ¤ë‹¤. ê° í”„ë¡œì„¸ìŠ¤ëŠ” ë…ë¦½ëœ ë©”ëª¨ë¦¬ ê³µê°„ì„ ê°€ì§„ë‹¤.

**í”„ë¡œì„¸ìŠ¤ì˜ íŠ¹ì§•:**
- ë…ë¦½ëœ ê°€ìƒ ë©”ëª¨ë¦¬ ê³µê°„
- ê³ ìœ í•œ í”„ë¡œì„¸ìŠ¤ ID (PID)
- ìµœì†Œ í•˜ë‚˜ì˜ ìŠ¤ë ˆë“œ(ë©”ì¸ ìŠ¤ë ˆë“œ) í¬í•¨
- í”„ë¡œì„¸ìŠ¤ ê°„ ì§ì ‘ì ì¸ ë©”ëª¨ë¦¬ ê³µìœ  ë¶ˆê°€  

![](./images/001.png)   
  

### ìŠ¤ë ˆë“œ (Thread)
ìŠ¤ë ˆë“œëŠ” í”„ë¡œì„¸ìŠ¤ ë‚´ì—ì„œ ì‹¤í–‰ë˜ëŠ” ì‹¤í–‰ ë‹¨ìœ„ë‹¤. ê°™ì€ í”„ë¡œì„¸ìŠ¤ì˜ ìŠ¤ë ˆë“œë“¤ì€ ë©”ëª¨ë¦¬ ê³µê°„ì„ ê³µìœ í•œë‹¤.

**ìŠ¤ë ˆë“œì˜ íŠ¹ì§•:**
- í”„ë¡œì„¸ìŠ¤ì˜ ë©”ëª¨ë¦¬ ê³µê°„ ê³µìœ 
- ê³ ìœ í•œ ìŠ¤íƒê³¼ ë ˆì§€ìŠ¤í„° ì„¸íŠ¸
- ë¹ ë¥¸ ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­
- ìŠ¤ë ˆë“œ ê°„ ë°ì´í„° ê³µìœ  ê°€ëŠ¥

![](./images/002.png)   
     

ì˜ˆì œ ì½”ë“œ: ìŠ¤ë ˆë“œë¥¼ ì‚¬ìš©í•œ í”„ë¡œê·¸ë¨     
```cpp
#include <iostream>
#include <vector>
#include <windows.h> // Win32 APIë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•œ í•„ìˆ˜ í—¤ë”

// ì „ì—­ ë³€ìˆ˜ (ëª¨ë“  ìŠ¤ë ˆë“œê°€ ê³µìœ )
int sharedCounter = 0;

// ìŠ¤ë ˆë“œì— ì¸ìë¥¼ ì „ë‹¬í•˜ê¸° ìœ„í•œ êµ¬ì¡°ì²´
struct ThreadData {
    int threadId;
    int iterations;
};

// Win32 API ìŠ¤ë ˆë“œ í•¨ìˆ˜ í˜•ì‹: DWORD WINAPI FunctionName(LPVOID lpParam)
DWORD WINAPI incrementCounter(LPVOID lpParam) {
    // void í¬ì¸í„°(lpParam)ë¥¼ ì›ë˜ì˜ êµ¬ì¡°ì²´ í¬ì¸í„°ë¡œ ë³€í™˜
    ThreadData* data = static_cast<ThreadData*>(lpParam);

    for (int i = 0; i < data->iterations; ++i) {
        sharedCounter++;
        // Win32 APIì˜ Sleep í•¨ìˆ˜ ì‚¬ìš© (ë°€ë¦¬ì´ˆ ë‹¨ìœ„)
        Sleep(1);
    }

    // std::coutì€ ìŠ¤ë ˆë“œ ì•ˆì „í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ì¶œë ¥ì´ ì„ì¼ ìˆ˜ ìˆìŒ
    // ì—¬ê¸°ì„œëŠ” ê°„ë‹¨í•œ ì˜ˆì‹œë¡œ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.
    std::cout << "ìŠ¤ë ˆë“œ " << data->threadId << " ì™„ë£Œ" << std::endl;

    return 0; // ìŠ¤ë ˆë“œ í•¨ìˆ˜ëŠ” DWORD ê°’ì„ ë°˜í™˜í•´ì•¼ í•¨
}

void demonstrateWin32Threads() {
    const int numThreads = 4;
    const int iterations = 1000;

    // ìŠ¤ë ˆë“œ í•¸ë“¤ì„ ì €ì¥í•  ë²¡í„°
    std::vector<HANDLE> threadHandles(numThreads);
    // ìŠ¤ë ˆë“œì— ì „ë‹¬í•  ì¸ìë“¤ì„ ì €ì¥í•  ë²¡í„° (ì¤‘ìš”: ìŠ¤ë ˆë“œê°€ ì‹¤í–‰ë˜ëŠ” ë™ì•ˆ ë©”ëª¨ë¦¬ì— ìœ ì§€ë˜ì–´ì•¼ í•¨)
    std::vector<ThreadData> threadArgs(numThreads);

    std::cout << "Win32 API ìŠ¤ë ˆë“œ ìƒì„± ì‹œì‘..." << std::endl;

    // ì—¬ëŸ¬ ìŠ¤ë ˆë“œ ìƒì„±
    for (int i = 0; i < numThreads; ++i) {
        // ìŠ¤ë ˆë“œì— ì „ë‹¬í•  ë°ì´í„° ì„¤ì •
        threadArgs[i] = { i, iterations };

        // CreateThreadë¡œ ìŠ¤ë ˆë“œ ìƒì„±
        threadHandles[i] = CreateThread(
            NULL,              // ê¸°ë³¸ ë³´ì•ˆ ì†ì„±
            0,                 // ê¸°ë³¸ ìŠ¤íƒ í¬ê¸°
            incrementCounter,  // ìŠ¤ë ˆë“œê°€ ì‹¤í–‰í•  í•¨ìˆ˜
            &threadArgs[i],    // í•¨ìˆ˜ì— ì „ë‹¬í•  ì¸ì
            0,                 // ì¦‰ì‹œ ì‹¤í–‰
            NULL               // ìŠ¤ë ˆë“œ IDëŠ” í•„ìš” ì—†ìŒ
        );
    }

    // ëª¨ë“  ìŠ¤ë ˆë“œê°€ ì™„ë£Œë  ë•Œê¹Œì§€ ëŒ€ê¸° (std::thread::joinê³¼ ìœ ì‚¬)
    WaitForMultipleObjects(numThreads, threadHandles.data(), TRUE, INFINITE);

    std::cout << "ëª¨ë“  ìŠ¤ë ˆë“œ ì‘ì—… ì™„ë£Œ." << std::endl;

    // ì‚¬ìš©ì´ ëë‚œ ìŠ¤ë ˆë“œ í•¸ë“¤ ì •ë¦¬
    for (HANDLE handle : threadHandles) {
        CloseHandle(handle);
    }

    // ê²°ê³¼ ì¶œë ¥
    std::cout << "ìµœì¢… ì¹´ìš´í„° ê°’: " << sharedCounter << std::endl;
    std::cout << "ì˜ˆìƒ ê°’: " << numThreads * iterations << std::endl;
}

// í”„ë¡œê·¸ë¨ ì‹œì‘ì 
int main() 
{
    demonstrateWin32Threads();
    return 0;
}
```

### í”„ë¡œì„¸ìŠ¤ vs ìŠ¤ë ˆë“œ ë¹„êµ
![](./images/003.png)   
![](./images/004.png)   
![](./images/005.png)   
![](./images/006.png)   
  


### ë©€í‹°í”„ë¡œì„¸ìŠ¤ vs ë©€í‹°ìŠ¤ë ˆë“œ ì‚¬ìš© ì‹œë‚˜ë¦¬ì˜¤

#### ë©€í‹°í”„ë¡œì„¸ìŠ¤ê°€ ì í•©í•œ ê²½ìš°
**ì¥ì :**
- ë†’ì€ ì•ˆì •ì„± (í”„ë¡œì„¸ìŠ¤ ê°„ ê²©ë¦¬)
- í™•ì¥ì„± (ì—¬ëŸ¬ ë¨¸ì‹ ì— ë¶„ì‚° ê°€ëŠ¥)
- ë³´ì•ˆì„± (ê¶Œí•œ ë¶„ë¦¬ ê°€ëŠ¥)

**ì‚¬ìš© ì˜ˆì‹œ:**
```cpp
// ê²Œì„ ì„œë²„ ì•„í‚¤í…ì²˜ ì˜ˆì‹œ
// ë§ˆìŠ¤í„° í”„ë¡œì„¸ìŠ¤ + ì—¬ëŸ¬ ì›Œì»¤ í”„ë¡œì„¸ìŠ¤

#include <windows.h>
#include <iostream>
#include <string>

class GameServerManager 
{
public:
    void startGameServers(int serverCount) 
    {
        for (int i = 0; i < serverCount; ++i) 
        {
            std::string cmdLine = "GameWorker.exe " + std::to_string(i);
            
            STARTUPINFO si = {0};
            PROCESS_INFORMATION pi = {0};
            si.cb = sizeof(si);
            
            if (CreateProcess(NULL, (LPSTR)cmdLine.c_str(), 
                            NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) 
            {
                std::cout << "ê²Œì„ ì„œë²„ " << i << " ì‹œì‘ë¨ (PID: " 
                         << pi.dwProcessId << ")" << std::endl;
                CloseHandle(pi.hThread);
                CloseHandle(pi.hProcess);
            }
        }
    }
};
```
  
#### ë©€í‹°ìŠ¤ë ˆë“œê°€ ì í•©í•œ ê²½ìš°
**ì¥ì :**
- ë¹ ë¥¸ ë°ì´í„° ê³µìœ 
- ë‚®ì€ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰
- ë¹ ë¥¸ ìƒì„±/ì œê±°

**ì‚¬ìš© ì˜ˆì‹œ:**
```cpp
// ê²Œì„ ì„œë²„ ë‚´ë¶€ ë©€í‹°ìŠ¤ë ˆë“œ ì²˜ë¦¬
#include <thread>
#include <queue>
#include <mutex>
#include <condition_variable>

class GameServer 
{
private:
    std::queue<std::string> messageQueue;
    std::mutex queueMutex;
    std::condition_variable cv;
    bool running = true;

public:
    void networkThread() 
    {
        // ë„¤íŠ¸ì›Œí¬ íŒ¨í‚· ìˆ˜ì‹  ìŠ¤ë ˆë“œ
        while (running) 
        {
            // íŒ¨í‚· ìˆ˜ì‹  ì‹œë®¬ë ˆì´ì…˜
            std::string packet = receivePacket();
            
            {
                std::lock_guard<std::mutex> lock(queueMutex);
                messageQueue.push(packet);
            }
            cv.notify_one();
        }
    }
    
    void gameLogicThread() 
    {
        // ê²Œì„ ë¡œì§ ì²˜ë¦¬ ìŠ¤ë ˆë“œ
        while (running) {
            std::unique_lock<std::mutex> lock(queueMutex);
            cv.wait(lock, [this] { return !messageQueue.empty() || !running; });
            
            if (!running) break;
            
            std::string message = messageQueue.front();
            messageQueue.pop();
            lock.unlock();
            
            processGameLogic(message);
        }
    }
    
private:
    std::string receivePacket() 
    {
        // ë„¤íŠ¸ì›Œí¬ íŒ¨í‚· ìˆ˜ì‹  ì‹œë®¬ë ˆì´ì…˜
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
        return "íŒ¨í‚· ë°ì´í„°";
    }
    
    void processGameLogic(const std::string& message) 
    {
        // ê²Œì„ ë¡œì§ ì²˜ë¦¬
        std::this_thread::sleep_for(std::chrono::milliseconds(5));
    }
};
```
  

### ì‹¤ìŠµ 1: Task Managerë¥¼ í†µí•œ í”„ë¡œì„¸ìŠ¤/ìŠ¤ë ˆë“œ ê´€ì°° 

#### 1.1 ì¤€ë¹„ ì‘ì—…
1. `Ctrl + Shift + Esc`ë¡œ Task Manager ì‹¤í–‰
2. "ìì„¸íˆ" íƒ­ í´ë¦­
3. ì—´ í—¤ë”ì—ì„œ ìš°í´ë¦­ â†’ "ì—´ ì„ íƒ"ì—ì„œ "ìŠ¤ë ˆë“œ" ì²´í¬  
  
![](./images/021.png)   
![](./images/022.png)     

#### 1.2 ê´€ì°° í”„ë¡œê·¸ë¨ ì‘ì„±

```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <chrono>
#include <windows.h>

void cpuIntensiveTask(int threadId, int seconds)
{
    auto start = std::chrono::high_resolution_clock::now();
    auto end = start + std::chrono::seconds(seconds);

    while (std::chrono::high_resolution_clock::now() < end) {
        // CPU ì§‘ì•½ì  ì‘ì—… ì‹œë®¬ë ˆì´ì…˜
        volatile int dummy = 0;
        for (int i = 0; i < 1000000; ++i) {
            dummy += i;
        }
    }

    std::cout << "ìŠ¤ë ˆë“œ " << threadId << " ì™„ë£Œ" << std::endl;
}

int main()
{    
    std::cout << "í˜„ì¬ í”„ë¡œì„¸ìŠ¤ ID: " << GetCurrentProcessId() << std::endl;
    std::cout << "Task Managerì—ì„œ ì´ PIDë¥¼ ì°¾ì•„ë³´ì„¸ìš”!" << std::endl;

    std::cout << std::endl;
    std::cout << "10ì´ˆ í›„ ìŠ¤ë ˆë“œ ìƒì„±í•©ë‹ˆë‹¤" << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(10));

    std::cout << "\n1ë‹¨ê³„: ë‹¨ì¼ ìŠ¤ë ˆë“œë¡œ ì‹¤í–‰ (10ì´ˆ)" << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(2));
    cpuIntensiveTask(0, 8);

    std::cout << "\n2ë‹¨ê³„: 8ê°œ ìŠ¤ë ˆë“œë¡œ ì‹¤í–‰ (10ì´ˆ)" << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(2));

    std::vector<std::thread> threads;
    for (int i = 0; i < 8; ++i) {
        threads.emplace_back(cpuIntensiveTask, i, 8);
    }

    for (auto& t : threads) {
        t.join();
    }

    std::cout << "ê´€ì°° ì™„ë£Œ. ì—”í„°ë¥¼ ëˆŒëŸ¬ ì¢…ë£Œí•˜ì„¸ìš”." << std::endl;
    std::cin.get();
    return 0;
}
```

#### 1.3 ê´€ì°° í¬ì¸íŠ¸
- **CPU ì‚¬ìš©ë¥ **: ë‹¨ì¼ ìŠ¤ë ˆë“œ vs ë©€í‹° ìŠ¤ë ˆë“œì—ì„œì˜ ì°¨ì´
- **ìŠ¤ë ˆë“œ ìˆ˜**: í”„ë¡œê·¸ë¨ ì‹¤í–‰ ì¤‘ ìŠ¤ë ˆë“œ ê°œìˆ˜ ë³€í™”
- **ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰**: ìŠ¤ë ˆë“œ ì¶”ê°€ì— ë”°ë¥¸ ë©”ëª¨ë¦¬ ë³€í™”
  

### ì‹¤ìŠµ 2: ì„±ëŠ¥ ë¹„êµ ì‹¤ìŠµ 

#### 2.1 ë²¤ì¹˜ë§ˆí¬ í”„ë¡œê·¸ë¨ ì‘ì„±

```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <chrono>
#include <numeric>
#include <algorithm>

class PerformanceBenchmark
{
private:
    static const int ARRAY_SIZE = 10000000;
    std::vector<int> data;

public:
    PerformanceBenchmark() : data(ARRAY_SIZE) {
        // ëœë¤ ë°ì´í„° ìƒì„±
        std::iota(data.begin(), data.end(), 1);
        std::random_shuffle(data.begin(), data.end());
    }

    // ë‹¨ì¼ ìŠ¤ë ˆë“œë¡œ ë°°ì—´ ì •ë ¬
    long long singleThreadSort() {
        auto dataCopy = data;

        auto start = std::chrono::high_resolution_clock::now();
        std::sort(dataCopy.begin(), dataCopy.end());
        auto end = std::chrono::high_resolution_clock::now();

        return std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    }

    // ë©€í‹° ìŠ¤ë ˆë“œë¡œ ë°°ì—´ ì •ë ¬ (ë³‘í•© ì •ë ¬ ë°©ì‹)
    long long multiThreadSort(int numThreads = 4) {
        auto dataCopy = data;

        auto start = std::chrono::high_resolution_clock::now();
        parallelSort(dataCopy, numThreads);
        auto end = std::chrono::high_resolution_clock::now();

        return std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    }

private:
    void parallelSort(std::vector<int>& arr, int numThreads) {
        if (numThreads <= 1 || arr.size() < 1000) {
            std::sort(arr.begin(), arr.end());
            return;
        }

        std::vector<std::thread> threads;
        int chunkSize = arr.size() / numThreads;

        // ê° ì²­í¬ë¥¼ ë³‘ë ¬ë¡œ ì •ë ¬
        for (int i = 0; i < numThreads; ++i) {
            int start = i * chunkSize;
            int end = (i == numThreads - 1) ? arr.size() : (i + 1) * chunkSize;

            threads.emplace_back([&arr, start, end]() {
                std::sort(arr.begin() + start, arr.begin() + end);
                });
        }

        for (auto& t : threads) {
            t.join();
        }

        // ì •ë ¬ëœ ì²­í¬ë“¤ì„ ë³‘í•©
        mergeChunks(arr, numThreads, chunkSize);
    }

    void mergeChunks(std::vector<int>& arr, int numThreads, int chunkSize) {
        // ê°„ë‹¨í•œ ë³‘í•© êµ¬í˜„ (ì‹¤ì œë¡œëŠ” ë” íš¨ìœ¨ì ì¸ ë°©ë²• ì‚¬ìš©)
        std::vector<int> temp = arr;

        for (int step = 1; step < numThreads; step *= 2) {
            for (int i = 0; i < numThreads; i += step * 2) {
                int left = i * chunkSize;
                int mid = std::min((i + step) * chunkSize, (int)arr.size());
                int right = std::min((i + step * 2) * chunkSize, (int)arr.size());

                if (mid < right) {
                    std::inplace_merge(arr.begin() + left,
                        arr.begin() + mid,
                        arr.begin() + right);
                }
            }
        }
    }
};

// ê°„ë‹¨í•œ ìˆ˜í•™ ì—°ì‚° ë²¤ì¹˜ë§ˆí¬
class MathBenchmark {
public:
    static long long singleThreadCalculation() {
        auto start = std::chrono::high_resolution_clock::now();

        double result = 0;
        for (int i = 0; i < 100000000; ++i) {
            result += std::sin(i) * std::cos(i);
        }

        auto end = std::chrono::high_resolution_clock::now();
        std::cout << "ê³„ì‚° ê²°ê³¼ (ì˜ë¯¸ ì—†ìŒ): " << result << std::endl;

        return std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    }

    static long long multiThreadCalculation(int numThreads = 4) {
        auto start = std::chrono::high_resolution_clock::now();

        std::vector<std::thread> threads;
        std::vector<double> results(numThreads, 0.0);
        int workPerThread = 100000000 / numThreads;

        for (int t = 0; t < numThreads; ++t) {
            threads.emplace_back([t, workPerThread, &results, numThreads]() {
                double localResult = 0;
                int startIdx = t * workPerThread;
                int endIdx = (t == numThreads - 1) ? 100000000 : (t + 1) * workPerThread;

                for (int i = startIdx; i < endIdx; ++i) {
                    localResult += std::sin(i) * std::cos(i);
                }
                results[t] = localResult;
                });
        }

        for (auto& thread : threads) {
            thread.join();
        }

        double totalResult = std::accumulate(results.begin(), results.end(), 0.0);
        auto end = std::chrono::high_resolution_clock::now();

        std::cout << "ê³„ì‚° ê²°ê³¼ (ì˜ë¯¸ ì—†ìŒ): " << totalResult << std::endl;
        return std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    }
};

int main() {
    std::cout << "=== ë©€í‹°ìŠ¤ë ˆë“œ ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬ ===" << std::endl;
    std::cout << "CPU ì½”ì–´ ìˆ˜: " << std::thread::hardware_concurrency() << std::endl << std::endl;

    // ìˆ˜í•™ ì—°ì‚° ë²¤ì¹˜ë§ˆí¬
    std::cout << "1. ìˆ˜í•™ ì—°ì‚° ë²¤ì¹˜ë§ˆí¬" << std::endl;

    auto mathSingleTime = MathBenchmark::singleThreadCalculation();
    std::cout << "ë‹¨ì¼ ìŠ¤ë ˆë“œ: " << mathSingleTime << "ms" << std::endl;

    auto mathMultiTime = MathBenchmark::multiThreadCalculation(4);
    std::cout << "4 ìŠ¤ë ˆë“œ: " << mathMultiTime << "ms" << std::endl;

    double mathSpeedup = (double)mathSingleTime / mathMultiTime;
    std::cout << "ì†ë„ í–¥ìƒ: " << mathSpeedup << "ë°°" << std::endl << std::endl;

    // ì •ë ¬ ë²¤ì¹˜ë§ˆí¬
    std::cout << "2. ë°°ì—´ ì •ë ¬ ë²¤ì¹˜ë§ˆí¬" << std::endl;
    PerformanceBenchmark benchmark;

    auto sortSingleTime = benchmark.singleThreadSort();
    std::cout << "ë‹¨ì¼ ìŠ¤ë ˆë“œ ì •ë ¬: " << sortSingleTime << "ms" << std::endl;

    auto sortMultiTime = benchmark.multiThreadSort(4);
    std::cout << "4 ìŠ¤ë ˆë“œ ì •ë ¬: " << sortMultiTime << "ms" << std::endl;

    double sortSpeedup = (double)sortSingleTime / sortMultiTime;
    std::cout << "ì†ë„ í–¥ìƒ: " << sortSpeedup << "ë°°" << std::endl << std::endl;

    // ê²°ê³¼ ë¶„ì„
    std::cout << "=== ê²°ê³¼ ë¶„ì„ ===" << std::endl;
    std::cout << "â€¢ CPU ì§‘ì•½ì  ì‘ì—…(ìˆ˜í•™ ì—°ì‚°)ì—ì„œëŠ” ë©€í‹°ìŠ¤ë ˆë“œê°€ íš¨ê³¼ì " << std::endl;
    std::cout << "â€¢ ë©”ëª¨ë¦¬ ì ‘ê·¼ì´ ë§ì€ ì‘ì—…(ì •ë ¬)ì—ì„œëŠ” íš¨ê³¼ê°€ ì œí•œì ì¼ ìˆ˜ ìˆìŒ" << std::endl;
    std::cout << "â€¢ ì‹¤ì œ ì„±ëŠ¥ í–¥ìƒì€ ì‘ì—…ì˜ íŠ¹ì„±ê³¼ ì‹œìŠ¤í…œ í™˜ê²½ì— ë”°ë¼ ë‹¬ë¼ì§" << std::endl;

    return 0;
}
```


## ìŠ¤ë ˆë“œ ìƒíƒœ ëª¨ë¸

### 1. ì´ë¡ : ìŠ¤ë ˆë“œ ìƒíƒœ ëª¨ë¸ì˜ ê¸°ë³¸ ê°œë…

#### 1.1 ìŠ¤ë ˆë“œ ìƒëª…ì£¼ê¸° ê°œìš”
ìŠ¤ë ˆë“œëŠ” ìƒì„±ë¶€í„° ì¢…ë£Œê¹Œì§€ ì—¬ëŸ¬ ìƒíƒœë¥¼ ê±°ì¹˜ë©´ì„œ ì‹¤í–‰ëœë‹¤. ì´ ìƒíƒœë“¤ì„ ì´í•´í•˜ëŠ” ê²ƒì€ íš¨ìœ¨ì ì¸ ë©€í‹°ìŠ¤ë ˆë“œ í”„ë¡œê·¸ë˜ë°ì˜ í•µì‹¬ì´ë‹¤.

**ê¸°ë³¸ ìŠ¤ë ˆë“œ ìƒíƒœ (5ê°€ì§€)**

1. **ìƒì„± (Created/New)**: ìŠ¤ë ˆë“œ ê°ì²´ëŠ” ë§Œë“¤ì–´ì¡Œì§€ë§Œ ì•„ì§ ì‹¤í–‰ë˜ì§€ ì•Šì€ ìƒíƒœ
2. **ì‹¤í–‰ ê°€ëŠ¥ (Ready/Runnable)**: ì‹¤í–‰í•  ì¤€ë¹„ê°€ ë˜ì–´ ìˆê³  CPU í• ë‹¹ì„ ê¸°ë‹¤ë¦¬ëŠ” ìƒíƒœ
3. **ì‹¤í–‰ (Running)**: í˜„ì¬ CPUì—ì„œ ì‹¤ì œë¡œ ì‹¤í–‰ë˜ê³  ìˆëŠ” ìƒíƒœ
4. **ëŒ€ê¸° (Waiting/Blocked)**: íŠ¹ì • ì´ë²¤íŠ¸(I/O, ë™ê¸°í™” ê°ì²´ ë“±)ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ìƒíƒœ
5. **ì¢…ë£Œ (Terminated/Dead)**: ì‹¤í–‰ì´ ì™„ë£Œë˜ì–´ ì •ë¦¬ë˜ê¸°ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ìƒíƒœ
  
![](./images/007.png)   
![](./images/008.png)   

  
#### 1.2 Windowsì—ì„œì˜ ìŠ¤ë ˆë“œ ìƒíƒœ
WindowsëŠ” ì¢€ ë” ì„¸ë¶„í™”ëœ ìŠ¤ë ˆë“œ ìƒíƒœë¥¼ ì‚¬ìš©í•´:

- **Initialized**: ìŠ¤ë ˆë“œê°€ ìƒì„±ë˜ì—ˆì§€ë§Œ ì•„ì§ ì‹œì‘ë˜ì§€ ì•ŠìŒ
- **Ready**: ì‹¤í–‰ ëŒ€ê¸° ì¤‘
- **Running**: í˜„ì¬ ì‹¤í–‰ ì¤‘
- **Standby**: ë‹¤ìŒì— ì‹¤í–‰ë  ì˜ˆì • (íŠ¹ì • í”„ë¡œì„¸ì„œì— í• ë‹¹ë¨)
- **Waiting**: ê°ì²´ë‚˜ ì´ë²¤íŠ¸ ëŒ€ê¸° ì¤‘
- **Transition**: ë©”ëª¨ë¦¬ì—ì„œ í˜ì´ì§€ ëŒ€ê¸°
- **Terminated**: ì¢…ë£Œë¨
  
![](./images/009.png)     
  

### 2. ìŠ¤ë ˆë“œ ìƒíƒœ ì „í™˜ ë‹¤ì´ì–´ê·¸ë¨
ìŠ¤ë ˆë“œê°€ ì–´ë–¤ ì¡°ê±´ì—ì„œ ìƒíƒœë¥¼ ë³€ê²½í•˜ëŠ”ì§€ ì‹œê°ì ìœ¼ë¡œ í™•ì¸í•´ë³´ì.

<pre>
    [ìƒì„±]
      â†“ ìŠ¤ë ˆë“œ ì‹œì‘
   [ì‹¤í–‰ê°€ëŠ¥]
      â†“ ìŠ¤ì¼€ì¤„ëŸ¬ê°€ CPU í• ë‹¹
    [ì‹¤í–‰] â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â†“                      â”‚
      â”œâ”€â†’ [ëŒ€ê¸°] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ (ì´ë²¤íŠ¸ ë°œìƒì‹œ)
      â”‚   (I/O, ë™ê¸°í™” ëŒ€ê¸°)
      â”‚
      â”œâ”€â†’ [ì‹¤í–‰ê°€ëŠ¥] (ì‹œê°„ í• ë‹¹ëŸ‰ ì´ˆê³¼, ì„ ì )
      â”‚      â†‘
      â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (ìŠ¤ì¼€ì¤„ëŸ¬ ì¬ì„ íƒ)
      â”‚
      â””â”€â†’ [ì¢…ë£Œ] (í•¨ìˆ˜ ì™„ë£Œ, ì˜ˆì™¸, ê°•ì œ ì¢…ë£Œ)
</pre>
  
![](./images/010.png)     


### 3 ìƒíƒœ ì „í™˜ ì¡°ê±´ë“¤
**ìƒì„± â†’ ì‹¤í–‰ê°€ëŠ¥**
- `std::thread` ìƒì„±ì í˜¸ì¶œ ë˜ëŠ” `CreateThread()` API í˜¸ì¶œ

**ì‹¤í–‰ê°€ëŠ¥ â†’ ì‹¤í–‰**
- ìš´ì˜ì²´ì œ ìŠ¤ì¼€ì¤„ëŸ¬ê°€ í•´ë‹¹ ìŠ¤ë ˆë“œë¥¼ ì„ íƒ
- CPU ì½”ì–´ê°€ ì‚¬ìš© ê°€ëŠ¥í•´ì§

**ì‹¤í–‰ â†’ ëŒ€ê¸°**
- I/O ì‘ì—… (íŒŒì¼ ì½ê¸°/ì“°ê¸°, ë„¤íŠ¸ì›Œí¬ í†µì‹ )
- ë™ê¸°í™” ê°ì²´ ëŒ€ê¸° (`mutex`, `condition_variable` ë“±)
- ëª…ì‹œì  ëŒ€ê¸° (`sleep`, `wait` í•¨ìˆ˜ í˜¸ì¶œ)

**ì‹¤í–‰ â†’ ì‹¤í–‰ê°€ëŠ¥**
- ì‹œê°„ í• ë‹¹ëŸ‰(time slice) ì†Œì§„
- ë” ë†’ì€ ìš°ì„ ìˆœìœ„ ìŠ¤ë ˆë“œì˜ ì„ ì (preemption)
- `yield()` í•¨ìˆ˜ í˜¸ì¶œë¡œ ìë°œì  ì–‘ë³´

**ëŒ€ê¸° â†’ ì‹¤í–‰ê°€ëŠ¥**
- ëŒ€ê¸° ì¤‘ì´ë˜ ì´ë²¤íŠ¸ ë°œìƒ
- I/O ì‘ì—… ì™„ë£Œ
- ë™ê¸°í™” ê°ì²´ íšë“ ê°€ëŠ¥
  

Window:  
![](./images/011.png)   
![](./images/012.png)   


### 4. ìš”ì•½

#### í•µì‹¬ í¬ì¸íŠ¸
1. **ìŠ¤ë ˆë“œ ìƒíƒœ**ëŠ” ìƒì„±â†’ì‹¤í–‰ê°€ëŠ¥â†’ì‹¤í–‰â†’ëŒ€ê¸°â†’ì¢…ë£Œì˜ ìƒëª…ì£¼ê¸°ë¥¼ ê°€ì§„ë‹¤
2. **ìƒíƒœ ì „í™˜**ì€ ìŠ¤ì¼€ì¤„ëŸ¬, I/O, ë™ê¸°í™” ë“±ì˜ ì´ë²¤íŠ¸ì— ì˜í•´ ë°œìƒí•œë‹¤
3. **Windowsì—ì„œëŠ”** ë” ì„¸ë¶„í™”ëœ ìŠ¤ë ˆë“œ ìƒíƒœì™€ ê³ ê¸‰ ì œì–´ ê¸°ëŠ¥ì„ ì œê³µí•œë‹¤
4. **ì‹¤ìš©ì ì¸ ìŠ¤ë ˆë“œ ê´€ë¦¬**ë¥¼ ìœ„í•´ì„œëŠ” ì—­í• ë³„ ë¶„ë¦¬ì™€ ìš°ì„ ìˆœìœ„ ì„¤ì •ì´ ì¤‘ìš”í•˜ë‹¤

#### ê²Œì„ ì„œë²„ ê°œë°œì—ì„œì˜ í™œìš©
- **ë„¤íŠ¸ì›Œí¬ ìŠ¤ë ˆë“œ**ëŠ” ë†’ì€ ìš°ì„ ìˆœìœ„ë¡œ I/O ì²˜ë¦¬
- **ê²Œì„ ë¡œì§ ìŠ¤ë ˆë“œ**ëŠ” CPU ì§‘ì•½ì  ì‘ì—… ë‹´ë‹¹
- **ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ**ìœ¼ë¡œ ì‹¤ì‹œê°„ ìŠ¤ë ˆë“œ ìƒíƒœ ì¶”ì 
- **ë¶€í•˜ ë¶„ì‚°**ìœ¼ë¡œ íš¨ìœ¨ì ì¸ ë¦¬ì†ŒìŠ¤ í™œìš©

  
-----  
    
## ê°„ë‹¨í•œ ìŠ¤ë ˆë“œ í”„ë¡œê·¸ë˜ë° 

### Win32 API  
ì´ í”„ë¡œê·¸ë¨ì€ ì—¬ëŸ¬ ê°œì˜ ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ì—¬ ê³µìœ  ë³€ìˆ˜ì¸ `g_count`ë¥¼ ê°ê° 100ë§Œ ë²ˆì”© ì¦ê°€ì‹œí‚¨ë‹¤.   
`CRITICAL_SECTION`ì„ ì‚¬ìš©í•˜ì—¬ í•œ ë²ˆì— í•˜ë‚˜ì˜ ìŠ¤ë ˆë“œë§Œ `g_count`ì— ì ‘ê·¼í•˜ë„ë¡ í•˜ì—¬ ë°ì´í„°ì˜ ë¬´ê²°ì„±ì„ ë³´ì¥í•œë‹¤.  
  
```cpp
#include <iostream>
#include <vector>
#include <process.h> // _beginthreadex
#include <windows.h> // Windows API

// ìŠ¤ë ˆë“œì— ì „ë‹¬ë  ë°ì´í„° êµ¬ì¡°ì²´
struct ThreadData {
    int threadId;
};

// ëª¨ë“  ìŠ¤ë ˆë“œê°€ ê³µìœ í•  ì „ì—­ ë³€ìˆ˜
int g_count = 0;

// ë™ê¸°í™”ë¥¼ ìœ„í•œ í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ ê°ì²´
CRITICAL_SECTION g_cs;

// ìŠ¤ë ˆë“œê°€ ì‹¤í–‰í•  í•¨ìˆ˜
// unsigned int __stdcall: _beginthreadexì—ì„œ ìš”êµ¬í•˜ëŠ” í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜
unsigned int __stdcall ThreadFunction(void* pParam) {
    ThreadData* pData = static_cast<ThreadData*>(pParam);

    for (int i = 0; i < 1000000; ++i) {
        // --- í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ ì‹œì‘ ---
        // ê³µìœ  ë°ì´í„°ì— ì ‘ê·¼í•˜ê¸° ì „ì— ì ê¸ˆì„ ìš”ì²­í•œë‹¤.
        // ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ì´ë¯¸ ì ê¸ˆì„ íšë“í–ˆë‹¤ë©´, í•´ë‹¹ ìŠ¤ë ˆë“œê°€ ì ê¸ˆì„ í•´ì œí•  ë•Œê¹Œì§€ ëŒ€ê¸°í•œë‹¤.
        EnterCriticalSection(&g_cs);

        // í•œ ë²ˆì— í•˜ë‚˜ì˜ ìŠ¤ë ˆë“œë§Œ ì´ ì½”ë“œ ë¸”ë¡ì„ ì‹¤í–‰í•  ìˆ˜ ìˆë‹¤.
        g_count++;

        // ê³µìœ  ë°ì´í„° ì ‘ê·¼ì´ ëë‚¬ìœ¼ë¯€ë¡œ ì ê¸ˆì„ í•´ì œí•œë‹¤.
        LeaveCriticalSection(&g_cs);
        // --- í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ ì¢…ë£Œ ---
    }

    std::cout << "Thread " << pData->threadId << " finished." << std::endl;

    // ìŠ¤ë ˆë“œì— ì „ë‹¬ëœ ë©”ëª¨ë¦¬ í•´ì œ
    delete pData;

    return 0; // ìŠ¤ë ˆë“œ ì¢…ë£Œ ì½”ë“œ
}

int main() 
{
    const int NUM_THREADS = 5; // ìƒì„±í•  ìŠ¤ë ˆë“œ ê°œìˆ˜

    std::vector<HANDLE> threadHandles(NUM_THREADS);
    std::vector<ThreadData*> threadData(NUM_THREADS);

    // 1. í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ ì´ˆê¸°í™”
    // ë™ê¸°í™” ê°ì²´ë¥¼ ì‚¬ìš©í•˜ê¸° ì „ì— ë°˜ë“œì‹œ í˜¸ì¶œí•´ì•¼ í•œë‹¤.
    InitializeCriticalSection(&g_cs);

    std::cout << "Main thread: Creating " << NUM_THREADS << " worker threads..." << std::endl;

    for (int i = 0; i < NUM_THREADS; ++i) {
        // ê° ìŠ¤ë ˆë“œì— ê³ ìœ í•œ ë°ì´í„°ë¥¼ ì „ë‹¬í•˜ê¸° ìœ„í•´ ë™ì  í• ë‹¹
        threadData[i] = new ThreadData{ i };

        // 2. ìŠ¤ë ˆë“œ ìƒì„±
        // _beginthreadex(ë³´ì•ˆ ì†ì„±, ìŠ¤íƒ í¬ê¸°, ìŠ¤ë ˆë“œ í•¨ìˆ˜, ìŠ¤ë ˆë“œ ì¸ì, ìƒì„± í”Œë˜ê·¸, ìŠ¤ë ˆë“œ ID)
        threadHandles[i] = (HANDLE)_beginthreadex(NULL, 0, &ThreadFunction, threadData[i], 0, NULL);

        if (threadHandles[i] == NULL) {
            std::cerr << "Failed to create thread " << i << std::endl;
            return 1;
        }
    }

    // 3. ëª¨ë“  ìŠ¤ë ˆë“œê°€ ì¢…ë£Œë  ë•Œê¹Œì§€ ëŒ€ê¸°
    // WaitForMultipleObjects(í•¸ë“¤ ê°œìˆ˜, í•¸ë“¤ ë°°ì—´, ëª¨ë‘ ëŒ€ê¸° ì—¬ë¶€, íƒ€ì„ì•„ì›ƒ)
    // ì„¸ ë²ˆì§¸ ì¸ìê°€ TRUEì´ë¯€ë¡œ, ëª¨ë“  ìŠ¤ë ˆë“œê°€ ì¢…ë£Œë˜ì–´ì•¼ ë°˜í™˜ëœë‹¤.
    WaitForMultipleObjects(NUM_THREADS, threadHandles.data(), TRUE, INFINITE);

    std::cout << "All threads have finished execution." << std::endl;
    std::cout << "Final g_count: " << g_count << std::endl;
    std::cout << "Expected g_count: " << NUM_THREADS * 1000000 << std::endl;

    // 4. ìŠ¤ë ˆë“œ í•¸ë“¤ ì •ë¦¬
    // ìŠ¤ë ˆë“œ ê°ì²´ì™€ ê´€ë ¨ëœ ì»¤ë„ ë¦¬ì†ŒìŠ¤ë¥¼ í•´ì œí•œë‹¤.
    for (int i = 0; i < NUM_THREADS; ++i) {
        CloseHandle(threadHandles[i]);
    }

    // í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ ê°ì²´ ë¦¬ì†ŒìŠ¤ í•´ì œ
    DeleteCriticalSection(&g_cs);

    return 0;
}
```

#### ì½”ë“œ ì„¤ëª… ğŸ“

  * **`InitializeCriticalSection(&g_cs)`**

      * **í¬ë¦¬í‹°ì»¬ ì„¹ì…˜(ì„ê³„ ì˜ì—­)** ê°ì²´ì¸ `g_cs`ë¥¼ ì´ˆê¸°í™”í•œë‹¤. ì„ê³„ ì˜ì—­ì´ë€ ë‘ ê°œ ì´ìƒì˜ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ì ‘ê·¼í•´ì„œëŠ” ì•ˆ ë˜ëŠ” ê³µìœ  ìì›ì„ ì˜ë¯¸í•œë‹¤. ì´ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ì•¼ `EnterCriticalSection`ê³¼ `LeaveCriticalSection`ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

  * **`_beginthreadex(...)`**

      * ìƒˆë¡œìš´ ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ê³  ì‹¤í–‰ì„ ì‹œì‘í•œë‹¤.
      * ì„¸ ë²ˆì§¸ ì¸ìë¡œ ì „ë‹¬ëœ `ThreadFunction`ì´ ìƒˆë¡œìš´ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰ë  ì½”ë“œì´ë‹¤.
      * ë„¤ ë²ˆì§¸ ì¸ìëŠ” ìŠ¤ë ˆë“œ í•¨ìˆ˜ì— ì „ë‹¬í•  ë°ì´í„°ë¥¼ ì§€ì •í•œë‹¤.

  * **`EnterCriticalSection(&g_cs)`**

      * ê³µìœ  ìì›(`g_count`)ì— ì ‘ê·¼í•˜ê¸° ì „ì— í˜¸ì¶œí•˜ì—¬ ì ê¸ˆì„ ìš”ì²­í•œë‹¤.
      * ë§Œì•½ ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ì´ë¯¸ ì ê¸ˆì„ íšë“í•œ ìƒíƒœë¼ë©´, ê·¸ ìŠ¤ë ˆë“œê°€ `LeaveCriticalSection`ì„ í˜¸ì¶œí•˜ì—¬ ì ê¸ˆì„ í•´ì œí•  ë•Œê¹Œì§€ ì´ ì§€ì ì—ì„œ ì‹¤í–‰ì´ ë©ˆì¶”ê³  ëŒ€ê¸°í•œë‹¤.

  * **`LeaveCriticalSection(&g_cs)`**

      * ê³µìœ  ìì›ì— ëŒ€í•œ ëª¨ë“  ì‘ì—…ì„ ë§ˆì¹œ í›„ ì ê¸ˆì„ í•´ì œí•œë‹¤.
      * ì´ í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ë©´, `EnterCriticalSection`ì—ì„œ ëŒ€ê¸°í•˜ê³  ìˆë˜ ë‹¤ë¥¸ ìŠ¤ë ˆë“œ ì¤‘ í•˜ë‚˜ê°€ ì ê¸ˆì„ íšë“í•˜ê³  ì„ê³„ ì˜ì—­ ì½”ë“œë¥¼ ì‹¤í–‰í•  ìˆ˜ ìˆê²Œ ëœë‹¤.

  * **`WaitForMultipleObjects(...)`**

      * `main` í•¨ìˆ˜(ë©”ì¸ ìŠ¤ë ˆë“œ)ê°€ ìì‹ ìŠ¤ë ˆë“œë“¤ì˜ ì‘ì—…ì´ ëª¨ë‘ ëë‚  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ë„ë¡ í•œë‹¤.
      * ì´ í•¨ìˆ˜ê°€ ì—†ë‹¤ë©´, ë©”ì¸ ìŠ¤ë ˆë“œëŠ” ìì‹ ìŠ¤ë ˆë“œê°€ ì‘ì—…ì„ ì™„ë£Œí•˜ê¸° ì „ì— ë¨¼ì € ì¢…ë£Œë˜ì–´ í”„ë¡œê·¸ë¨ì´ ë¹„ì •ìƒì ìœ¼ë¡œ ëë‚  ìˆ˜ ìˆë‹¤.

  * **`CloseHandle(...)`**

      * ìŠ¤ë ˆë“œ ì‚¬ìš©ì´ ëª¨ë‘ ëë‚œ í›„, ìŠ¤ë ˆë“œ ì»¤ë„ ê°ì²´ë¥¼ ì‹œìŠ¤í…œì—ì„œ ì œê±°í•˜ì—¬ ë¦¬ì†ŒìŠ¤ ëˆ„ìˆ˜ë¥¼ ë°©ì§€í•œë‹¤. ìŠ¤ë ˆë“œê°€ ì¢…ë£Œë˜ì—ˆë‹¤ê³  í•´ì„œ í•¸ë“¤ì´ ìë™ìœ¼ë¡œ ë‹«íˆì§€ëŠ” ì•Šìœ¼ë¯€ë¡œ ëª…ì‹œì ìœ¼ë¡œ í˜¸ì¶œí•´ì•¼ í•œë‹¤.

#### ì‹¤í–‰ ê²°ê³¼ ì˜ˆì¸¡

```
Main thread: Creating 5 worker threads...
Thread 1 finished.
Thread 0 finished.
Thread 3 finished.
Thread 2 finished.
Thread 4 finished.
All threads have finished execution.
Final g_count: 5000000
Expected g_count: 5000000
```
  
(ìŠ¤ë ˆë“œ ì™„ë£Œ ìˆœì„œëŠ” ì‹¤í–‰í•  ë•Œë§ˆë‹¤ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.)

ë§Œì•½ `EnterCriticalSection`ê³¼ `LeaveCriticalSection`ìœ¼ë¡œ `g_count++` ì—°ì‚°ì„ ê°ì‹¸ì§€ ì•ŠëŠ”ë‹¤ë©´, ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— `g_count` ê°’ì„ ì½ê³ , ì¦ê°€ì‹œí‚¤ê³ , ì“°ëŠ” ê³¼ì •ì—ì„œ **ê²½ìŸ ìƒíƒœ(Race Condition)**ê°€ ë°œìƒí•˜ì—¬ `Final g_count`ê°€ ì˜ˆìƒ ê°’ì¸ 5,000,000 ë³´ë‹¤ ì‘ê²Œ ë‚˜ì˜¬ ê²ƒì´ë‹¤. ì´ ì˜ˆì œëŠ” ë™ê¸°í™”ì˜ ì¤‘ìš”ì„±ì„ ëª…í™•í•˜ê²Œ ë³´ì—¬ì¤€ë‹¤.
  
    
### C++ Thread  
Windows APIë¡œ ì‘ì„±í–ˆë˜ ì½”ë“œì™€ ì™„ì „íˆ ë™ì¼í•œ ê¸°ëŠ¥ì„ C++11 í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬(`std::thread`, `std::mutex` ë“±)ë§Œì„ ì‚¬ìš©í•˜ì—¬ ì‘ì„±í•˜ì˜€ë‹¤.
`std::mutex`ì™€ `std::lock_guard`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ê³µìœ  ë³€ìˆ˜ì¸ `g_count`ë¥¼ ì•ˆì „í•˜ê²Œ ì¦ê°€ì‹œí‚¤ëŠ” ì˜ˆì œì´ë‹¤.  
    
ì´ ì½”ë“œëŠ” íŠ¹ì • ìš´ì˜ì²´ì œ(OS)ì— ì¢…ì†ë˜ì§€ ì•Šì•„ Windows, macOS, Linux ë“± ë‹¤ì–‘í•œ í™˜ê²½ì—ì„œ ì»´íŒŒì¼í•˜ê³  ì‹¤í–‰í•  ìˆ˜ ìˆë‹¤.
  
```cpp
#include <iostream>
#include <vector>
#include <thread> // std::thread
#include <mutex>  // std::mutex, std::lock_guard

// ëª¨ë“  ìŠ¤ë ˆë“œê°€ ê³µìœ í•  ì „ì—­ ë³€ìˆ˜
int g_count = 0;

// ë™ê¸°í™”ë¥¼ ìœ„í•œ ë®¤í…ìŠ¤ ê°ì²´
// Windows APIì˜ CRITICAL_SECTIONê³¼ ìœ ì‚¬í•œ ì—­í• ì„ í•œë‹¤.
std::mutex g_mutex;

// ìŠ¤ë ˆë“œê°€ ì‹¤í–‰í•  í•¨ìˆ˜
void ThreadFunction(int threadId) 
{
    for (int i = 0; i < 1000000; ++i) {
        // --- ë®¤í…ìŠ¤ ì ê¸ˆ ì‹œì‘ ---
        // std::lock_guardëŠ” ìƒì„±ë  ë•Œ ìë™ìœ¼ë¡œ g_mutexë¥¼ ì ê·¼ë‹¤.
        // ì´ ë¸”ë¡({})ì„ ë²—ì–´ë‚  ë•Œ, lock_guard ê°ì²´ê°€ íŒŒê´´ë˜ë©´ì„œ
        // ìë™ìœ¼ë¡œ g_mutexì˜ ì ê¸ˆì„ í•´ì œ(unlock)í•œë‹¤. (RAII íŒ¨í„´)
        // EnterCriticalSection/LeaveCriticalSection ìŒì„ ëŒ€ì²´í•œë‹¤.
        {
            std::lock_guard<std::mutex> lock(g_mutex);
            g_count++;
        } // <- lock_guardê°€ ì—¬ê¸°ì„œ ì†Œë©¸ë˜ë©° g_mutex.unlock()ì´ í˜¸ì¶œë¨
        // --- ë®¤í…ìŠ¤ ì ê¸ˆ ì¢…ë£Œ ---
    }
    // C++ì—ì„œëŠ” coutì´ ìŠ¤ë ˆë“œë¡œë¶€í„° ì•ˆì „í•œ ì¶œë ¥ì„ ì–´ëŠ ì •ë„ ë³´ì¥í•˜ì§€ë§Œ,
    // ì—¬ëŸ¬ ìŠ¤ë ˆë“œì˜ ì¶œë ¥ì´ ì„ì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ëª…í™•í•œ êµ¬ë¶„ì„ ìœ„í•´ ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•œë‹¤.
    // std::cout << "Thread " << threadId << " finished." << std::endl;
}

int main() 
{
    const int NUM_THREADS = 5; // ìƒì„±í•  ìŠ¤ë ˆë“œ ê°œìˆ˜

    std::vector<std::thread> threads;

    std::cout << "Main thread: Creating " << NUM_THREADS << " worker threads..." << std::endl;

    // 1. ìŠ¤ë ˆë“œ ìƒì„±
    // Windows APIì˜ _beginthreadexì™€ ìœ ì‚¬í•œ ì—­í• ì„ í•œë‹¤.
    for (int i = 0; i < NUM_THREADS; ++i) {
        // std::thread ê°ì²´ë¥¼ ìƒì„±í•˜ë©´ ë°”ë¡œ ìŠ¤ë ˆë“œê°€ ì‹¤í–‰ëœë‹¤.
        // ì²« ë²ˆì§¸ ì¸ìëŠ” ìŠ¤ë ˆë“œ í•¨ìˆ˜, ê·¸ ì´í›„ëŠ” í•´ë‹¹ í•¨ìˆ˜ì— ì „ë‹¬í•  ì¸ìë“¤ì´ë‹¤.
        threads.emplace_back(ThreadFunction, i);
    }

    // 2. ëª¨ë“  ìŠ¤ë ˆë“œê°€ ì¢…ë£Œë  ë•Œê¹Œì§€ ëŒ€ê¸°
    // Windows APIì˜ WaitForMultipleObjectsì™€ ìœ ì‚¬í•œ ì—­í• ì„ í•œë‹¤.
    for (auto& t : threads) {
        // join() ë©¤ë²„ í•¨ìˆ˜ëŠ” í•´ë‹¹ ìŠ¤ë ˆë“œê°€ ì¢…ë£Œë  ë•Œê¹Œì§€ í˜„ì¬ ìŠ¤ë ˆë“œ(main)ë¥¼ ëŒ€ê¸°ì‹œí‚¨ë‹¤.
        t.join();
    }

    std::cout << "All threads have finished execution." << std::endl;
    std::cout << "Final g_count: " << g_count << std::endl;
    std::cout << "Expected g_count: " << NUM_THREADS * 1000000 << std::endl;

    // C++ì—ì„œëŠ” std::threadì™€ std::mutex ê°ì²´ê°€ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ë©´
    // ìë™ìœ¼ë¡œ ì†Œë©¸ë˜ë¯€ë¡œ, CloseHandleì´ë‚˜ DeleteCriticalSectionê³¼ ê°™ì€
    // ëª…ì‹œì ì¸ ì •ë¦¬ í•¨ìˆ˜ í˜¸ì¶œì´ í•„ìš” ì—†ë‹¤.

    return 0;
}
```

  
#### Windows API ë²„ì „ê³¼ì˜ ë¹„êµ ğŸ”„

| ê¸°ëŠ¥ | Windows API | C++ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ | ì„¤ëª… |
| :--- | :--- | :--- | :--- |
| **ìŠ¤ë ˆë“œ ìƒì„±** | `_beginthreadex()` | `std::thread` | `std::thread` ê°ì²´ë¥¼ ìƒì„±í•˜ëŠ” ê²ƒë§Œìœ¼ë¡œ ìŠ¤ë ˆë“œê°€ ì‹œì‘ë˜ì–´ ë” ê°„ê²°í•˜ë‹¤. |
| **ë™ê¸°í™” ê°ì²´**| `CRITICAL_SECTION` | `std::mutex` | ê³µìœ  ìì›ì„ ë³´í˜¸í•˜ê¸° ìœ„í•œ ì ê¸ˆ ë©”ì»¤ë‹ˆì¦˜ì„ ì œê³µí•œë‹¤. |
| **ì ê¸ˆ/í•´ì œ** | `Enter/LeaveCriticalSection` | `std::lock_guard` | `std::lock_guard`ëŠ” **RAII(Resource Acquisition Is Initialization)** íŒ¨í„´ì„ í™œìš©í•˜ì—¬, ê°ì²´ê°€ ìƒì„±ë  ë•Œ ì ê·¸ê³  ë²”ìœ„ë¥¼ ë²—ì–´ë‚  ë•Œ ìë™ìœ¼ë¡œ í•´ì œí•œë‹¤. ì´ ë°©ì‹ì€ ê°œë°œìê°€ ì ê¸ˆ í•´ì œë¥¼ ìŠì–´ë²„ë¦¬ëŠ” ì‹¤ìˆ˜ë¥¼ ì›ì²œì ìœ¼ë¡œ ë°©ì§€í•´ í›¨ì”¬ ì•ˆì „í•˜ë‹¤. |
| **ì¢…ë£Œ ëŒ€ê¸°** | `WaitForMultipleObjects()` | `thread.join()` | ê° ìŠ¤ë ˆë“œ ê°ì²´ì— ëŒ€í•´ `join()`ì„ í˜¸ì¶œí•˜ì—¬ í•´ë‹¹ ìŠ¤ë ˆë“œê°€ ëë‚  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦°ë‹¤. |
| **ë¦¬ì†ŒìŠ¤ ì •ë¦¬**| `CloseHandle()` | **(í•„ìš” ì—†ìŒ)** | `std::thread` ê°ì²´ê°€ ì†Œë©¸ìì—ì„œ ê´€ë ¨ ë¦¬ì†ŒìŠ¤ë¥¼ ìë™ìœ¼ë¡œ ì •ë¦¬í•˜ë¯€ë¡œ ë³„ë„ì˜ ì •ë¦¬ ì½”ë“œê°€ í•„ìš” ì—†ë‹¤. |
  
