# 스레드 어피니티와 프로세서 할당

## 1. 개념 소개
현대의 컴퓨터 시스템은 대부분 멀티코어 프로세서를 탑재하고 있다. 운영체제의 스케줄러는 기본적으로 시스템의 모든 프로세서 코어에 스레드를 자동으로 분배하여 실행한다. 그러나 특정 상황에서는 개발자가 직접 스레드가 실행될 프로세서를 지정하는 것이 성능상 유리할 수 있다. 이러한 기법을 **스레드 어피니티(Thread Affinity)** 설정이라고 한다.

스레드 어피니티는 특정 스레드를 특정 프로세서 코어 또는 코어 그룹에 바인딩하는 기술이다. Windows는 각 프로세서 코어를 비트마스크로 표현하며, 개발자는 이 비트마스크를 통해 스레드가 실행될 수 있는 프로세서를 제한하거나 지정할 수 있다.

### 1.1 스레드 어피니티가 필요한 이유
스레드 어피니티 설정이 유용한 경우는 다음과 같다.

**CPU 캐시 친화성 향상**: 스레드가 특정 코어에서 계속 실행되면 해당 코어의 L1, L2 캐시에 스레드 관련 데이터가 유지된다. 스레드가 다른 코어로 이동하면 캐시 미스가 발생하여 성능이 저하될 수 있다. 스레드 어피니티를 설정하면 캐시 히트율을 높여 성능을 개선할 수 있다.

**NUMA 시스템 최적화**: NUMA(Non-Uniform Memory Access) 아키텍처에서는 각 프로세서가 로컬 메모리와 원격 메모리에 서로 다른 속도로 접근한다. 스레드를 특정 NUMA 노드의 프로세서에 할당하고 해당 노드의 메모리를 사용하면 메모리 접근 지연을 최소화할 수 있다.

**실시간 성능 보장**: 특정 스레드를 전용 코어에 할당하여 다른 스레드의 간섭 없이 일정한 성능을 보장할 수 있다. 이는 실시간 시스템이나 오디오/비디오 처리와 같이 지연 시간에 민감한 애플리케이션에서 중요하다.

**리소스 분리**: 여러 독립적인 작업을 수행하는 애플리케이션에서 각 작업 그룹을 서로 다른 프로세서 세트에 할당하여 간섭을 줄이고 예측 가능한 성능을 얻을 수 있다.

### 1.2 프로세서 비트마스크
Windows에서 프로세서는 비트마스크로 표현된다. 각 비트는 하나의 논리 프로세서를 나타내며, 비트가 1로 설정되면 해당 프로세서를 사용할 수 있음을 의미한다.

예를 들어, 4코어 시스템에서 비트마스크는 다음과 같이 해석된다.

- `0x0001` (이진수: 0001): 프로세서 0만 사용
- `0x0002` (이진수: 0010): 프로세서 1만 사용
- `0x0003` (이진수: 0011): 프로세서 0과 1 사용
- `0x000F` (이진수: 1111): 모든 프로세서(0, 1, 2, 3) 사용

64비트 시스템에서는 `DWORD_PTR` 타입을 사용하여 최대 64개의 프로세서를 표현할 수 있다. 64개를 초과하는 프로세서를 다루려면 프로세서 그룹 개념을 사용해야 한다.
  
</br>     

## 2. 주요 API 함수

### 2.1 SetThreadAffinityMask

```cpp
DWORD_PTR SetThreadAffinityMask(
    HANDLE    hThread,
    DWORD_PTR dwThreadAffinityMask
);
```

이 함수는 지정된 스레드의 어피니티 마스크를 설정한다.

**매개변수**:
- `hThread`: 어피니티 마스크를 설정할 스레드의 핸들. `GetCurrentThread()`를 사용하여 현재 스레드를 지정할 수 있다.
- `dwThreadAffinityMask`: 스레드가 실행될 수 있는 프로세서를 나타내는 비트마스크. 이 값은 프로세스의 어피니티 마스크의 부분집합이어야 한다.

**반환값**: 성공하면 이전 어피니티 마스크를 반환한다. 실패하면 0을 반환한다.

**중요 사항**: 스레드 어피니티 마스크는 프로세스 어피니티 마스크 범위 내에서만 설정할 수 있다. 프로세스에 허용되지 않은 프로세서를 지정하면 함수가 실패한다.

### 2.2 SetProcessAffinityMask

```cpp
BOOL SetProcessAffinityMask(
    HANDLE    hProcess,
    DWORD_PTR dwProcessAffinityMask
);
```

이 함수는 프로세스의 어피니티 마스크를 설정한다. 프로세스 내 모든 스레드는 이 마스크 범위 내에서만 프로세서에 할당될 수 있다.

**매개변수**:
- `hProcess`: 프로세스 핸들. `GetCurrentProcess()`로 현재 프로세스를 지정할 수 있다.
- `dwProcessAffinityMask`: 프로세스가 사용할 수 있는 프로세서를 나타내는 비트마스크.

**반환값**: 성공하면 0이 아닌 값, 실패하면 0을 반환한다.

### 2.3 GetProcessAffinityMask

```cpp
BOOL GetProcessAffinityMask(
    HANDLE     hProcess,
    PDWORD_PTR lpProcessAffinityMask,
    PDWORD_PTR lpSystemAffinityMask
);
```

이 함수는 프로세스와 시스템의 어피니티 마스크를 조회한다.

**매개변수**:
- `hProcess`: 프로세스 핸들.
- `lpProcessAffinityMask`: 프로세스의 현재 어피니티 마스크를 받을 변수의 포인터.
- `lpSystemAffinityMask`: 시스템의 어피니티 마스크를 받을 변수의 포인터. 시스템에서 사용 가능한 모든 프로세서를 나타낸다.

**반환값**: 성공하면 0이 아닌 값, 실패하면 0을 반환한다.

### 2.4 SetThreadIdealProcessor

```cpp
DWORD SetThreadIdealProcessor(
    HANDLE hThread,
    DWORD  dwIdealProcessor
);
```

이 함수는 스레드의 이상적인 프로세서를 설정한다. 어피니티 마스크와 달리 이는 강제가 아닌 힌트이며, 스케줄러는 가능한 한 이 프로세서에서 스레드를 실행하려고 시도한다.

**매개변수**:
- `hThread`: 스레드 핸들.
- `dwIdealProcessor`: 이상적인 프로세서 번호(0부터 시작). `MAXIMUM_PROCESSORS` 값을 지정하면 시스템이 자동으로 선택한다.

**반환값**: 성공하면 이전 이상적인 프로세서 번호를 반환한다.

### 2.5 GetSystemInfo

```cpp
void GetSystemInfo(
    LPSYSTEM_INFO lpSystemInfo
);
```

이 함수는 현재 컴퓨터의 하드웨어 및 운영체제 정보를 반환한다. `SYSTEM_INFO` 구조체의 `dwNumberOfProcessors` 멤버를 통해 시스템의 프로세서 개수를 확인할 수 있다.
  
</br>  

## 3. 기본 사용 예제

### 3.1 시스템 정보 조회 및 어피니티 설정
다음 예제는 시스템의 프로세서 정보를 조회하고, 스레드를 특정 프로세서에 할당하는 기본적인 방법을 보여준다.

```cpp
#include <windows.h>
#include <iostream>

DWORD WINAPI WorkerThread(LPVOID lpParam)
{
    int threadId = (int)(INT_PTR)lpParam;
    
    // 현재 스레드가 실행 중인 프로세서 번호 확인
    DWORD currentProcessor = GetCurrentProcessorNumber();
    
    std::cout << "Thread " << threadId 
              << " started on processor " << currentProcessor << std::endl;
    
    // 간단한 작업 수행
    DWORD sum = 0;
    for (int i = 0; i < 100000000; i++)
    {
        sum += i;
    }
    
    currentProcessor = GetCurrentProcessorNumber();
    std::cout << "Thread " << threadId 
              << " finished on processor " << currentProcessor 
              << " (sum: " << sum << ")" << std::endl;
    
    return 0;
}

int main()
{
    // 시스템 정보 조회
    SYSTEM_INFO sysInfo;
    GetSystemInfo(&sysInfo);
    
    std::cout << "System has " << sysInfo.dwNumberOfProcessors 
              << " processors" << std::endl;
    
    // 프로세스 어피니티 마스크 조회
    DWORD_PTR processAffinityMask;
    DWORD_PTR systemAffinityMask;
    
    if (GetProcessAffinityMask(GetCurrentProcess(), 
                               &processAffinityMask, 
                               &systemAffinityMask))
    {
        std::cout << "Process affinity mask: 0x" << std::hex 
                  << processAffinityMask << std::endl;
        std::cout << "System affinity mask: 0x" 
                  << systemAffinityMask << std::dec << std::endl;
    }
    
    std::cout << "\n--- Creating threads with affinity ---\n" << std::endl;
    
    // 각 프로세서에 하나씩 스레드 생성
    const int numThreads = min(4, (int)sysInfo.dwNumberOfProcessors);
    HANDLE threads[4];
    
    for (int i = 0; i < numThreads; i++)
    {
        // 스레드 생성
        threads[i] = CreateThread(
            NULL,
            0,
            WorkerThread,
            (LPVOID)(INT_PTR)i,
            CREATE_SUSPENDED,  // 일시 중지 상태로 생성
            NULL
        );
        
        if (threads[i] == NULL)
        {
            std::cerr << "Failed to create thread " << i << std::endl;
            continue;
        }
        
        // 각 스레드를 특정 프로세서에 할당
        // 비트마스크: 1 << i는 i번째 프로세서를 나타냄
        DWORD_PTR affinityMask = (DWORD_PTR)1 << i;
        DWORD_PTR previousMask = SetThreadAffinityMask(threads[i], affinityMask);
        
        if (previousMask == 0)
        {
            std::cerr << "Failed to set affinity for thread " << i << std::endl;
        }
        else
        {
            std::cout << "Thread " << i << " affinity set to processor " 
                      << i << " (mask: 0x" << std::hex << affinityMask 
                      << std::dec << ")" << std::endl;
        }
        
        // 스레드 실행 재개
        ResumeThread(threads[i]);
    }
    
    std::cout << "\nWaiting for threads to complete...\n" << std::endl;
    
    // 모든 스레드 완료 대기
    WaitForMultipleObjects(numThreads, threads, TRUE, INFINITE);
    
    // 핸들 정리
    for (int i = 0; i < numThreads; i++)
    {
        CloseHandle(threads[i]);
    }
    
    std::cout << "\nAll threads completed." << std::endl;
    
    return 0;
}
```

이 예제는 시스템의 프로세서 개수만큼 스레드를 생성하고, 각 스레드를 서로 다른 프로세서에 할당한다. `GetCurrentProcessorNumber()` 함수를 사용하여 스레드가 실제로 어떤 프로세서에서 실행되는지 확인할 수 있다.
  

### 3.2 동적 어피니티 변경
스레드 실행 중에도 어피니티를 변경할 수 있다. 다음 예제는 작업 특성에 따라 어피니티를 동적으로 조정하는 방법을 보여준다.

```cpp
#include <windows.h>
#include <iostream>
#include <vector>

// 연산 집약적 작업
void ComputeIntensiveTask(int iterations)
{
    volatile double result = 0.0;
    for (int i = 0; i < iterations; i++)
    {
        result += sqrt((double)i);
    }
}

DWORD WINAPI AdaptiveThread(LPVOID lpParam)
{
    HANDLE hThread = GetCurrentThread();
    
    std::cout << "Phase 1: Running on single core" << std::endl;
    
    // Phase 1: 단일 코어에서 실행
    DWORD_PTR affinityMask = 0x0001;  // 프로세서 0
    SetThreadAffinityMask(hThread, affinityMask);
    
    DWORD start = GetTickCount();
    ComputeIntensiveTask(10000000);
    DWORD elapsed1 = GetTickCount() - start;
    
    std::cout << "Phase 1 completed in " << elapsed1 << " ms on processor " 
              << GetCurrentProcessorNumber() << std::endl;
    
    Sleep(1000);
    
    std::cout << "Phase 2: Running on any of first two cores" << std::endl;
    
    // Phase 2: 두 개의 코어 중 하나에서 실행 (스케줄러가 선택)
    affinityMask = 0x0003;  // 프로세서 0 또는 1
    SetThreadAffinityMask(hThread, affinityMask);
    
    start = GetTickCount();
    ComputeIntensiveTask(10000000);
    DWORD elapsed2 = GetTickCount() - start;
    
    std::cout << "Phase 2 completed in " << elapsed2 << " ms on processor " 
              << GetCurrentProcessorNumber() << std::endl;
    
    return 0;
}

int main()
{
    SYSTEM_INFO sysInfo;
    GetSystemInfo(&sysInfo);
    
    std::cout << "System has " << sysInfo.dwNumberOfProcessors 
              << " processors\n" << std::endl;
    
    if (sysInfo.dwNumberOfProcessors < 2)
    {
        std::cout << "This example requires at least 2 processors." << std::endl;
        return 1;
    }
    
    HANDLE hThread = CreateThread(NULL, 0, AdaptiveThread, NULL, 0, NULL);
    
    if (hThread == NULL)
    {
        std::cerr << "Failed to create thread" << std::endl;
        return 1;
    }
    
    WaitForSingleObject(hThread, INFINITE);
    CloseHandle(hThread);
    
    return 0;
}
```
  
</br>  

## 4. 실용적인 활용 예제

### 4.1 생산자-소비자 패턴에서의 어피니티 최적화
생산자와 소비자 스레드를 서로 다른 프로세서에 할당하여 캐시 경합을 줄이고 성능을 향상시킬 수 있다.
  
스레드 고정(Affinity): SetThreadAffinityMask를 사용해 생산자 스레드는 0번 CPU 코어에, 소비자 스레드는 1번 CPU 코어에 각각 고정(pinning)하여 실행한다. 이는 캐시 효율성을 높이고 컨텍스트 스위칭을 줄이려는 시도일 수 있다.

```cpp  
#include <windows.h> // Win32 API 헤더 (Critical Section, Event, Thread 등)
#include <iostream>  // C++ 표준 입출력
#include <queue>     // C++ 표준 큐 (데이터 저장소로 사용)

// 생산자와 소비자가 공유할 데이터 및 동기화 객체들을 묶은 구조체
struct SharedQueue
{
    std::queue<int> queue; // 데이터를 저장할 실제 큐
    CRITICAL_SECTION cs;   // 임계 영역(Critical Section). 큐에 대한 동시 접근을 막는 락(Mutex).
    HANDLE notEmpty;       // 큐가 비어있지 않음("not empty")을 알리는 이벤트. 소비자가 대기함.
    HANDLE notFull;        // 큐가 가득 차지 않음("not full")을 알리는 이벤트. 생산자가 대기함.
    bool done;             // 생산자가 모든 작업을 마쳤음을 알리는 플래그
    static const int MAX_SIZE = 100; // 큐의 최대 크기 (유한 버퍼)
};

// 생산자 스레드 함수
DWORD WINAPI ProducerThread(LPVOID lpParam)
{
    // main에서 전달받은 void* 포인터를 원래의 SharedQueue* 타입으로 캐스팅
    SharedQueue* sharedQueue = (SharedQueue*)lpParam;
    
    // 이 스레드(생산자)를 첫 번째 CPU 코어(0번 코어)에서만 실행되도록 고정(Affinity)
    // 0x0001은 비트마스크로, 0번 코어만 허용한다는 의미
    SetThreadAffinityMask(GetCurrentThread(), 0x0001);
    
    // 현재 스레드가 *실제로* 어느 코어에서 실행 중인지 확인하여 출력
    std::cout << "Producer running on processor " 
              << GetCurrentProcessorNumber() << std::endl;
    
    // 1000개의 아이템을 생산
    for (int i = 0; i < 1000; i++)
    {
        // 큐에 빈 공간이 생길 때까지 대기하는 루프
        while (true)
        {
            // 1. 락(Critical Section) 획득
            EnterCriticalSection(&sharedQueue->cs);
            
            // 2. 큐에 공간이 있는지 확인
            if (sharedQueue->queue.size() < SharedQueue::MAX_SIZE)
            {
                // [공간 있음]
                // 3. 데이터를 큐에 삽입
                sharedQueue->queue.push(i);
                
                // 4. 락 해제
                LeaveCriticalSection(&sharedQueue->cs);
                
                // 5. 큐가 비어있지 않음("notEmpty")을 소비자에게 알림 (신호 보냄)
                SetEvent(sharedQueue->notEmpty);
                
                // 6. 큐에 아이템을 넣었으므로 while(true) 루프 탈출
                break;
            }
            
            // [공간 없음 (큐 꽉 참)]
            // 3. ★★ 중요: 대기(Wait) 상태로 들어가기 *전에* 반드시 락을 해제해야 함.
            //    (그렇지 않으면 소비자가 락을 잡고 큐에서 아이템을 뺄 수 없어 데드락 발생)
            LeaveCriticalSection(&sharedQueue->cs);
            
            // 4. 큐에 빈 공간이 생겼다는("notFull") 신호가 올 때까지 무한정 대기
            WaitForSingleObject(sharedQueue->notFull, INFINITE);
            
            // 5. 신호를 받고 깨어나면, while(true) 루프의 처음(EnterCriticalSection)으로 돌아가
            //    다시 큐 상태를 확인
        }
        
        // 작업 시뮬레이션 (100개마다 진행 상황 출력)
        if (i % 100 == 0)
        {
            std::cout << "Produced: " << i << std::endl;
        }
    }
    
    // ----- 생산 작업 완료 -----
    
    // 1. 락 획득 (done 플래그를 안전하게 수정하기 위해)
    EnterCriticalSection(&sharedQueue->cs);
    sharedQueue->done = true; // 작업 완료 플래그 설정
    LeaveCriticalSection(&sharedQueue->cs);
    
    // 2. ★★ 매우 중요: 소비자가 큐가 비어있어서 'notEmpty' 이벤트를 기다리며 잠들어 있을 수 있음.
    //    'done = true'가 된 것을 확인하고 스레드를 종료할 수 있도록 *반드시* 깨워줘야 함.
    SetEvent(sharedQueue->notEmpty);
    
    std::cout << "Producer finished" << std::endl;
    return 0;
}

// 소비자 스레드 함수
DWORD WINAPI ConsumerThread(LPVOID lpParam)
{
    // main에서 전달받은 SharedQueue* 포인터 캐스팅
    SharedQueue* sharedQueue = (SharedQueue*)lpParam;
    
    // 이 스레드(소비자)를 두 번째 CPU 코어(1번 코어)에 고정
    // 0x0002는 비트마스크로, 1번 코어만 허용한다는 의미
    SetThreadAffinityMask(GetCurrentThread(), 0x0002);
    
    // 현재 스레드가 *실제로* 어느 코어에서 실행 중인지 확인
    std::cout << "Consumer running on processor " 
              << GetCurrentProcessorNumber() << std::endl;
    
    int processedCount = 0; // 처리한 아이템 개수 카운트
    
    // 생산자가 작업을 마치고 큐도 비어있을 때까지 무한 루프
    while (true)
    {
        // 1. 락 획득 (큐 상태 확인 및 데이터 추출을 위해)
        EnterCriticalSection(&sharedQueue->cs);
        
        // 2. 큐가 비어있는지 확인
        if (sharedQueue->queue.empty())
        {
            // [큐 비어있음]
            // 3. 큐가 비어있다면, 생산자가 작업을 마쳤는지 확인
            if (sharedQueue->done)
            {
                // [생산자 완료 & 큐 비어있음]
                // 4. 락을 해제하고
                LeaveCriticalSection(&sharedQueue->cs);
                // 5. 소비자 루프를 탈출 (스레드 종료)
                break;
            }
            
            // [생산자 미완료 & 큐 비어있음]
            // 4. ★★ 중요: 대기 상태로 들어가기 *전에* 락을 해제
            LeaveCriticalSection(&sharedQueue->cs);
            
            // 5. 큐에 아이템이 들어왔다는("notEmpty") 신호가 올 때까지 대기
            WaitForSingleObject(sharedQueue->notEmpty, INFINITE);
            
            // 6. 신호를 받고 깨어나면, while(true) 루프의 처음(EnterCriticalSection)으로
            //    돌아가서 큐 상태를 다시 확인 (데이터가 있는지, done 플래그가 섰는지)
            continue; 
        }
        
        // [큐 비어있지 않음 (아이템 있음)]
        // 3. 큐에서 데이터를 꺼냄
        int value = sharedQueue->queue.front();
        sharedQueue->queue.pop();
        
        // 4. 락 해제 (다른 스레드가 큐에 접근할 수 있도록 빠르게 풀어줌)
        LeaveCriticalSection(&sharedQueue->cs);
        
        // 5. 큐에서 아이템을 하나 뺐으므로, 큐에 빈 공간이 생겼음("notFull")을
        //    생산자에게 알림 (신호 보냄)
        SetEvent(sharedQueue->notFull);
        
        // 6. (락 바깥에서) 꺼낸 데이터 처리 시뮬레이션
        processedCount++;
        if (processedCount % 100 == 0)
        {
            std::cout << "Consumed: " << value << " (total: " 
                      << processedCount << ")" << std::endl;
        }
    }
    
    // ----- 소비 작업 완료 -----
    std::cout << "Consumer finished. Total processed: " 
              << processedCount << std::endl;
    return 0;
}

int main()
{
    // 시스템 정보(특히 CPU 코어 수)를 얻기 위한 구조체
    SYSTEM_INFO sysInfo;
    GetSystemInfo(&sysInfo);
    
    // 이 예제는 생산자와 소비자를 다른 코어에 할당하므로,
    // 최소 2개의 프로세서(코어)가 필요함
    if (sysInfo.dwNumberOfProcessors < 2)
    {
        std::cout << "This example requires at least 2 processors." << std::endl;
        return 1;
    }
    
    // 공유 큐 객체 생성
    SharedQueue sharedQueue;
    
    // --- 동기화 객체 초기화 ---
    // 1. Critical Section 초기화
    InitializeCriticalSection(&sharedQueue.cs);
    
    // 2. "notEmpty" 이벤트 생성
    //    (NULL: 기본 보안, FALSE: Auto-reset, FALSE: 초기 상태 non-signaled, NULL: 이름 없음)
    //    * Auto-reset(FALSE): Wait...Object로 대기하던 스레드 *하나*가 깨어나면
    //                        이벤트가 *자동으로* non-signaled(대기) 상태로 돌아감
    sharedQueue.notEmpty = CreateEvent(NULL, FALSE, FALSE, NULL);
    
    // 3. "notFull" 이벤트 생성 (마찬가지로 Auto-reset)
    sharedQueue.notFull = CreateEvent(NULL, FALSE, FALSE, NULL);
    
    // 4. 작업 완료 플래그 초기화
    sharedQueue.done = false;
    
    std::cout << "Starting producer-consumer example with affinity\n" << std::endl;
    
    // 시작 시간 기록
    DWORD start = GetTickCount();
    
    // 생산자 스레드 생성. 3번째 인자가 스레드 함수, 4번째 인자가 전달할 파라미터.
    HANDLE producer = CreateThread(NULL, 0, ProducerThread, &sharedQueue, 0, NULL);
    // 소비자 스레드 생성
    HANDLE consumer = CreateThread(NULL, 0, ConsumerThread, &sharedQueue, 0, NULL);
    
    if (producer == NULL || consumer == NULL)
    {
        std::cerr << "Failed to create threads" << std::endl;
        return 1;
    }
    
    // 두 스레드를 배열에 담음
    HANDLE threads[2] = { producer, consumer };
    
    // WaitForMultipleObjects: 배열 안의 *모든* 스레드가 종료될 때까지 대기 (TRUE 옵션)
    WaitForMultipleObjects(2, threads, TRUE, INFINITE);
    
    // 종료 시간 기록 및 총 소요 시간 출력
    DWORD elapsed = GetTickCount() - start;
    std::cout << "\nCompleted in " << elapsed << " ms" << std::endl;
    
    // --- 리소스 정리 ---
    // 생성한 Win32 핸들(스레드, 이벤트)들을 닫아줌 (메모리 누수 방지)
    CloseHandle(producer);
    CloseHandle(consumer);
    CloseHandle(sharedQueue.notEmpty);
    CloseHandle(sharedQueue.notFull);
    
    // Critical Section 객체 삭제
    DeleteCriticalSection(&sharedQueue.cs);
    
    return 0;
}
```
  
  
### 4.2 워커 스레드 풀과 어피니티 관리
다음 예제는 워커 스레드 풀을 생성하고 각 스레드를 특정 프로세서에 할당하여 작업을 분산 처리하는 방법을 보여준다.
- 스레드 풀: 미리 여러 개의 스레드를 생성해두고, 작업(WorkItem)이 들어오면 대기 중인 스레드가 작업을 가져가 처리하는 방식이다.
- CPU 친화도(Affinity): 각 스레드를 특정 CPU 코어에 고정(binding)시켜, 스레드가 여러 코어 사이를 이동하며 발생하는 캐시 미스(cache miss)와 같은 성능 저하를 줄이려는 기법이다
  
```cpp   
#include <windows.h> // Win32 API (스레드, 이벤트, 크리티컬 섹션 등)
#include <iostream>  // C++ 표준 입출력
#include <vector>    // C++ 벡터 (스레드 핸들 저장)
#include <queue>     // C++ 큐 (작업 큐로 사용)

// 스레드 풀이 처리할 작업 항목을 정의하는 구조체
struct WorkItem
{
    int id;           // 작업 고유 ID
    int complexity;   // 작업 복잡도 (처리 시간 시뮬레이션에 사용)
};

// CPU 친화도(Affinity) 기능이 있는 스레드 풀 클래스
class AffinityThreadPool
{
private:
    std::vector<HANDLE> threads;  // 생성된 워커 스레드들의 핸들(제어권)을 저장
    std::queue<WorkItem> workQueue; // 작업들을 저장하는 큐 (공유 자원)
    CRITICAL_SECTION queueCS;       // 'workQueue'에 대한 동시 접근을 막는 락(Mutex)
    
    // Win32 이벤트 객체 (C++의 std::condition_variable과 유사한 역할)
    HANDLE workAvailable; // 큐에 새 작업이 추가되었음을 알리는 이벤트
    HANDLE shutdownEvent; // 스레드 풀 종료를 모든 스레드에 알리는 이벤트
    
    bool shutdown; // 종료 신호 플래그
    
    // 통계용 변수
    int completedTasks;      // 완료된 작업 수
    CRITICAL_SECTION statsCS; // 'completedTasks' 변수를 보호하기 위한 락

    // -------------------------------------------------------------------------
    // 워커 스레드 관련
    // -------------------------------------------------------------------------

    // CreateThread 함수는 C 스타일 함수 포인터만 받을 수 있음 (static 멤버 함수만 가능)
    // 이 함수는 실제 스레드 로직을 실행하기 위한 진입점(entry point) 역할을 함
    static DWORD WINAPI WorkerThreadProc(LPVOID lpParam)
    {
        // lpParam으로 전달받은 'this' 포인터를 원래 클래스 타입으로 캐스팅
        AffinityThreadPool* pool = (AffinityThreadPool*)lpParam;
        // 멤버 함수인 WorkerThread()를 호출
        return pool->WorkerThread();
    }

    // 각 워커 스레드가 실제로 실행하는 메인 루프
    DWORD WorkerThread()
    {
        // 1. 자신의 스레드 인덱스 찾기 (디버깅/로깅 목적)
        DWORD threadId = GetCurrentThreadId(); // 자신의 스레드 ID
        int threadIndex = -1;
        
        // 풀이 관리하는 스레드 핸들 목록(threads)을 뒤져서
        // 자신의 스레드 ID와 일치하는 핸들을 찾아 인덱스를 식별
        for (size_t i = 0; i < threads.size(); i++)
        {
            // GetThreadId()는 스레드 핸들(HANDLE)로부터 스레드 ID(DWORD)를 얻어옴
            if (GetThreadId(threads[i]) == threadId)
            {
                threadIndex = (int)i;
                break;
            }
        }
        
        std::cout << "Worker thread " << threadIndex 
                  << " started on processor " << GetCurrentProcessorNumber() // 현재 실행 중인 CPU 코어 번호
                  << std::endl;
        
        // 2. 대기할 이벤트 설정
        // 스레드는 "새로운 작업 신호" 또는 "종료 신호" 둘 중 하나를 기다림
        HANDLE events[2] = { workAvailable, shutdownEvent };
        
        // 3. 메인 작업 루프
        while (true)
        {
            // WaitForMultipleObjects: 여러 이벤트 중 *하나라도* 신호(signaled) 상태가 될 때까지 대기
            // 2: 대기할 핸들 개수
            // events: 핸들 배열
            // FALSE: 배열 중 하나라도 신호되면 리턴 (TRUE면 모두 신호되어야 리턴)
            // INFINITE: 무한정 대기
            DWORD result = WaitForMultipleObjects(2, events, FALSE, INFINITE);
            
            // 3-1. 종료 이벤트(events[1])가 신호된 경우
            // (리턴값 = WAIT_OBJECT_0 + 배열 인덱스)
            if (result == WAIT_OBJECT_0 + 1)  // shutdownEvent
            {
                break; // 작업 루프 탈출
            }
            
            // 3-2. 작업 가능 이벤트(events[0])가 신호된 경우
            // (또는 두 이벤트가 동시에 신호된 경우, 인덱스가 낮은 0번이 우선)
            WorkItem item;
            bool hasWork = false;
            
            // 3-3. 큐에서 작업 가져오기 (임계 영역)
            EnterCriticalSection(&queueCS); // 큐에 접근하기 위해 락
            if (!workQueue.empty())
            {
                item = workQueue.front(); // 큐에서 작업 하나 꺼내기
                workQueue.pop();
                hasWork = true;
            }
            LeaveCriticalSection(&queueCS); // 락 해제
            
            // 3-4. 작업 처리
            if (hasWork)
            {
                // 실제 작업 수행 (락 바깥에서 수행해야 다른 스레드가 큐에 접근 가능)
                ProcessWork(item, threadIndex);
                
                // 완료된 작업 수 갱신 (임계 영역)
                EnterCriticalSection(&statsCS);
                completedTasks++;
                LeaveCriticalSection(&statsCS);
            }
            // else:
            // 큐가 비어있었음 (다른 스레드가 먼저 가져감).
            // 루프 처음으로 돌아가 다시 이벤트를 대기.
            // (참고: workAvailable가 수동 리셋이라, 큐가 비어도
            // ResetEvent가 호출되기 전까지 계속 깨어날 수 있음.
            // 이 코드에서는 ResetEvent를 호출하지 않으므로, 큐가 비면
            // 스레드들이 이 루프를 계속 돌며 큐를 확인하게 될 수 있음 - 비효율적)
        }
        
        std::cout << "Worker thread " << threadIndex << " shutting down" << std::endl;
        return 0;
    }

    // 실제 작업을 시뮬레이션하는 함수
    void ProcessWork(const WorkItem& item, int threadIndex)
    {
        DWORD processor = GetCurrentProcessorNumber(); // 내가 실행 중인 CPU 코어
        
        // 작업 복잡도(complexity)에 비례하는 시간 동안 CPU 연산 수행
        // (volatile: 컴파일러가 이 연산을 최적화로 제거하지 못하게 함)
        volatile double result = 0.0;
        for (int i = 0; i < item.complexity * 100000; i++)
        {
            result += sqrt((double)i); // 의미 없는 계산 반복
        }
        
        // 50번째 작업마다 진행 상황 출력
        if (item.id % 50 == 0)
        {
            std::cout << "Thread " << threadIndex << " (CPU " << processor 
                      << ") completed task " << item.id << std::endl;
        }
    }
    
public:
    // 생성자
    AffinityThreadPool() : shutdown(false), completedTasks(0)
    {
        // 락(Critical Section) 2개 초기화
        InitializeCriticalSection(&queueCS);
        InitializeCriticalSection(&statsCS);
        
        // 이벤트 생성
        // (NULL: 기본 보안, TRUE: 수동 리셋(Manual-reset), FALSE: 초기 비신호 상태, NULL: 이름 없음)
        // **중요**: '수동 리셋(TRUE)'은 SetEvent()로 신호하면 ResetEvent()를 부르기 전까지
        // 계속 신호 상태를 유지함. (Auto-reset(FALSE)은 스레드 하나가 깨어나면 자동 리셋됨)
        workAvailable = CreateEvent(NULL, TRUE, FALSE, NULL);
        shutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    }
    
    // 소멸자
    ~AffinityThreadPool()
    {
        Shutdown(); // 스레드 풀 종료
        
        // 리소스 해제
        DeleteCriticalSection(&queueCS);
        DeleteCriticalSection(&statsCS);
        CloseHandle(workAvailable);
        CloseHandle(shutdownEvent);
    }
    
    // 스레드 풀 초기화 (워커 스레드 생성)
    bool Initialize(int numThreads)
    {
        SYSTEM_INFO sysInfo;
        GetSystemInfo(&sysInfo); // 시스템 정보(CPU 코어 수 등) 가져오기
        
        // 요청된 스레드 수와 실제 CPU 코어 수 중 작은 값을 실제 스레드 수로 결정
        int actualThreads = min(numThreads, (int)sysInfo.dwNumberOfProcessors);
        
        std::cout << "Creating thread pool with " << actualThreads 
                  << " threads" << std::endl;
        
        for (int i = 0; i < actualThreads; i++)
        {
            // 스레드 생성
            HANDLE hThread = CreateThread(
                NULL,                // 기본 보안 속성
                0,                   // 기본 스택 크기
                WorkerThreadProc,    // 스레드 진입점 함수 (static)
                this,                // 스레드 함수에 전달할 인자 ('this' 포인터)
                CREATE_SUSPENDED,    // ★★ 중요: 스레드를 '일시 정지' 상태로 생성
                NULL                 // 스레드 ID는 받지 않음
            );
            
            if (hThread == NULL)
            {
                std::cerr << "Failed to create worker thread " << i << std::endl;
                return false;
            }
            
            // ★★ 스레드 친화도(Affinity) 설정
            // 스레드가 시작하기 전에(CREATE_SUSPENDED) 친화도를 설정
            // 라운드 로빈 방식으로 각 스레드를 다른 코어에 할당
            int processorIndex = i % sysInfo.dwNumberOfProcessors;
            // (DWORD_PTR)1 << processorIndex : 특정 코어(processorIndex)만 1로 켠 비트마스크
            // 예: 0번 코어 -> 0001 (1), 1번 코어 -> 0010 (2), 2번 코어 -> 0100 (4)
            DWORD_PTR affinityMask = (DWORD_PTR)1 << processorIndex;
            
            if (SetThreadAffinityMask(hThread, affinityMask) == 0)
            {
                std::cerr << "Failed to set affinity for thread " << i << std::endl;
            }
            else
            {
                std::cout << "Thread " << i << " bound to processor " 
                          << processorIndex << std::endl;
            }
            
            threads.push_back(hThread); // 스레드 핸들 목록에 추가
            ResumeThread(hThread);      // 스레드 설정이 끝났으니 '재개' (실행 시작)
        }
        
        return true;
    }
    
    // 단일 작업을 큐에 추가
    void AddWork(const WorkItem& item)
    {
        EnterCriticalSection(&queueCS); // 락
        workQueue.push(item);
        LeaveCriticalSection(&queueCS); // 락 해제
        
        // 큐에 작업이 추가되었음을 모든 대기 중인 스레드에 알림
        SetEvent(workAvailable);
    }
    
    // 여러 작업을 큐에 한 번에 추가 (효율적)
    void AddWorkBatch(const std::vector<WorkItem>& items)
    {
        EnterCriticalSection(&queueCS);
        for (const auto& item : items)
        {
            workQueue.push(item);
        }
        LeaveCriticalSection(&queueCS);
        
        // 작업 배치가 추가되었음을 모든 대기 중인 스레드에 알림
        SetEvent(workAvailable);
    }
    
    // 모든 작업이 완료될 때까지 대기 (폴링 방식)
    void WaitForCompletion()
    {
        // 큐가 빌 때까지 기다림
        while (true)
        {
            EnterCriticalSection(&queueCS);
            bool empty = workQueue.empty();
            LeaveCriticalSection(&queueCS);
            
            if (empty)
            {
                // ★★ 큐가 비었더라도, 스레드들이 마지막 작업을 아직 처리 중일 수 있음.
                // 잠시 대기한 후 다시 한번 확인 (Race condition 방지를 위한 간단한 휴리스틱)
                Sleep(100); 
                
                EnterCriticalSection(&queueCS);
                empty = workQueue.empty();
                LeaveCriticalSection(&queueCS);
                
                // 다시 확인해도 큐가 비어있으면 모든 작업이 완료된 것으로 간주
                if (empty)
                    break;
            }
            
            Sleep(10); // 큐에 작업이 남아있을 경우, CPU 점유를 낮추기 위해 잠시 대기
        }
    }
    
    // 스레드 풀 종료
    void Shutdown()
    {
        // 이미 종료되었으면 중복 실행 방지
        if (shutdown)
            return;
            
        shutdown = true;
        // '종료 이벤트'를 신호 상태로 만듦
        // WorkerThread의 WaitForMultipleObjects가 깨어나고,
        // (result == WAIT_OBJECT_0 + 1) 조건을 만족하여 루프를 탈출하게 됨
        SetEvent(shutdownEvent);
        
        if (!threads.empty())
        {
            // 모든 스레드가 종료(루프 탈출)될 때까지 대기
            // (TRUE: 배열의 '모든' 핸들이 신호 상태가 될 때까지 대기)
            WaitForMultipleObjects((DWORD)threads.size(), 
                                   threads.data(), TRUE, INFINITE);
            
            // 모든 스레드가 종료되었으므로 핸들 닫기
            for (HANDLE hThread : threads)
            {
                CloseHandle(hThread); // Win32 리소스 해제
            }
            threads.clear();
        }
    }
    
    // 완료된 작업 수 반환
    int GetCompletedTaskCount() const
    {
        // 값을 읽기만 하므로 락을 걸지 않음 (엄격하지 않은 통계)
        // (정확한 값을 원하면 statsCS로 락을 걸어야 함)
        return completedTasks;
    }
};

// --- 메인 함수 ---
int main()
{
    AffinityThreadPool pool;
    
    // 4개의 스레드로 풀 초기화 (CPU 코어 수에 따라 이보다 적게 생성될 수 있음)
    if (!pool.Initialize(4))
    {
        std::cerr << "Failed to initialize thread pool" << std::endl;
        return 1;
    }
    
    std::cout << "\nAdding work items to the pool...\n" << std::endl;
    
    // 200개의 작업 항목 생성
    std::vector<WorkItem> workItems;
    for (int i = 0; i < 200; i++)
    {
        WorkItem item;
        item.id = i;
        item.complexity = (i % 10) + 1; // 1~10 사이의 복잡도
        workItems.push_back(item);
    }
    
    DWORD start = GetTickCount(); // 시작 시간 측정
    
    // 200개의 작업을 스레드 풀에 추가
    pool.AddWorkBatch(workItems);
    
    std::cout << "Waiting for all tasks to complete...\n" << std::endl;
    
    // 모든 작업이 완료될 때까지 메인 스레드 대기
    pool.WaitForCompletion();
    
    DWORD elapsed = GetTickCount() - start; // 종료 시간 측정
    
    std::cout << "\nAll tasks completed!" << std::endl;
    std::cout << "Total tasks: " << pool.GetCompletedTaskCount() << std::endl;
    std::cout << "Time elapsed: " << elapsed << " ms" << std::endl;
    
    // main 함수가 끝나면 pool 객체의 소멸자(~AffinityThreadPool)가 호출되어
    // 자동으로 Shutdown()이 실행되고 모든 리소스가 정리됨
    return 0;
}
```  
  

### 4.3 성능 측정 및 비교
어피니티 설정의 효과를 측정하는 예제이다.

예상 효과:  
연산 집약적인 작업(이 코드의 ComputeTask 같은)은 스레드가 한 코어에 고정될 때 **캐시 효율성(Cache Locality)**이 높아져 더 빠를 수 있다. (스레드가 다른 코어로 이동하면 해당 코어의 L1/L2 캐시를 다시 채워야 하므로 비효율적dl다.)   
  
```cpp 
#include <windows.h> // Win32 API (스레드, 시스템 정보, 시간 측정 등)
#include <iostream>  // C++ 표준 입출력
#include <vector>    // C++ 벡터 (스레드 핸들 저장용)

// 각 스레드가 실행할 연산 집약적 작업 (CPU를 바쁘게 만듦)
// 이 작업은 외부 데이터 접근 없이 순수하게 CPU 연산만 수행합니다.
DWORD WINAPI ComputeTask(LPVOID lpParam)
{
    // lpParam (LPVOID, 포인터)을 정수(int)로 안전하게 캐스팅
    // (INT_PTR은 32/64비트 환경 모두에서 포인터와 같은 크기를 보장)
    int iterations = (int)(INT_PTR)lpParam;
    
    // 'volatile' 키워드: 컴파일러가 이 반복문을 "쓸모없는 연산"이라 판단하여
    // 최적화(제거)하지 못하도록 방지합니다.
    volatile double result = 0.0;
    
    // CPU를 많이 사용하는 수학 연산 (sqrt, sin)을 반복
    for (int i = 0; i < iterations; i++)
    {
        result += sqrt((double)i) * sin((double)i);
    }
    
    return 0; // 작업 완료
}

// -----------------------------------------------------------------
// 테스트 케이스 1: 어피니티(CPU 고정)를 *사용하지 않고* 실행
// -----------------------------------------------------------------
DWORD RunWithoutAffinity(int numThreads, int workload)
{
    std::vector<HANDLE> threads; // 생성된 스레드들의 핸들(제어권)을 저장할 벡터
    
    // GetTickCount(): 시스템 부팅 후 경과 시간을 밀리초(ms) 단위로 반환
    DWORD start = GetTickCount(); // 시작 시간 기록
    
    // 요청된 수(numThreads)만큼 스레드 생성
    for (int i = 0; i < numThreads; i++)
    {
        HANDLE hThread = CreateThread(
            NULL,                   // 기본 보안 속성
            0,                      // 기본 스택 크기
            ComputeTask,            // 스레드가 실행할 함수
            (LPVOID)(INT_PTR)workload, // 함수에 전달할 인자 (작업량)
            0,                      // 생성 플래그 (0 = 즉시 실행)
            NULL                    // 스레드 ID는 받지 않음
        );
        if (hThread) {
            threads.push_back(hThread); // 생성된 핸들을 벡터에 추가
        }
    }
    
    // WaitForMultipleObjects: 벡터에 있는 *모든* 스레드가 종료될 때까지 대기
    // (TRUE: 모든 핸들, INFINITE: 무한정 대기)
    // 모든 스레드가 ComputeTask를 완료해야 다음 코드로 진행
    WaitForMultipleObjects((DWORD)threads.size(), threads.data(), TRUE, INFINITE);
    
    DWORD elapsed = GetTickCount() - start; // 총 소요 시간 계산
    
    // 리소스 정리: 모든 스레드 핸들 닫기 (메모리 누수 방지)
    for (HANDLE hThread : threads)
    {
        CloseHandle(hThread);
    }
    
    return elapsed; // 소요 시간(ms) 반환
}

// -----------------------------------------------------------------
// 테스트 케이스 2: 어피니티(CPU 고정)를 *사용하여* 실행
// -----------------------------------------------------------------
DWORD RunWithAffinity(int numThreads, int workload)
{
    std::vector<HANDLE> threads;
    SYSTEM_INFO sysInfo;
    GetSystemInfo(&sysInfo); // 시스템 정보(총 CPU 코어 수) 가져오기
    
    DWORD start = GetTickCount(); // 시작 시간 기록
    
    for (int i = 0; i < numThreads; i++)
    {
        HANDLE hThread = CreateThread(
            NULL,
            0,
            ComputeTask,
            (LPVOID)(INT_PTR)workload,
            CREATE_SUSPENDED, // ★★ 중요: 스레드를 '일시 정지' 상태로 생성
                              // 어피니티를 설정한 *후에* 실행시키기 위함
            NULL
        );
        if (!hThread) continue;
        
        // 스레드를 시작하기 *전에* 어피니티(친화도)를 설정합니다.
        
        // 스레드를 할당할 CPU 코어 인덱스 계산 (라운드 로빈 방식)
        // 예: 8개 스레드, 4개 코어 -> 0,1,2,3,0,1,2,3...
        int processorIndex = i % sysInfo.dwNumberOfProcessors;
        
        // 어피니티 마스크(Bitmask) 생성
        // 예: 0번 코어 -> 0001 (1), 1번 코어 -> 0010 (2), 2번 코어 -> 0100 (4)
        DWORD_PTR affinityMask = (DWORD_PTR)1 << processorIndex;
        
        // 스레드가 지정된 CPU 코어(affinityMask)에서만 실행되도록 설정
        SetThreadAffinityMask(hThread, affinityMask);
        
        // 어피니티 설정이 완료되었으므로 스레드 실행을 '재개'
        ResumeThread(hThread);
        
        threads.push_back(hThread); // 핸들 목록에 추가
    }
    
    // 모든 스레드가 종료될 때까지 대기
    WaitForMultipleObjects((DWORD)threads.size(), threads.data(), TRUE, INFINITE);
    
    DWORD elapsed = GetTickCount() - start; // 총 소요 시간 계산
    
    // 리소스 정리
    for (HANDLE hThread : threads)
    {
        CloseHandle(hThread);
    }
    
    return elapsed; // 소요 시간(ms) 반환
}

// --- 메인 함수 (테스트 실행 및 결과 비교) ---
int main()
{
    SYSTEM_INFO sysInfo;
    GetSystemInfo(&sysInfo); // 시스템의 CPU 코어 수 확인
    
    std::cout << "System processors: " << sysInfo.dwNumberOfProcessors << std::endl;
    std::cout << "Performance comparison: Affinity vs No Affinity\n" << std::endl;
    
    // --- 테스트 설정 ---
    const int numTests = 3;       // 테스트 반복 횟수 (평균 내기)
    const int numThreads = 8;     // 생성할 스레드 개수 (코어 수보다 많게 설정하여 비교)
    const int workload = 5000000; // 스레드당 작업량 (반복 횟수)
    // --------------------
    
    std::cout << "Test configuration:" << std::endl;
    std::cout << "  Threads: " << numThreads << std::endl;
    std::cout << "  Workload per thread: " << workload << " iterations" << std::endl;
    std::cout << "  Number of test runs: " << numTests << "\n" << std::endl;
    
    // "워밍업(Warming up)" 실행
    // CPU가 저전력 모드에서 활성 모드로 전환되고, 관련 라이브러리(DLL)가
    // 메모리에 로드되는 등의 초기 비용을 상쇄하여 더 일관된 측정을 위함.
    std::cout << "Warming up..." << std::endl;
    RunWithoutAffinity(2, 1000000); // (결과는 무시)
    RunWithAffinity(2, 1000000);    // (결과는 무시)
    Sleep(1000); // 시스템 안정화 대기
    
    
    // --- 1. 어피니티 없이 실행 (OS가 자유롭게 스케줄링) ---
    std::cout << "\nRunning WITHOUT affinity..." << std::endl;
    DWORD totalWithout = 0;
    for (int i = 0; i < numTests; i++)
    {
        DWORD elapsed = RunWithoutAffinity(numThreads, workload);
        std::cout << "  Test " << (i + 1) << ": " << elapsed << " ms" << std::endl;
        totalWithout += elapsed;
        Sleep(500); // 다음 테스트 전 잠시 대기 (시스템 안정화)
    }
    DWORD avgWithout = totalWithout / numTests; // 평균 시간 계산
    
    Sleep(1000); // 두 테스트 그룹 간 시스템 안정화 대기
    
    // --- 2. 어피니티 사용 (스레드를 특정 CPU 코어에 고정) ---
    std::cout << "\nRunning WITH affinity..." << std::endl;
    DWORD totalWith = 0;
    for (int i = 0; i < numTests; i++)
    {
        DWORD elapsed = RunWithAffinity(numThreads, workload);
        std::cout << "  Test " << (i + 1) << ": " << elapsed << " ms" << std::endl;
        totalWith += elapsed;
        Sleep(500); // 다음 테스트 전 잠시 대기
    }
    DWORD avgWith = totalWith / numTests; // 평균 시간 계산
    
    // --- 최종 결과 출력 ---
    std::cout << "\n=== Results ===" << std::endl;
    std::cout << "Average without affinity: " << avgWithout << " ms" << std::endl;
    std::cout << "Average with affinity:    " << avgWith << " ms" << std::endl;
    
    // 성능 향상률(%) 계산 및 출력
    if (avgWith < avgWithout)
    {
        // (기존 시간 - 새 시간) / 기존 시간 * 100
        double improvement = ((double)(avgWithout - avgWith) / avgWithout) * 100.0;
        std::cout << "Improvement with affinity: " << improvement << "%" << std::endl;
    }
    else
    {
        // (새 시간 - 기존 시간) / 기존 시간 * 100
        double degradation = ((double)(avgWith - avgWithout) / avgWithout) * 100.0;
        std::cout << "Performance degradation with affinity: " << degradation << "%" << std::endl;
    }
    
    return 0;
} 
```  

  
</br>  

## 5. 고급 활용 기법

### 5.1 NUMA 인식 프로그래밍
NUMA 시스템에서는 프로세서와 메모리의 물리적 위치가 성능에 큰 영향을 미친다. Windows는 NUMA 노드 정보를 조회하고 스레드와 메모리를 특정 노드에 할당하는 API를 제공한다.
  
이 코드의 목적: 시스템의 NUMA 노드(CPU와 로컬 메모리 그룹)를 식별하고, 각 노드에 대해 별도의 스레드를 생성한다. 그리고 **각 스레드가 자신이 속한 NUMA 노드의 CPU에서만 실행되도록 강제(CPU 친화도 설정)** 한다.

기대 효과: 스레드가 연산(<code>NUMAAwareThread</code>의 sqrt 루프)을 수행할 때 사용하는 데이터(스택 변수 result 등)가 해당 스레드가 실행 중인 CPU의 "로컬" 메모리에 할당될 가능성이 높다. 스레드가 다른 노드로 이동(migration)되지 않으므로, "원격" 메모리 접근으로 인한 성능 저하를 방지하고 캐시 효율성을 극대화할 수 있다.  

```cpp
#include <windows.h> // Win32 API 사용 (NUMA, 스레드 관련 함수)
#include <iostream>  // 콘솔 입출력
#include <vector>    // 스레드 핸들을 저장하기 위함

// 시스템의 NUMA 토폴로지(구조) 정보를 출력하는 함수
void DisplayNUMAInformation()
{
    // 시스템에서 가장 높은 NUMA 노드 번호를 가져옵니다.
    // (NUMA 노드는 0번부터 시작)
    ULONG highestNodeNumber;
    if (!GetNumaHighestNodeNumber(&highestNodeNumber))
    {
        // 함수 실패 시
        std::cerr << "Failed to get NUMA node count" << std::endl;
        return;
    }
    
    // 가장 높은 노드 번호가 0이면 노드는 1개, 1이면 노드는 2개...
    std::cout << "System has " << (highestNodeNumber + 1) 
              << " NUMA node(s)" << std::endl;
    
    // 0번 노드부터 가장 높은 번호의 노드까지 순회
    for (ULONG node = 0; node <= highestNodeNumber; node++)
    {
        // 해당 NUMA 노드(node)에 속한 프로세서(CPU 코어)들의
        // 비트마스크(bitmap)를 가져옵니다.
        ULONGLONG processorMask;
        if (GetNumaNodeProcessorMask(node, &processorMask))
        {
            std::cout << "NUMA Node " << node << ":" << std::endl;
            // 16진수(hex)로 마스크를 출력
            // 예: 0xFF -> 8개 코어(0~7), 0xFF00 -> 8개 코어(8~15)
            std::cout << "  Processor mask: 0x" << std::hex 
                      << processorMask << std::dec << std::endl; // 다시 10진수(dec)로 복귀
            
            // --- 이 마스크에 몇 개의 비트(프로세서)가 켜져 있는지 계산 ---
            int processorCount = 0;
            ULONGLONG mask = processorMask;
            while (mask)
            {
                // mask & 1 : 가장 오른쪽 비트가 1인지 확인
                if (mask & 1)
                    processorCount++;
                // mask >>= 1 : 비트를 오른쪽으로 1칸 이동 (다음 비트 검사)
                mask >>= 1;
            }
            std::cout << "  Number of processors: " << processorCount << std::endl;
        }
    }
}

// 각 NUMA 노드에서 실행될 스레드 함수
DWORD WINAPI NUMAAwareThread(LPVOID lpParam)
{
    // CreateThread에서 전달받은 인자(노드 번호)를 원래 타입으로 캐스팅
    UCHAR nodeNumber = (UCHAR)(ULONG_PTR)lpParam;
    
    // 이 스레드가 *실제로* 어느 CPU 코어에서 실행 *시작*되었는지 출력
    // (main에서 설정한 어피니티 마스크 내의 코어 중 하나일 것임)
    std::cout << "Thread for NUMA node " << (int)nodeNumber 
              << " started on processor " << GetCurrentProcessorNumber() 
              << std::endl;
    
    // CPU 집약적인 작업 수행 (연산 시뮬레이션)
    // 'volatile'은 컴파일러가 이 루프를 최적화로 제거하지 못하게 함
    volatile double result = 0.0;
    for (int i = 0; i < 50000000; i++) // 5천만 번 반복
    {
        result += sqrt((double)i);
    }
    
    std::cout << "Thread for NUMA node " << (int)nodeNumber 
              << " completed" << std::endl;
    
    return 0;
}

int main()
{
    // 1. 시스템의 NUMA 정보 출력
    DisplayNUMAInformation();
    
    // 2. 스레드를 생성하기 위해 다시 한번 NUMA 노드 수 확인
    ULONG highestNodeNumber;
    if (!GetNumaHighestNodeNumber(&highestNodeNumber))
    {
        std::cerr << "Failed to get NUMA information" << std::endl;
        return 1;
    }
    
    // 가장 높은 노드가 0이라는 것은, 노드가 1개뿐인 시스템(UMA)이라는 의미
    if (highestNodeNumber == 0)
    {
        std::cout << "\nThis is not a NUMA system. "
                  << "Example will run but won't show NUMA benefits." << std::endl;
    }
    
    std::cout << "\nCreating threads bound to NUMA nodes...\n" << std::endl;
    
    std::vector<HANDLE> threads; // 생성된 스레드 핸들을 관리할 벡터
    
    // 3. 각 NUMA 노드마다 스레드 1개씩 생성
    for (UCHAR node = 0; node <= highestNodeNumber; node++)
    {
        // 이 노드(node)에 속한 프로세서 마스크를 가져옴
        ULONGLONG processorMask;
        if (!GetNumaNodeProcessorMask(node, &processorMask))
        {
            continue; // 마스크 획득 실패 시 다음 노드로
        }
        
        // 스레드 생성
        HANDLE hThread = CreateThread(
            NULL,                       // 기본 보안
            0,                          // 기본 스택 크기
            NUMAAwareThread,            // 실행할 스레드 함수
            (LPVOID)(ULONG_PTR)node,    // 스레드 함수에 전달할 인자 (노드 번호)
            CREATE_SUSPENDED,           // ★★ 중요: 스레드를 '일시 정지' 상태로 생성
            NULL
        );
        
        if (hThread == NULL)
        {
            std::cerr << "Failed to create thread for node " << (int)node << std::endl;
            continue;
        }
        
        // 4. ★★ 핵심: 스레드 친화도(Affinity) 설정
        // 이 스레드(hThread)가 오직 'processorMask'에 포함된 CPU 코어에서만
        // 실행되도록 OS 스케줄러에 강제함.
        if (SetThreadAffinityMask(hThread, (DWORD_PTR)processorMask) == 0)
        {
            // 실패 시 (예: 마스크가 유효하지 않은 경우)
            std::cerr << "Failed to set affinity for node " << (int)node << std::endl;
        }
        
        // 5. 어피니티 설정이 완료되었으므로, 스레드 실행 '재개'
        ResumeThread(hThread);
        threads.push_back(hThread); // 벡터에 핸들 추가
    }
    
    // 6. 모든 스레드가 작업을 완료할 때까지 대기
    if (!threads.empty())
    {
        WaitForMultipleObjects((DWORD)threads.size(), threads.data(), TRUE, INFINITE);
        
        // 7. 리소스 정리
        for (HANDLE hThread : threads)
        {
            CloseHandle(hThread);
        }
    }
    
    return 0;
}
``` 
  
#### NUMA에서 "CPU" 또는 "노드"  
NUMA에서 "CPU" 또는 "노드"라고 말할 때, 이는 일반적으로 **물리적인 CPU 소켓(Socket)**을 의미한다.

각 CPU 소켓에는 여러 개의 **코어(Core)**가 포함되어 있으며, 이 코어들은 해당 소켓에 직접 연결된 **로컬 메모리(Local Memory)**에 매우 빠르게 접근할 수 있다.

시스템에는 두 개의 **소켓 (CPU 0, CPU 1)**이 있습니다.

* **NUMA 노드 0:** CPU 소켓 0과 그에 연결된 로컬 메모리 0
* **NUMA 노드 1:** CPU 소켓 1과 그에 연결된 로컬 메모리 1

**핵심은 이렇다:**
* **빠른 접근 (Uniform):** CPU 0의 *모든 코어*들은 로컬 메모리 0에 빠르고 균일하게 접근한다.
* **느린 접근 (Non-Uniform):** CPU 0의 코어가 CPU 1에 연결된 "원격" 메모리 1에 접근하려면, 두 소켓을 잇는 고속 인터커넥트(예: QPI, UPI, Infinity Fabric)를 거쳐야 한다. 이 접근은 로컬 메모리 접근보다 느리다.

따라서 NUMA의 "Non-Uniform(불균일)" 경계는 코어와 코어 사이가 아니라, **소켓과 소켓 사이**에서 발생한다.

**요약:**
* **CPU 소켓:** NUMA 노드를 구성하는 단위이다.
* **CPU 코어:** 하나의 NUMA 노드(소켓)에 속해 있는 개별 연산 유닛이다.  
  
  
### 5.2 프로세서 그룹 처리 (64개 이상의 프로세서)
64개를 초과하는 프로세서를 가진 시스템에서는 프로세서 그룹 개념을 사용해야 한다.
  
아래 코드는 시스템의 **프로세서 그룹(Processor Groups)** 정보를 확인하고, 64개 이상의 논리 프로세서(코어)를 가진 고성능 시스템을 올바르게 다루는 방법을 보여주는 예제이다.

  * **프로세서 그룹이란?** Windows는 64비트(`DWORD_PTR` 또는 `KAFFINITY`) 비트마스크를 사용하여 스레드가 실행될 수 있는 CPU 코어를 지정한다. 이 방식은 논리 프로세서가 64개를 초과하는 시스템(예: 128코어 서버)에서는 모든 코어를 표현할 수 없다.  
  * **해결책:** Windows는 64개가 넘는 코어들을 여러 개의 "프로세서 그룹"으로 나눈다. (예: 128코어 -> 64코어짜리 2개 그룹).
  * **이 코드의 목적:**
    1.  시스템에 몇 개의 그룹이 있는지, 각 그룹에 몇 개의 코어가 있는지 확인한다.
    2.  `SetThreadGroupAffinity` 함수를 사용하여 스레드를 *특정 그룹*의 *특정 코어*에 정확하게 고정(binding)시킨다.
    3.  스레드가 자신이 의도한 그룹과 코어에서 실행되는지 `GetCurrentProcessorNumberEx`로 확인한다.
  
  
```cpp
#include <windows.h> // Win32 API (프로세서 그룹, 스레드 관련 함수)
#include <iostream>  // C++ 표준 입출력
#include <vector>    // C++ 벡터 (스레드 핸들 저장용)

// 시스템의 프로세서 그룹 및 코어 구성을 출력하는 함수
void DisplayProcessorGroupInfo()
{
    // 1. 시스템에 활성화된 프로세서 그룹의 총 개수를 가져옵니다.
    //    (일반 PC는 1개, 64코어 초과 서버는 2개 이상일 수 있습니다)
    WORD activeGroupCount = GetActiveProcessorGroupCount();
    std::cout << "Active processor groups: " << activeGroupCount << std::endl;
    
    DWORD totalProcessors = 0; // 시스템 전체의 총 논리 프로세서 수
    
    // 2. 0번 그룹부터 마지막 그룹까지 순회
    for (WORD group = 0; group < activeGroupCount; group++)
    {
        // 3. 'group' 번호에 해당하는 그룹 *내*의 활성 프로세서(코어) 수를 가져옵니다.
        //    (이 값은 최대 64를 넘지 않습니다)
        DWORD processorsInGroup = GetActiveProcessorCount(group);
        std::cout << "Group " << group << ": " 
                  << processorsInGroup << " processors" << std::endl;
        totalProcessors += processorsInGroup;
    }
    
    std::cout << "Total processors: " << totalProcessors << std::endl;
}

// 각 스레드가 실행할 함수 (그룹 인식)
DWORD WINAPI GroupAwareThread(LPVOID lpParam)
{
    // main에서 전달받은 스레드 ID (단순 식별용)
    int threadId = (int)(INT_PTR)lpParam;
    
    // 1. 현재 스레드가 *실제로* 실행 중인 위치(그룹, 코어)를 확인
    PROCESSOR_NUMBER procNumber; // 그룹 번호와 그룹 내 코어 번호를 저장할 구조체
    
    // 2. 'Ex' (Extended) 버전의 함수를 사용해야 그룹 정보를 얻을 수 있습니다.
    //    (GetCurrentProcessorNumber()는 그룹 정보를 반환하지 않습니다)
    GetCurrentProcessorNumberEx(&procNumber);
    
    std::cout << "Thread " << threadId 
              << " running on Group " << procNumber.Group  // 현재 그룹
              << ", Processor " << (int)procNumber.Number // 그룹 내 코어 번호
              << std::endl;
    
    // 3. CPU 집약적 작업 시뮬레이션
    // 'volatile'은 컴파일러가 이 루프를 최적화(제거)하지 못하게 함
    volatile double result = 0.0;
    for (int i = 0; i < 30000000; i++) // 3천만 번 반복
    {
        result += sqrt((double)i);
    }
    
    return 0;
}

int main()
{
    // 1. 시스템의 프로세서 그룹 정보 출력
    DisplayProcessorGroupInfo();
    
    // 2. 스레드 생성을 위해 그룹 수 다시 확인
    WORD groupCount = GetActiveProcessorGroupCount();
    
    if (groupCount == 0)
    {
        std::cerr << "Failed to get processor group count" << std::endl;
        return 1;
    }
    
    std::cout << "\nCreating threads across processor groups...\n" << std::endl;
    
    std::vector<HANDLE> threads; // 생성된 스레드 핸들을 관리할 벡터
    int threadId = 0; // 스레드에 0부터 순차적으로 ID 부여
    
    // 3. 모든 프로세서 그룹을 순회
    for (WORD group = 0; group < groupCount; group++)
    {
        // 4. 현재 'group'의 코어 수 확인
        DWORD processorsInGroup = GetActiveProcessorCount(group);
        
        // 5. 데모를 위해, 각 그룹에서 최대 4개의 스레드만 생성 (너무 많이 만들지 않도록)
        DWORD threadsToCreate = min(processorsInGroup, 4);
        
        // 6. 해당 그룹의 0번 프로세서(proc)부터 순차적으로 스레드를 할당
        for (DWORD proc = 0; proc < threadsToCreate; proc++)
        {
            // 스레드 생성
            HANDLE hThread = CreateThread(
                NULL,
                0,
                GroupAwareThread,
                (LPVOID)(INT_PTR)threadId++, // 스레드 함수에 ID 전달
                CREATE_SUSPENDED,           // ★★ 중요: 스레드를 '일시 정지' 상태로 생성
                NULL
            );
            
            if (hThread == NULL)
            {
                std::cerr << "Failed to create thread" << std::endl;
                continue;
            }
            
            // 7. ★★ 핵심: 스레드를 고정시킬 위치(그룹 + 코어 마스크)를 정의
            // GROUP_AFFINITY: 64개 초과 시스템에서 친화도(Affinity)를 지정하기 위한 구조체
            GROUP_AFFINITY groupAffinity = { 0 };
            
            // 7-1. 이 스레드가 속할 그룹 번호
            groupAffinity.Group = group; 
            
            // 7-2. 이 그룹 *내*에서 사용할 코어 비트마스크 (KAFFINITY는 64비트 정수)
            // (KAFFINITY)1 << proc : 'proc' 번째 비트만 1로 켠 마스크
            // 예: proc=0 -> 0x01, proc=1 -> 0x02, proc=2 -> 0x04 ...
            groupAffinity.Mask = (KAFFINITY)1 << proc;
            
            // 8. 스레드(hThread)에 그룹 친화도(groupAffinity)를 설정
            //    (이전 예제의 SetThreadAffinityMask()는 단일 그룹(64코어 하)에서만 동작함)
            if (!SetThreadGroupAffinity(hThread, &groupAffinity, NULL))
            {
                std::cerr << "Failed to set group affinity for Group " 
                          << group << ", Processor " << proc << std::endl;
            }
            else
            {
                // (성공 시 바인딩 정보 출력)
                std::cout << "Thread " << (threadId - 1) 
                          << " bound to Group " << group 
                          << ", Processor " << proc << std::endl;
            }
            
            // 9. 친화도 설정이 완료되었으므로, '일시 정지'했던 스레드를 '재개'
            ResumeThread(hThread);
            threads.push_back(hThread); // 핸들 목록에 추가
        }
    }
    
    std::cout << "\nWaiting for all threads to complete...\n" << std::endl;
    
    // 10. 생성된 모든 스레드가 종료될 때까지 대기
    if (!threads.empty())
    {
        WaitForMultipleObjects((DWORD)threads.size(), threads.data(), TRUE, INFINITE);
        
        // 11. 리소스 정리
        for (HANDLE hThread : threads)
        {
            CloseHandle(hThread);
        }
    }
    
    std::cout << "All threads completed" << std::endl;
    
    return 0;
}
``` 
  
    
</br>  

## 6. 주의사항 및 모범 사례

### 6.1 주의사항
**과도한 어피니티 설정의 부작용**: 너무 많은 스레드를 소수의 프로세서에 할당하면 로드 밸런싱이 깨져서 오히려 성능이 저하될 수 있다. 어피니티 설정은 신중하게 사용해야 한다.

**운영체제 스케줄러와의 충돌**: Windows 스케줄러는 매우 정교하게 설계되어 있다. 불필요한 어피니티 설정은 스케줄러의 최적화를 방해할 수 있다. 실제 성능 측정을 통해 어피니티 설정의 효과를 검증해야 한다.

**하드웨어 의존성**: 어피니티 설정의 효과는 하드웨어 구성에 크게 의존한다. 특정 시스템에서 최적화된 설정이 다른 시스템에서는 비효율적일 수 있다.

**프로세스 어피니티 제약**: 스레드 어피니티는 프로세스 어피니티의 범위 내에서만 설정할 수 있다. 프로세스에 할당되지 않은 프로세서에 스레드를 할당하려고 하면 실패한다.
  

### 6.2 모범 사례

**성능 측정 우선**: 어피니티를 설정하기 전과 후의 성능을 정확히 측정한다. 실제로 성능이 향상되는 경우에만 어피니티 설정을 유지한다.

**캐시 친화성 고려**: 자주 통신하는 스레드들은 같은 프로세서나 같은 캐시를 공유하는 프로세서에 배치하여 캐시 친화성을 높인다.

**NUMA 인식**: NUMA 시스템에서는 스레드와 메모리를 같은 NUMA 노드에 배치하여 메모리 접근 지연을 최소화한다.

**동적 조정 가능성**: 시스템 부하나 작업 특성에 따라 어피니티를 동적으로 조정할 수 있도록 설계한다.

**이상적인 프로세서 활용**: 엄격한 어피니티 대신 `SetThreadIdealProcessor`를 사용하면 시스템에 힌트를 제공하면서도 유연성을 유지할 수 있다.

**프로파일링 도구 사용**: Visual Studio Profiler나 Windows Performance Analyzer 같은 도구를 사용하여 스레드의 실제 프로세서 사용 패턴을 분석한다.
  
</br>  

## 7. 정리
스레드 어피니티는 멀티코어 시스템에서 스레드의 실행 위치를 제어하여 성능을 최적화할 수 있는 강력한 기법이다. `SetThreadAffinityMask`, `SetProcessAffinityMask`, `GetProcessAffinityMask` 같은 Win32 API를 통해 프로세서 할당을 세밀하게 제어할 수 있다.

어피니티 설정은 캐시 친화성 향상, NUMA 최적화, 실시간 성능 보장, 리소스 분리 등의 목적으로 활용된다. 특히 생산자-소비자 패턴, 워커 스레드 풀, NUMA 인식 프로그래밍 등 다양한 실용적인 시나리오에서 성능 개선을 가져올 수 있다.

그러나 어피니티 설정은 신중하게 사용해야 한다. 과도한 설정은 로드 밸런싱을 방해하고 운영체제 스케줄러의 최적화를 무력화할 수 있다. 항상 실제 성능 측정을 통해 어피니티 설정의 효과를 검증하고, 하드웨어 구성과 작업 특성을 고려하여 적용해야 한다.

64개를 초과하는 프로세서를 가진 시스템에서는 프로세서 그룹 API를 사용해야 하며, NUMA 시스템에서는 NUMA 인식 API를 활용하여 최적의 성능을 달성할 수 있다.


 