# 7주차: C++ STL 스레드 프로그래밍 1

## std::thread
C++에서 스레드를 생성하는 방법은 여러 가지가 있다. std::thread 객체를 생성할 때 실행할 함수를 전달하면, 새로운 스레드가 생성되고 해당 함수가 실행된다.

### 함수 포인터를 사용한 스레드 생성
가장 기본적인 방법은 일반 함수를 스레드로 실행하는 것이다.

```
#include <iostream>
#include <thread>
#include <chrono>

// 스레드에서 실행할 함수
void workerFunction(int id, int iterations) {
    for (int i = 0; i < iterations; ++i) {
        std::cout << "Thread " << id << " is working: " << i << std::endl;
        // 작업 시뮬레이션을 위한 짧은 대기
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    std::cout << "Thread " << id << " completed!" << std::endl;
}

int main() {
    std::cout << "Main thread starting..." << std::endl;
    
    // 세 개의 스레드 생성
    std::thread t1(workerFunction, 1, 3);
    std::thread t2(workerFunction, 2, 4);
    std::thread t3(workerFunction, 3, 2);
    
    // 모든 스레드가 완료될 때까지 대기
    t1.join();
    t2.join();
    t3.join();
    
    std::cout << "All threads completed. Main thread exiting." << std::endl;
    return 0;
}
```  


### std::this_thread::get_id
* **역할**: 현재 실행 중인 스레드의 식별자(`std::thread::id`)를 반환한다.
* **시그니처/속성**: `std::thread::id get_id() noexcept` 다.
* **특징**: `std::thread::id`는 비교 연산과 스트림 출력, `std::hash`가 제공되어 맵/셋의 키로 사용할 수 있다. 같은 스레드에 대해 항상 같은 값을 반환하며 서로 다른 스레드는 서로 다른 값을 갖는다. 기본생성된 `std::thread::id{}`는 “어떤 스레드에도 속하지 않음”을 뜻하며 `std::thread{}`의 `get_id()`와 동일하다.
* **예시**:

  ```cpp
  #include <thread>
  #include <iostream>

  int main() {
    std::cout << "main id = " << std::this_thread::get_id() << '\n';
    std::thread t([]{
      std::cout << "worker id = " << std::this_thread::get_id() << '\n';
    });
    t.join();
  }
  ```

### std::this_thread::yield
* **역할**: 스케줄러에 “다른 준비된 스레드를 먼저 실행해도 된다”는 힌트를 준다. 현재 스레드의 실행을 즉시 양보하고 다시 스케줄될 수 있다.
* **시그니처/속성**: `void yield() noexcept` 다.
* **보장/주의**: 실제로 컨텍스트 스위치가 일어날지, 어느 정도 대기할지는 구현과 시스템 상태에 따라 다르다. 준비된 다른 스레드가 없으면 아무 변화가 없을 수 있다. 과도한 사용은 성능을 해칠 수 있으므로 스핀 대기에서의 백오프 단계 등에 제한적으로 쓰는 것이 좋다. 동기화에는 `condition_variable`, 세마포어, `atomic::wait/notify` 같은 프리미티브가 더 적절하다.
* **예시(스핀 대기 백오프)**:

  ```cpp
  #include <atomic>
  #include <thread>

  std::atomic<bool> ready = false;

  void wait_ready() {
    int spins = 0;
    while (!ready.load(std::memory_order_acquire)) {
      if (spins < 100) {
        ++spins; // 아주 짧게 바쁜 대기
      } else {
        std::this_thread::yield(); // 그다음엔 양보
      }
    }
  }
  ```

### std::this_thread::sleep_for
* **역할**: 현재 스레드를 **상대 시간**만큼 차단한다. 최소한 지정한 기간 동안 깨어나지 않는다.
* **시그니처/속성**:

  ```cpp
  template<class Rep, class Period>
  void sleep_for(const std::chrono::duration<Rep, Period>& rel_time);
  ```

  구현은 보통 `noexcept`로 제공하며, `rel_time <= 0`이면 즉시 반환한다.
* **보장/주의**: 스케줄링 지연, 타이머 해상도 등의 이유로 **요청한 시간보다 더 오래** 잠들 수 있다. 정확한 주기를 보장하지 않으므로, 주기 유지가 중요하면 실제 경과 시간을 측정해 보정하는 루프를 구성해야 한다. 폴링 용도로 남용하지 말고, 가능하면 조건변수나 세마포어로 이벤트를 기다리는 것이 낫다.
* **예시(60Hz 루프 보정)**:

  ```cpp
  #include <chrono>
  #include <thread>

  using clock = std::chrono::steady_clock;

  int main() {
    const auto frame = std::chrono::milliseconds(1000 / 60);
    auto next = clock::now();
    for (;;) {
      // 작업 수행
      // ...

      next += frame;
      std::this_thread::sleep_until(next); // sleep_for 대신 오차 누적을 줄인다
    }
  }
  ```
  
### std::this_thread::sleep_until
* **역할**: 현재 스레드를 **절대 시각**까지 차단한다. 지정한 시각이 도달하면 깨어난다.
* **시그니처/속성**:

  ```cpp
  template<class Clock, class Duration>
  void sleep_until(const std::chrono::time_point<Clock, Duration>& abs_time);
  ```

  `abs_time`가 이미 과거면 즉시 반환한다.
* **보장/주의**: `Clock`의 성질을 따른다. `std::chrono::steady_clock`를 쓰면 시스템 시간 조정(NTP, 사용자의 수동 시간 변경) 영향을 받지 않아 타이밍이 안정적이다. `std::chrono::system_clock`로 지정하면 시계가 뒤로/앞으로 점프할 때 대기 시간이 예상과 달라질 수 있다. 또한 스케줄링 지연으로 목표 시각 **이후**에 깨어날 수 있다.
* **예시(특정 절대 시각까지 대기)**:

  ```cpp
  #include <chrono>
  #include <thread>
  #include <iostream>

  int main() {
    using clock = std::chrono::steady_clock;
    auto wake = clock::now() + std::chrono::seconds(2);
    std::this_thread::sleep_until(wake);
    std::cout << "woke up\n";
  }
  ```

>> 작은 팁
>> * 아주 짧은 지연을 `sleep_for(1us)`처럼 요청해도 실제 대기시간은 운영체제 타이머 해상도에 의해 훨씬 길어질 수 있다. 고해상도 타이밍이 필요하면 바쁜 대기와 백오프, 또는 플랫폼의 고해상도 타이머를 검토해야 한다.
>> * 스레드 우선순위와 타이머 정확도는 운영체제마다 다르므로, 성능/정확도 요구가 높다면 대상 플랫폼에서 실측하는 것이 안전하다.
       
    
### 함수 객체(Functor)를 사용한 스레드 생성
함수 객체는 operator()를 오버로드한 클래스의 인스턴스다. 이 방법은 스레드가 실행될 때 상태를 유지할 수 있다는 장점이 있다.    
  
```
#include <iostream>
#include <thread>
#include <chrono>

// 함수 객체 클래스
class WorkerTask {
private:
    int id_;
    int iterations_;
    
public:
    WorkerTask(int id, int iterations) : id_(id), iterations_(iterations) {}
    
    // 함수 호출 연산자 오버로드
    void operator()() {
        for (int i = 0; i < iterations_; ++i) {
            std::cout << "Worker " << id_ << " processing: " << i << std::endl;
            std::this_thread::sleep_for(std::chrono::milliseconds(150));
        }
        std::cout << "Worker " << id_ << " finished!" << std::endl;
    }
};

int main() {
    std::cout << "Creating threads with functors..." << std::endl;
    
    // 함수 객체를 사용한 스레드 생성
    WorkerTask task1(1, 3);
    WorkerTask task2(2, 2);
    
    std::thread t1(task1);
    std::thread t2(task2);
    
    // 또는 임시 객체를 직접 전달
    std::thread t3(WorkerTask(3, 4));
    
    t1.join();
    t2.join();
    t3.join();
    
    std::cout << "All workers completed." << std::endl;
    return 0;
}
```  
    
  
### 람다 표현식을 사용한 스레드 생성
C++11의 람다 표현식은 스레드 생성을 더욱 간결하고 유연하게 만든다. 람다는 지역 변수를 캡처할 수 있어 매우 편리하다.
  
```
#include <iostream>
#include <thread>
#include <vector>
#include <chrono>

int main() {
    std::cout << "Creating threads with lambda expressions..." << std::endl;
    
    // 지역 변수
    int sharedValue = 100;
    std::vector<std::thread> threads;
    
    // 값으로 캡처하는 람다
    threads.emplace_back([sharedValue]() {
        std::cout << "Thread 1: Captured value = " << sharedValue << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    });
    
    // 참조로 캡처하는 람다 (주의: 동기화 필요)
    threads.emplace_back([&sharedValue]() {
        std::cout << "Thread 2: Captured reference = " << sharedValue << std::endl;
        sharedValue += 50;  // 실제로는 mutex로 보호해야 함
        std::cout << "Thread 2: Modified value to " << sharedValue << std::endl;
    });
    
    // 매개변수를 받는 람다
    auto worker = [](int id, const std::string& message) {
        for (int i = 0; i < 3; ++i) {
            std::cout << "Thread " << id << ": " << message << " (" << i << ")" << std::endl;
            std::this_thread::sleep_for(std::chrono::milliseconds(200));
        }
    };
    
    threads.emplace_back(worker, 3, "Processing data");
    threads.emplace_back(worker, 4, "Calculating results");
    
    // 모든 스레드 종료 대기
    for (auto& t : threads) {
        t.join();
    }
    
    std::cout << "Final sharedValue: " << sharedValue << std::endl;
    return 0;
}
``` 
   
  
### 스레드 매개변수 전달 방법
스레드에 매개변수를 전달할 때는 값, 참조, 포인터 방식을 사용할 수 있다. 각 방식은 장단점이 있으며, 특히 참조와 포인터를 사용할 때는 주의가 필요하다.  

```
#include <iostream>
#include <thread>
#include <string>
#include <functional>

// 값으로 받는 함수
void byValue(int x, std::string str) {
    x += 10;
    str += " modified";
    std::cout << "By value - x: " << x << ", str: " << str << std::endl;
}

// 참조로 받는 함수
void byReference(int& x, std::string& str) {
    x += 20;
    str += " changed";
    std::cout << "By reference - x: " << x << ", str: " << str << std::endl;
}

// 포인터로 받는 함수
void byPointer(int* x, std::string* str) {
    if (x && str) {
        *x += 30;
        *str += " updated";
        std::cout << "By pointer - x: " << *x << ", str: " << *str << std::endl;
    }
}

// const 참조로 받는 함수 (읽기 전용)
void byConstReference(const int& x, const std::string& str) {
    std::cout << "By const reference - x: " << x << ", str: " << str << std::endl;
}

int main() {
    int num = 100;
    std::string text = "Hello";
    
    std::cout << "Initial values - num: " << num << ", text: " << text << std::endl;
    std::cout << "----------------------------------------" << std::endl;
    
    // 1. 값으로 전달 (원본 변경 없음)
    std::thread t1(byValue, num, text);
    t1.join();
    std::cout << "After byValue - num: " << num << ", text: " << text << std::endl;
    std::cout << "----------------------------------------" << std::endl;
    
    // 2. 참조로 전달 (std::ref 필요)
    std::thread t2(byReference, std::ref(num), std::ref(text));
    t2.join();
    std::cout << "After byReference - num: " << num << ", text: " << text << std::endl;
    std::cout << "----------------------------------------" << std::endl;
    
    // 3. 포인터로 전달
    std::thread t3(byPointer, &num, &text);
    t3.join();
    std::cout << "After byPointer - num: " << num << ", text: " << text << std::endl;
    std::cout << "----------------------------------------" << std::endl;
    
    // 4. const 참조로 전달 (std::cref 사용)
    std::thread t4(byConstReference, std::cref(num), std::cref(text));
    t4.join();
    std::cout << "After byConstReference - num: " << num << ", text: " << text << std::endl;
    
    return 0;
}
```  
  
**주의사항:**
- std::thread는 기본적으로 모든 인자를 값으로 복사한다
- 참조를 전달하려면 std::ref() 또는 std::cref()를 사용해야 한다
- 포인터를 전달할 때는 포인터가 가리키는 객체의 생명주기를 주의해야 한다
- 지역 변수의 주소를 스레드에 전달할 때는 스레드가 종료되기 전에 변수가 소멸되지 않도록 주의해야 한다
  
  
</br>    
  
## std::mutex  
  
### 경쟁 상태(Race Condition)와 임계 영역
여러 스레드가 동시에 같은 데이터에 접근할 때 경쟁 상태가 발생할 수 있다. 경쟁 상태는 프로그램의 실행 결과가 스레드의 실행 순서에 따라 달라지는 현상이다.

```
     Thread 1                    Thread 2
         │                           │
         ▼                           ▼
    Read value (100)            Read value (100)
         │                           │
         ▼                           ▼
    Add 10 (110)                Add 20 (120)
         │                           │
         ▼                           ▼
    Write value (110)           Write value (120)
         │                           │
         ▼                           ▼
    
    예상 결과: 130 (100 + 10 + 20)
    실제 결과: 110 또는 120 (경쟁 상태)
```
  
  
### std::mutex 기본 사용법
뮤텍스(Mutual Exclusion)는 여러 스레드가 공유 자원에 동시에 접근하는 것을 방지하는 동기화 기법이다. std::mutex는 C++ 표준 라이브러리에서 제공하는 기본적인 뮤텍스 클래스다.

```
    Thread 1                Thread 2
        │                       │
        ▼                       ▼
    Lock Mutex              Try Lock
        │                    (Wait)
        ▼                       │
    Access Resource             │
        │                       │
        ▼                       │
    Unlock Mutex                │
        │                       ▼
        │                   Lock Mutex
        │                       │
        │                       ▼
        │                 Access Resource
        │                       │
        │                       ▼
        │                  Unlock Mutex
``` 
    
```
#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <chrono>

// 전역 뮤텍스와 공유 데이터
std::mutex mtx;
int shared_counter = 0;

// 뮤텍스를 수동으로 사용하는 방법 (권장하지 않음)
void unsafeIncrement(int id, int iterations) {
    for (int i = 0; i < iterations; ++i) {
        mtx.lock();  // 뮤텍스 잠금
        
        // 임계 영역 (Critical Section)
        int temp = shared_counter;
        temp++;
        std::this_thread::sleep_for(std::chrono::microseconds(10));
        shared_counter = temp;
        
        mtx.unlock();  // 뮤텍스 해제
    }
}

// try_lock을 사용한 비차단 잠금 시도
void tryLockExample(int id) {
    for (int attempt = 0; attempt < 5; ++attempt) {
        if (mtx.try_lock()) {
            std::cout << "Thread " << id << " acquired lock on attempt " << attempt << std::endl;
            
            // 임계 영역
            shared_counter += 10;
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            
            mtx.unlock();
            break;
        } else {
            std::cout << "Thread " << id << " failed to acquire lock on attempt " << attempt << std::endl;
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
        }
    }
}

int main() {
    std::cout << "=== Manual Mutex Usage Example ===" << std::endl;
    
    // 1. 기본 lock/unlock 사용
    shared_counter = 0;
    std::vector<std::thread> threads;
    
    for (int i = 0; i < 3; ++i) {
        threads.emplace_back(unsafeIncrement, i, 100);
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    std::cout << "Counter after manual locking: " << shared_counter << " (Expected: 300)" << std::endl;
    
    // 2. try_lock 사용 예제
    std::cout << "\n=== Try Lock Example ===" << std::endl;
    shared_counter = 0;
    threads.clear();
    
    for (int i = 0; i < 3; ++i) {
        threads.emplace_back(tryLockExample, i);
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    std::cout << "Final counter: " << shared_counter << std::endl;
    
    return 0;
}
```  
  
  
### std::lock_guard와 RAII 패턴
수동으로 lock()과 unlock()을 호출하는 것은 위험하다. 예외가 발생하거나 함수가 조기에 반환되면 unlock()이 호출되지 않아 데드락이 발생할 수 있다. **std::lock_guard는 RAII(Resource Acquisition Is Initialization) 패턴** 을 사용하여 이 문제를 해결한다.
   
```
void deposit(double amount) 
{
    std::lock_guard<std::mutex> lock(mtx_);  // 자동 잠금
    
    if (amount <= 0) {
        throw std::invalid_argument("Deposit amount must be positive");
    }
    
    double old_balance = balance_;
    balance_ += amount;
        
}  // lock_guard 소멸자에서 자동으로 unlock
```  
  
```
#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <exception>
#include <chrono>

class BankAccount {
private:
    mutable std::mutex mtx_;
    double balance_;
    std::string account_name_;
    
public:
    BankAccount(const std::string& name, double initial_balance) 
        : account_name_(name), balance_(initial_balance) {}
    
    // 입금 - lock_guard 사용
    void deposit(double amount) {
        std::lock_guard<std::mutex> lock(mtx_);  // 자동 잠금
        
        if (amount <= 0) {
            throw std::invalid_argument("Deposit amount must be positive");
        }
        
        double old_balance = balance_;
        balance_ += amount;
        
        std::cout << account_name_ << " - Deposit: $" << amount 
                  << " (Balance: $" << old_balance << " -> $" << balance_ << ")" 
                  << std::endl;
    }  // lock_guard 소멸자에서 자동으로 unlock
    
    // 출금 - lock_guard 사용
    bool withdraw(double amount) {
        std::lock_guard<std::mutex> lock(mtx_);
        
        if (amount <= 0) {
            throw std::invalid_argument("Withdrawal amount must be positive");
        }
        
        if (balance_ >= amount) {
            double old_balance = balance_;
            balance_ -= amount;
            
            std::cout << account_name_ << " - Withdraw: $" << amount 
                      << " (Balance: $" << old_balance << " -> $" << balance_ << ")" 
                      << std::endl;
            return true;
        }
        
        std::cout << account_name_ << " - Withdrawal failed: Insufficient funds" 
                  << " (Requested: $" << amount << ", Available: $" << balance_ << ")" 
                  << std::endl;
        return false;
    }
    
    // 잔액 조회 - const 메서드에서도 lock_guard 사용
    double getBalance() const {
        std::lock_guard<std::mutex> lock(mtx_);
        return balance_;
    }
    
    // 계좌 이체 - 두 개의 뮤텍스를 안전하게 관리
    static void transfer(BankAccount& from, BankAccount& to, double amount) {
        // std::lock을 사용하여 데드락 방지
        std::lock(from.mtx_, to.mtx_);
        
        // adopt_lock: 이미 잠긴 뮤텍스를 관리
        std::lock_guard<std::mutex> lock1(from.mtx_, std::adopt_lock);
        std::lock_guard<std::mutex> lock2(to.mtx_, std::adopt_lock);
        
        if (from.balance_ >= amount) {
            from.balance_ -= amount;
            to.balance_ += amount;
            
            std::cout << "Transfer: $" << amount 
                      << " from " << from.account_name_ 
                      << " to " << to.account_name_ << " successful" << std::endl;
        } else {
            std::cout << "Transfer failed: Insufficient funds in " 
                      << from.account_name_ << std::endl;
        }
    }
};

// 여러 트랜잭션을 수행하는 스레드 함수
void performTransactions(BankAccount& account, int thread_id) {
    try {
        for (int i = 0; i < 5; ++i) {
            if (i % 2 == 0) {
                account.deposit(10.0 * (thread_id + 1));
            } else {
                account.withdraw(5.0 * (thread_id + 1));
            }
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
    } catch (const std::exception& e) {
        std::cout << "Thread " << thread_id << " exception: " << e.what() << std::endl;
    }
}

int main() {
    std::cout << "=== Bank Account Thread Safety Demo ===" << std::endl;
    
    BankAccount account1("Checking", 1000.0);
    BankAccount account2("Savings", 500.0);
    
    std::cout << "\nInitial balances:" << std::endl;
    std::cout << "Checking: $" << account1.getBalance() << std::endl;
    std::cout << "Savings: $" << account2.getBalance() << std::endl;
    
    // 여러 스레드에서 동시에 계좌 작업 수행
    std::vector<std::thread> threads;
    
    for (int i = 0; i < 3; ++i) {
        threads.emplace_back(performTransactions, std::ref(account1), i);
    }
    
    // 계좌 이체 스레드
    threads.emplace_back([&account1, &account2]() {
        std::this_thread::sleep_for(std::chrono::milliseconds(250));
        BankAccount::transfer(account1, account2, 100.0);
    });
    
    for (auto& t : threads) {
        t.join();
    }
    
    std::cout << "\nFinal balances:" << std::endl;
    std::cout << "Checking: $" << account1.getBalance() << std::endl;
    std::cout << "Savings: $" << account2.getBalance() << std::endl;
    
    return 0;
}
```
  
  
### 실습: 멀티스레드 카운터 프로그램
이제 배운 내용을 종합하여 동기화된 멀티스레드 카운터 프로그램을 작성해보자. 이 프로그램은 여러 스레드가 동시에 카운터를 증가시키고, 감소시키며, 현재 값을 읽는 작업을 수행한다.
  
```
#include <iostream>
#include <thread>
#include <mutex>
#include <atomic>
#include <vector>
#include <chrono>
#include <random>
#include <iomanip>

// 스레드 안전 카운터 클래스
class ThreadSafeCounter {
private:
    mutable std::mutex mtx_;
    int value_;
    int increment_count_;
    int decrement_count_;
    int read_count_;
    
public:
    ThreadSafeCounter(int initial_value = 0) 
        : value_(initial_value), increment_count_(0), 
          decrement_count_(0), read_count_(0) {}
    
    void increment() {
        std::lock_guard<std::mutex> lock(mtx_);
        ++value_;
        ++increment_count_;
    }
    
    void decrement() {
        std::lock_guard<std::mutex> lock(mtx_);
        --value_;
        ++decrement_count_;
    }
    
    int getValue() const {
        std::lock_guard<std::mutex> lock(mtx_);
        const_cast<ThreadSafeCounter*>(this)->read_count_++;
        return value_;
    }
    
    void getStatistics(int& value, int& inc_count, int& dec_count, int& read_count) const {
        std::lock_guard<std::mutex> lock(mtx_);
        value = value_;
        inc_count = increment_count_;
        dec_count = decrement_count_;
        read_count = read_count_;
    }
};

// 작업 타입 열거형
enum class Operation {
    INCREMENT,
    DECREMENT,
    READ
};

// 워커 스레드 함수
void worker(ThreadSafeCounter& counter, int thread_id, int operations) {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> op_dist(0, 2);
    std::uniform_int_distribution<> delay_dist(1, 10);
    
    for (int i = 0; i < operations; ++i) {
        Operation op = static_cast<Operation>(op_dist(gen));
        
        switch (op) {
            case Operation::INCREMENT:
                counter.increment();
                std::cout << "[Thread " << std::setw(2) << thread_id 
                         << "] Incremented counter" << std::endl;
                break;
                
            case Operation::DECREMENT:
                counter.decrement();
                std::cout << "[Thread " << std::setw(2) << thread_id 
                         << "] Decremented counter" << std::endl;
                break;
                
            case Operation::READ:
                int value = counter.getValue();
                std::cout << "[Thread " << std::setw(2) << thread_id 
                         << "] Read value: " << value << std::endl;
                break;
        }
        
        // 랜덤 지연으로 실제 동시성 시뮬레이션
        std::this_thread::sleep_for(std::chrono::milliseconds(delay_dist(gen)));
    }
}

// 모니터링 스레드 함수
void monitor(ThreadSafeCounter& counter, std::atomic<bool>& stop_flag) {
    while (!stop_flag) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
        
        int value, inc_count, dec_count, read_count;
        counter.getStatistics(value, inc_count, dec_count, read_count);
        
        std::cout << "\n>>> Monitor Report: Value=" << value 
                  << ", Increments=" << inc_count 
                  << ", Decrements=" << dec_count 
                  << ", Reads=" << read_count 
                  << " <<<\n" << std::endl;
    }
}

int main() {
    std::cout << "=== Multi-threaded Counter Program ===" << std::endl;
    std::cout << "This program demonstrates thread-safe counter operations.\n" << std::endl;
    
    const int num_threads = 5;
    const int operations_per_thread = 10;
    
    ThreadSafeCounter counter(100);  // 초기값 100
    std::atomic<bool> stop_monitor(false);
    
    std::cout << "Starting " << num_threads << " worker threads..." << std::endl;
    std::cout << "Each thread will perform " << operations_per_thread 
              << " random operations.\n" << std::endl;
    
    // 모니터링 스레드 시작
    std::thread monitor_thread(monitor, std::ref(counter), std::ref(stop_monitor));
    
    // 워커 스레드들 시작
    auto start_time = std::chrono::high_resolution_clock::now();
    std::vector<std::thread> workers;
    
    for (int i = 0; i < num_threads; ++i) {
        workers.emplace_back(worker, std::ref(counter), i, operations_per_thread);
    }
    
    // 모든 워커 스레드 종료 대기
    for (auto& t : workers) {
        t.join();
    }
    
    auto end_time = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);
    
    // 모니터링 스레드 종료
    stop_monitor = true;
    monitor_thread.join();
    
    // 최종 통계 출력
    int final_value, total_inc, total_dec, total_reads;
    counter.getStatistics(final_value, total_inc, total_dec, total_reads);
    
    std::cout << "\n=== Final Statistics ===" << std::endl;
    std::cout << "Execution time: " << duration.count() << " ms" << std::endl;
    std::cout << "Final counter value: " << final_value << std::endl;
    std::cout << "Total increments: " << total_inc << std::endl;
    std::cout << "Total decrements: " << total_dec << std::endl;
    std::cout << "Total reads: " << total_reads << std::endl;
    std::cout << "Total operations: " << (total_inc + total_dec + total_reads) << std::endl;
    std::cout << "Expected final value: " << (100 + total_inc - total_dec) << std::endl;
    
    if (final_value == (100 + total_inc - total_dec)) {
        std::cout << "\n✓ Counter synchronization successful!" << std::endl;
    } else {
        std::cout << "\n✗ Counter synchronization failed!" << std::endl;
    }
    
    return 0;
}
```
  
  
## 고급 락 관리와 읽기-쓰기 락

### std::unique_lock의 활용과 유연한 락 관리
std::unique_lock은 std::lock_guard보다 더 유연한 락 관리를 제공한다. 락을 지연시키거나, 시간 제한을 두거나, 조건 변수와 함께 사용할 수 있다.

```
 std::lock_guard vs std::unique_lock
 
 lock_guard:                    unique_lock:
 ┌─────────────┐               ┌─────────────┐
 │  생성 시     │               │   유연한     │
 │  자동 잠금   │               │   잠금 제어   │
 ├─────────────┤               ├─────────────┤
 │  소멸 시     │               │  lock()     │
 │  자동 해제   │               │  unlock()   │
 ├─────────────┤               │  try_lock() │
 │             │               │  try_lock_  │
 │  단순하고    │               │   for()     │
 │   빠름       │               ├─────────────┤
 └─────────────┘               │ 조건변수와    │
                               │  사용 가능    │ 
                               └──────────────┘
```
  
```
#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>
#include <vector>
#include <condition_variable>

class ResourceManager {
private:
    std::mutex mtx_;
    std::condition_variable cv_;
    int resource_count_;
    bool resource_ready_;
    
public:
    ResourceManager() : resource_count_(0), resource_ready_(false) {}
    
    // 1. 지연된 잠금 (Deferred Locking)
    void deferredLockExample(int thread_id) {
        std::unique_lock<std::mutex> lock(mtx_, std::defer_lock);
        
        // 락 없이 작업 수행
        std::cout << "[Thread " << thread_id << "] Doing work without lock..." << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        
        // 필요할 때 락 획득
        lock.lock();
        std::cout << "[Thread " << thread_id << "] Lock acquired, accessing resource" << std::endl;
        resource_count_++;
        // 자동으로 unlock (RAII)
    }

    
    // 2. 시간 제한 잠금 (Timed Locking)
    void timedLockExample(int thread_id) {
        std::unique_lock<std::mutex> lock(mtx_, std::defer_lock);
        
        // 100ms 동안 락 획득 시도
        if (lock.try_lock_for(std::chrono::milliseconds(100))) {
            std::cout << "[Thread " << thread_id << "] Timed lock acquired!" << std::endl;
            resource_count_++;
            std::this_thread::sleep_for(std::chrono::milliseconds(200));
        } else {
            std::cout << "[Thread " << thread_id << "] Timed lock failed - timeout!" << std::endl;
        }
    }

    
    // 3. 조건 변수와 함께 사용
    void waitForResource(int thread_id) {
        std::unique_lock<std::mutex> lock(mtx_);
        
        std::cout << "[Thread " << thread_id << "] Waiting for resource..." << std::endl;
        
        // 조건이 충족될 때까지 대기
        cv_.wait(lock, [this] { return resource_ready_; });
        
        std::cout << "[Thread " << thread_id << "] Resource available! Processing..." << std::endl;
        resource_count_++;
    }
    
    void makeResourceReady() {
        std::this_thread::sleep_for(std::chrono::seconds(1));
        
        {
            std::lock_guard<std::mutex> lock(mtx_);
            resource_ready_ = true;
            std::cout << "[Main] Resource is now ready!" << std::endl;
        }
        
        cv_.notify_all();  // 모든 대기 중인 스레드 깨우기
    }

    
    // 4. 락 소유권 이전 (Lock Ownership Transfer)
    std::unique_lock<std::mutex> acquireLock() {
        std::unique_lock<std::mutex> lock(mtx_);
        std::cout << "Lock acquired in function" << std::endl;
        resource_count_++;
        return lock;  // 이동 생성자로 소유권 이전
    }
    
    void useLock(std::unique_lock<std::mutex> lock) {
        if (lock.owns_lock()) {
            std::cout << "Lock ownership transferred successfully" << std::endl;
            resource_count_++;
        }
    }
    

    // 5. 수동 잠금/해제
    void manualLockUnlock(int thread_id) {
        std::unique_lock<std::mutex> lock(mtx_);
        
        std::cout << "[Thread " << thread_id << "] First critical section" << std::endl;
        resource_count_++;
        
        lock.unlock();  // 수동으로 해제
        
        // 락 없이 작업
        std::cout << "[Thread " << thread_id << "] Non-critical work" << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
        
        lock.lock();  // 다시 획득
        
        std::cout << "[Thread " << thread_id << "] Second critical section" << std::endl;
        resource_count_++;
    }
    
    int getResourceCount() const {
        return resource_count_;
    }
};

int main() {
    std::cout << "=== std::unique_lock Advanced Features Demo ===" << std::endl;
    
    ResourceManager manager;
    
    // 1. Deferred Locking 테스트
    std::cout << "\n--- Deferred Locking ---" << std::endl;
    {
        std::vector<std::thread> threads;
        for (int i = 0; i < 3; ++i) {
            threads.emplace_back(&ResourceManager::deferredLockExample, &manager, i);
        }
        for (auto& t : threads) {
            t.join();
        }
    }
    
    // 2. Timed Locking 테스트
    std::cout << "\n--- Timed Locking ---" << std::endl;
    {
        std::thread t1(&ResourceManager::timedLockExample, &manager, 1);
        std::thread t2(&ResourceManager::timedLockExample, &manager, 2);
        t1.join();
        t2.join();
    }
    
    // 3. Condition Variable 테스트
    std::cout << "\n--- Condition Variable ---" << std::endl;
    {
        std::vector<std::thread> waiters;
        for (int i = 0; i < 3; ++i) {
            waiters.emplace_back(&ResourceManager::waitForResource, &manager, i);
        }
        
        std::thread notifier(&ResourceManager::makeResourceReady, &manager);
        
        for (auto& t : waiters) {
            t.join();
        }
        notifier.join();
    }
    
    // 4. Lock Ownership Transfer 테스트
    std::cout << "\n--- Lock Ownership Transfer ---" << std::endl;
    {
        auto lock = manager.acquireLock();
        manager.useLock(std::move(lock));
    }
    
    // 5. Manual Lock/Unlock 테스트
    std::cout << "\n--- Manual Lock/Unlock ---" << std::endl;
    {
        std::thread t1(&ResourceManager::manualLockUnlock, &manager, 1);
        std::thread t2(&ResourceManager::manualLockUnlock, &manager, 2);
        t1.join();
        t2.join();
    }
    
    std::cout << "\nFinal resource count: " << manager.getResourceCount() << std::endl;
    
    return 0;
}
```


### std::shared_mutex와 읽기-쓰기 락
많은 스레드가 데이터를 읽기만 하고, 가끔 쓰기 작업이 발생하는 경우, std::shared_mutex를 사용하면 성능을 크게 향상시킬 수 있다. 여러 스레드가 동시에 읽기 락을 획득할 수 있지만, 쓰기 락은 배타적이다.

```
 Shared Mutex 동작 방식
 
 읽기 스레드들 (공유 락):        쓰기 스레드 (배타적 락):
 ┌──────┐ ┌──────┐ ┌──────┐     ┌──────────┐
 │Reader│ │Reader│ │Reader│     │  Writer  │
 │  1   │ │  2   │ │  3   │     │          │
 └──┬───┘ └──┬───┘ └──┬───┘     └────┬─────┘
    │        │        │               │
    ▼        ▼        ▼               ▼
 ┌────────────────────────┐     ┌─────────┐
 │   Shared Lock (동시)    │     │Exclusive│
 │   여러 읽기 가능         │     │  Lock   │
 └────────────────────────┘     └─────────┘
            │                         │
            ▼                         ▼
     ┌──────────┐              ┌──────────┐
     │   Data   │              │   Data   │
     │  (읽기)   │              │  (쓰기)  │
     └──────────┘              └──────────┘
```

- Reader (읽기 스레드): 여러 개가 동시에 데이터에 접근할 수 있습니다. (std::shared_lock 사용)
- Writer (쓰기 스레드): 오직 하나만 데이터에 접근할 수 있으며, 이 스레드가 접근 중일 때는 다른 모든 스레드(Reader 포함)가 대기해야 한다. (std::unique_lock 사용)

#### 1. 기본 Read/Write (get/put) 데모
`shared_lock` (읽기)과 `unique_lock` (쓰기)의 가장 기본적인 사용법을 보여wns다.

**`1_basic_read_write.cpp`**

```cpp
#include <iostream>
#include <thread>
#include <shared_mutex>
#include <mutex>
#include <vector>
#include <map>
#include <string>
#include <chrono>
#include <random>
#include <iomanip>
#include <optional>

// 네임스페이스 단축
namespace ch = std::chrono;

/**
 * @brief 스레드 안전한 캐시 클래스 (std::shared_mutex 사용)
 */
template<typename Key, typename Value>
class ThreadSafeCache {
private:
    mutable std::shared_mutex mutex_;
    std::map<Key, Value> cache_;
    mutable size_t read_count_ = 0;
    mutable size_t write_count_ = 0;
    
public:
    // 읽기 작업 - 공유 락 (여러 스레드 동시 접근 가능)
    std::optional<Value> get(const Key& key) const {
        std::shared_lock<std::shared_mutex> lock(mutex_);
        read_count_++;
        std::cout << "[Cache] (Shared Lock) Reading key " << key << "..." << std::endl;
        
        auto it = cache_.find(key);
        if (it != cache_.end()) {
            std::this_thread::sleep_for(ch::milliseconds(10));
            return it->second;
        }
        return std::nullopt;
    }
    
    // 쓰기 작업 - 배타적 락 (한 번에 한 스레드만 접근 가능)
    void put(const Key& key, const Value& value) {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        write_count_++;
        std::cout << "[Cache] (Unique Lock) Writing key " << key << "..." << std::endl;
        
        std::this_thread::sleep_for(ch::milliseconds(50));
        cache_[key] = value;
    }

    // (이후 데모에서 사용될 함수들 - 지금은 필요 없지만 클래스 완결성을 위해 포함)
    void remove(const Key& key) {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        cache_.erase(key);
    }
    bool update_v1_flawed(const Key& key, const Value& new_value) { /* (데모 6 참고) */ return false; }
    bool update(const Key& key, const Value& new_value) { /* (데모 7 참고) */ return false; }

    // 캐시 내용 출력 (디버깅용)
    void print() const {
        std::shared_lock<std::shared_mutex> lock(mutex_);
        std::cout << "\n--- Cache Contents (" << cache_.size() << " items) ---" << std::endl;
        for (const auto& [key, value] : cache_) {
            std::cout << "  " << std::setw(5) << key << " -> " << value << std::endl;
        }
        std::cout << "--------------------------------\n" << std::endl;
    }
};


int main() {
    std::cout << "--- 1. 기본 Read/Write (get/put) 데모 ---" << std::endl;
    ThreadSafeCache<int, std::string> cache;
    
    std::cout << "Putting (1, 'Apple')..." << std::endl;
    cache.put(1, "Apple");
    
    std::cout << "Putting (2, 'Banana')..." << std::endl;
    cache.put(2, "Banana");
    
    cache.print();
    
    std::cout << "Getting key 1..." << std::endl;
    if (auto val = cache.get(1)) {
        std::cout << "Found: " << *val << std::endl;
    }
    
    std::cout << "Getting key 3 (not found)..." << std::endl;
    if (auto val = cache.get(3)) {
        std::cout << "Found: " << *val << std::endl;
    } else {
        std::cout << "Key 3 not found." << std::endl;
    }
    
    std::cout << "--------------------------------------" << std::endl;
    return 0;
}
```


#### "Check-then-Act"(확인 후 실행) 오류

1.  **확인 (Check):** 당신(스레드 A)이 ATM에서 계좌 잔액을 확인한다. "10만 원 있네!" (이때 **읽기 락** 🔒을 사용)
2.  **락 해제 (Release):** 확인했으니 일단 락을 푼다.
3.  **틈 (The Gap):** 😱 당신이 '출금' 버튼을 누르러 가는 **바로 그 1초 틈에...**
4.  **난입 (Interrupt):** 다른 사람(스레드 B)이 모바일 뱅킹으로 10만 원을 전부 인출해 간다. (이때 **쓰기 락** 🔑을 사용)
5.  **실행 (Act):** 당신은 "10만 원 있으니 5만 원 출금해야지"라고 생각하며 '출금' 버튼을 누른다. (다시 **쓰기 락** 🔑을 잡음)
6.  **결과:** ❌ 잔액이 0원이므로 출금에 실패한다.

**문제의 핵심:** 당신이 **확인(Check)한 시점**의 정보(10만 원)가, **실행(Act)하는 시점**에는 이미 옛날 정보가 되어버린 것이다.

```cpp
// `flawed_updater` (당신): 데이터를 "Original"인지 확인하고 "Updated"로 실행(수정)하려 한다.
// `remover` (다른 사람): 데이터를 "Empty"로 실행(수정) 한다.

#include <iostream>
#include <thread>
#include <shared_mutex>
#include <string>
#include <chrono>       // sleep_for 용
#include <iomanip>      // std::setw (출력 정렬용)

// 네임스페이스 단축
namespace ch = std::chrono;

// --- 단순화된 전역 자원 ---
std::shared_mutex mtx;
std::string shared_data;

/**
 * @brief [문제의 함수] 확인(Check)과 실행(Act) 사이에 '틈'이 있는 함수
 */
void flawed_updater() {
    // 1. 확인 (Check) - "읽기 락"
    {
        std::shared_lock lock(mtx);
        std::cout << "[Updater] (읽기 락) 데이터 확인 중...\n";
        if (shared_data != "Original") {
            std::cout << "[Updater] (읽기 락) 'Original'이 아니라서 종료.\n";
            return;
        }
        std::cout << "[Updater] (읽기 락) 'Original' 확인! 락 해제.\n";
        std::this_thread::sleep_for(ch::milliseconds(10));
    } // <-- 🔒 (읽기 락) 여기서 해제됨

    // 2. 틈 (The Gap) 😱
    //    이 함수는 쓰기 락을 잡기 전에 잠시 멈춥니다.
    //    이 '틈' 동안 다른 스레드가 끼어들 수 있습니다!
    std::cout << "[Updater] (락 없음) 쓰기 락 잡는 중... (틈 발생)\n";
    std::this_thread::sleep_for(ch::milliseconds(100)); // 틈을 인위적으로 길게 만듦

    // 3. 실행 (Act) - "쓰기 락"
    {
        std::unique_lock lock(mtx);
        std::cout << "[Updater] (쓰기 락) 'Updated'로 변경 시도...\n";
        
        // 중요: 락을 다시 잡았으면, 반드시 데이터를 '다시 확인'해야 합니다.
        if (shared_data == "Original") {
            shared_data = "Updated";
            std::cout << "[Updater] (쓰기 락) ★★★ 변경 성공! ★★★\n";
        } else {
            std::cout << "[Updater] (쓰기 락) ❌ 이런! 그새 데이터가 바뀜! ❌\n";
            std::cout << "          (현재 값: '" << shared_data << "')\n";
        }
    }
}

/**
 * @brief [난입하는 함수] 데이터를 그냥 수정하는 함수
 */
void remover() {
    std::unique_lock lock(mtx);
    std::cout << "          [Remover] (쓰기 락) 데이터 'Empty'로 변경!\n";
    shared_data = "Empty";
}

int main() {
    shared_data = "Original";
    std::cout << "--- 'Check-then-Act' 문제 데모 --- \n";
    std::cout << "Updater가 데이터를 확인(Check)한 '틈'에 Remover가 끼어들 것입니다.\n";
    std::cout << "초기 데이터: " << shared_data << "\n\n";

    // 1. Updater 스레드 시작
    std::thread updater_thread(flawed_updater);

    // 2. Updater가 '틈'에 빠질 때까지 잠시 대기 (약 30ms)
    std::this_thread::sleep_for(ch::milliseconds(30));

    // 3. Remover 스레드 시작 (바로 '틈'을 비집고 들어감)
    std::cout << "          [Main] Remover 끼어들기 시작! ->\n";
    std::thread remover_thread(remover);

    // 4. 모든 스레드 종료 대기
    updater_thread.join();
    remover_thread.join();

    std::cout << "\n--- 모든 작업 완료 --- \n";
    std::cout << "최종 데이터: '" << shared_data << "'\n";
    std::cout << "(Updater가 실패하고 'Empty'가 되어야 정상)\n";

    return 0;
}
```

예상 실행 결과

```
--- 'Check-then-Act' 문제 데모 --- 
Updater가 데이터를 확인(Check)한 '틈'에 Remover가 끼어들 것입니다.
초기 데이터: Original

[Updater] (읽기 락) 데이터 확인 중...
[Updater] (읽기 락) 'Original' 확인! 락 해제.
[Updater] (락 없음) 쓰기 락 잡는 중... (틈 발생)
          [Main] Remover 끼어들기 시작! ->
          [Remover] (쓰기 락) 데이터 'Empty'로 변경!
[Updater] (쓰기 락) 'Updated'로 변경 시도...
[Updater] (쓰기 락) ❌ 이런! 그새 데이터가 바뀜! ❌
          (현재 값: 'Empty')

--- 모든 작업 완료 --- 
최종 데이터: 'Empty'
(Updater가 실패하고 'Empty'가 되어야 정상)
```

#### "Check-then-Act" 문제: upgrade_lock 으로 해결하기

1.  **확인 (Check) - "승급용 락" 🎖️:** 당신(스레드 A)이 ATM에서 "출금할 **수도 있으니** 잔액 확인 좀 할게요"라고 요청한다. (이때 **`upgrade_lock`** 🔒 사용)
      * 이 락은 다른 **읽기 전용** 손님들(`shared_lock`)은 허용한다.
      * 하지만 다른 **쓰기** 손님(`unique_lock`)이나 **다른 승급용** 손님(`upgrade_lock`)은 막는다.
2.  **확인:** "10만 원 있네!"
3.  **승급 (Promote) - "쓰기 락" 🔑:** 당신은 락을 풀지 않고, 그 자리에서 바로 "이제 진짜 출금할게요!"라며 창구 직원에게 **`unique_lock`**으로 바꿔달라고 요청한다. (이때 `std::upgrade_to_unique_lock` 사용)
      * **틈이 없다.** 락이 풀린 적이 없기 때문이다.
      * (만약 동시에 있던 다른 '읽기' 손님들이 있다면, 그들이 나갈 때까지 잠깐 기다린 후 락을 승급시킨다.)
4.  **실행 (Act):** "5만 원 출금 완료."
5.  **결과:** ✅ 당신이 확인한 정보(10만 원)가 실행 시점에도 유효함이 보장된다. 그사이 아무도 끼어들지 못했다.
  
`flawed_updater` 대신 `correct_updater` 함수를 만들었다. `remover` 스레드는 이전과 동일하다.

```cpp
#include <iostream>
#include <thread>
#include <shared_mutex> // upgrade_lock, upgrade_to_unique_lock 포함
#include <string>
#include <chrono>       // sleep_for 용
#include <iomanip>      // std::setw (출력 정렬용)

// 네임스페이스 단축
namespace ch = std::chrono;

// --- 단순화된 전역 자원 ---
std::shared_mutex mtx;
std::string shared_data;

/**
 * @brief [해결된 함수] 'upgrade_lock'을 사용해 틈(Gap) 없이 안전하게 업데이트
 */
void correct_updater() {
    
    // 1. 확인 (Check) - "승급용 락" 🎖️
    //    (다른 shared_lock은 허용, unique/upgrade 락은 차단)
    std::upgrade_lock<std::shared_mutex> lock(mtx);
    std::cout << "[Updater] (Upgrade Lock 🎖️) 데이터 확인 중...\n";

    if (shared_data != "Original") {
        std::cout << "[Updater] (Upgrade Lock 🎖️) 'Original'이 아니라서 종료.\n";
        return; // 락 자동 해제
    }

    std::cout << "[Updater] (Upgrade Lock 🎖️) 'Original' 확인! 쓰기 락으로 승급 시도...\n";
    std::this_thread::sleep_for(ch::milliseconds(10));

    // 2. 승급 (Promote) & 3. 실행 (Act) - "쓰기 락" 🔑
    //    (락을 풀지 않고, 그 자리에서 바로 'unique_lock'으로 승급)
    std::upgrade_to_unique_lock<std::shared_mutex> unique_lock(std::move(lock));
    
    std::cout << "[Updater] (Unique Lock 🔑) ★★★ 승급 성공! 변경 실행! ★★★\n";
    shared_data = "Updated";
    std::cout << "[Updater] (Unique Lock 🔑) 변경 완료. 락 해제.\n";
    std::this_thread::sleep_for(ch::milliseconds(50));
    
    // 'unique_lock'이 여기서 해제됨 (원래 'lock'도 같이)
}

/**
 * @brief [수정 함수] 데이터를 그냥 수정하는 함수 (이전과 동일)
 */
void remover() {
    // 'correct_updater'가 락을 잡고 있으므로(Upgrade든 Unique든) 대기해야 함
    std::cout << "          [Remover] (대기 중) 쓰기 락 🔑 요청...\n";
    std::unique_lock lock(mtx);
    std::cout << "          [Remover] (쓰기 락 🔑) 획득! 'Empty'로 변경!\n";
    shared_data = "Empty";
}

int main() {
    shared_data = "Original";
    std::cout << "--- 'upgrade_lock' 해결 데모 --- \n";
    std::cout << "Updater가 락을 승급하는 동안 Remover는 끼어들지 못하고 대기합니다.\n";
    std::cout << "초기 데이터: " << shared_data << "\n\n";

    // 1. Updater 스레드 시작
    std::thread updater_thread(correct_updater);

    // 2. Updater가 'upgrade_lock'을 잡을 시간을 줌
    std::this_thread::sleep_for(ch::milliseconds(5));

    // 3. Remover 스레드 시작 (Updater가 락을 쥐고 있으므로 대기함)
    std::cout << "          [Main] Remover 시작 (대기해야 함) ->\n";
    std::thread remover_thread(remover);

    // 4. 모든 스레드 종료 대기
    updater_thread.join();
    remover_thread.join();

    std::cout << "\n--- 모든 작업 완료 --- \n";
    std::cout << "최종 데이터: '" << shared_data << "'\n";
    std::cout << "(Updater가 먼저 성공('Updated')하고, Remover가 덮어써('Empty')야 정상)\n";

    return 0;
}
```

  
### 데드락 방지 기법과 std::lock()
데드락은 두 개 이상의 스레드가 서로가 보유한 리소스를 기다리며 무한 대기하는 상황이다. C++는 std::lock()과 std::scoped_lock을 제공하여 데드락을 방지한다.

`std::lock()` 함수는 **여러 개의 뮤텍스(mutex)를 한꺼번에 잠글 때** 사용한다.

가장 중요한 기능은 **교착 상태(Deadlock)를 방지**해준다는 것이다.

#### 🤷‍♂️ 이게 왜 필요한가? (교착 상태 문제)
만약 두 개의 뮤텍스 `m1`과 `m2`가 있고, 두 스레드가 이 락을 잡으려 한다고 가정해 보자.

  * **스레드 1:** `m1`을 잠그고 ➡️ `m2`를 잠그려 함
  * **스레드 2:** `m2`를 잠그고 ➡️ `m1`을 잠그려 함 (순서가 반대)

운이 나쁘면 이런 상황이 발생한다:

1.  스레드 1이 `m1`을 잠근다. 🔒
2.  동시에 스레드 2가 `m2`를 잠근다. 🔑
3.  스레드 1은 `m2`가 풀리기를 영원히 기다리고, 스레드 2는 `m1`이 풀리기를 영원히 기다린다.
4.  ❌ **교착 상태 (Deadlock) 발생\!** 프로그램이 멈춘다.

#### ✅ `std::lock()`의 해결책
`std::lock(m1, m2);`는 **"전부 다 잠그거나, 아니면 하나도 잠그지 않거나"** 방식으로 동작한다.

`std::lock()`은 내부적으로 데드락을 피하는 알고리즘(예: 락을 순서대로 정렬해서 잡기)을 사용해서, 두 뮤텍스를 한 번에 잠근 것처럼 처리해 준다. 위와 같은 교착 상태가 절대로 발생하지 않는다.


#### 사용 방법 (RAII)
`std::lock()` 함수는 락을 **잠그기만** 할 뿐, **자동으로 해제해주지 않는다.**

```cpp
// ❌ 나쁜 방법: 직접 unlock()을 호출해야 해서 잊어버리기 쉽습니다.
std::lock(m1, m2);
// ... 위험한 작업 ...
if (/*...*/) {
    m1.unlock(); // 여기서 unlock()을 잊으면 큰일!
    m2.unlock();
    return;
}
m1.unlock();
m2.unlock();
```

따라서 `std::lock_guard`와 `std::adopt_lock` 태그를 함께 쓰는 것이 정석이다.

```cpp
#include <mutex>
#include <thread>

std::mutex m1;
std::mutex m2;

void safe_function() {
    // 1. 먼저 데드락 방지 잠금을 실행
    std::lock(m1, m2);

    // 2. 락의 "소유권"만 lock_guard에게 넘김 (adopt_lock)
    // (adopt_lock: "이미 잠겨있으니 다시 잠그지 말고, 끝나면 '풀어주기'만 해")
    std::lock_guard<std::mutex> guard1(m1, std::adopt_lock);
    std::lock_guard<std::mutex> guard2(m2, std::adopt_lock);

    // ... m1과 m2가 모두 필요한 안전한 작업 ...

} // <-- 함수가 끝나면 guard1, guard2가 자동으로 m1, m2를 unlock() 해줌
```

#### C++17 이상: 더 쉬운 방법 `std::scoped_lock`
C++17부터는 이 모든 과정을 한 번에 해주는 `std::scoped_lock`이 있습니다. **이것을 쓰는 것이 가장 좋다.**

`std::scoped_lock`은 생성자에서 `std::lock()`과 같은 방식으로 모든 뮤텍스를 잠그고, 소멸자에서 모든 락을 자동으로 해제(unlock)한다.

```cpp
#include <mutex>
#include <thread>

std::mutex m1;
std::mutex m2;

void best_safe_function() {
    // 1. 생성자에서 m1, m2를 데드락 없이 한 번에 잠금
    std::scoped_lock lock(m1, m2); 

    // ... m1과 m2가 모두 필요한 안전한 작업 ...

} // <-- 함수가 끝나면 lock이 자동으로 m1, m2를 unlock() 해줌
```

**요약:**
* **`std::lock`**: 여러 뮤텍스를 **데드락 없이** 잠가주는 *함수*. (수동 해제 필요)
* **`std::scoped_lock`**: 여러 뮤텍스를 **데드락 없이** 잠그고 *자동으로 해제*해주는 *클래스*. (C++17 이상 권장)

      
### 스레드 생명주기 관리
스레드의 생명주기를 올바르게 관리하는 것은 안정적인 멀티스레드 프로그램 작성의 핵심이다. join(), detach(), joinable() 메서드를 적절히 사용해야 한다.

```
 스레드 생명주기 상태:
 
    [생성]
      │
      ▼
 ┌─────────┐
 │Joinable │ ──────► detach() ──────► [Detached]
 │ 상태    │                          (독립 실행)
 └─────────┘
      │
      ▼
   join()
      │
      ▼
  [Joined]
 (종료 대기)
```
    

#### `join()`  

**`1_join_demo.cpp`**

```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <string>
#include <mutex>

// 스레드 안전한 로깅을 위한 뮤텍스
std::mutex cout_mutex;

void safe_print(const std::string& msg) {
    std::lock_guard<std::mutex> lock(cout_mutex);
    std::cout << msg << std::endl;
}

// 스레드가 실행할 작업 함수
void shortTask(int id) {
    safe_print("Short task " + std::to_string(id) + " started");
    std::this_thread::sleep_for(std::chrono::milliseconds(500));
    safe_print("Short task " + std::to_string(id) + " completed");
}

int main() {
    std::cout << "\n=== 1. join() Demonstration ===" << std::endl;
    std::cout << "join()은 스레드가 완료될 때까지 메인 스레드를 차단(block)합니다.\n" << std::endl;
    
    std::thread t1(shortTask, 1);
    std::cout << "Main: 스레드 생성됨. Joinable? " << (t1.joinable() ? "Yes" : "No") << std::endl;
    
    std::cout << "Main: t1이 완료될 때까지 대기합니다..." << std::endl;
    
    // t1 스레드가 종료될 때까지 여기서 대기합니다.
    t1.join(); 
    
    std::cout << "Main: t1.join() 완료됨." << std::endl;
    std::cout << "Main: join() 호출 후 Joinable? " << (t1.joinable() ? "Yes" : "No") << std::endl;
    
    return 0;
}
```


#### `detach()` (독립 실행)

**`2_detach_demo.cpp`**

```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <string>
#include <mutex>
#include <atomic> // std::atomic

// 스레드 안전한 로깅
std::mutex cout_mutex;
void safe_print(const std::string& msg) {
    std::lock_guard<std::mutex> lock(cout_mutex);
    std::cout << msg << std::endl;
}

// 백그라운드에서 오래 실행될 작업
void longTask(int id, std::atomic<bool>& should_stop) {
    safe_print("Long task " + std::to_string(id) + " started (백그라운드 실행)");
    
    // should_stop 플래그가 true가 될 때까지 100ms마다 체크
    while (!should_stop) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    
    safe_print("Long task " + std::to_string(id) + " stopped");
}

int main() {
    std::cout << "\n=== 2. detach() Demonstration ===" << std::endl;
    std::cout << "detach()는 스레드를 메인 스레드와 분리하여 독립적으로 실행시킵니다.\n" << std::endl;
    
    // 분리된 스레드를 제어하기 위한 플래그
    std::atomic<bool> stop_flag(false);
    
    std::thread t2(longTask, 2, std::ref(stop_flag));
    std::cout << "Main: 스레드 생성됨. Joinable? " << (t2.joinable() ? "Yes" : "No") << std::endl;
    
    // 스레드를 분리합니다.
    // 이제 t2 객체는 더 이상 실제 실행 스레드를 참조하지 않습니다.
    t2.detach(); 
    
    std::cout << "Main: 스레드 분리됨. Joinable? " << (t2.joinable() ? "Yes" : "No") << std::endl;
    
    std::cout << "Main: 0.5초 대기... (백그라운드 스레드는 계속 실행 중)" << std::endl;
    std::this_thread::sleep_for(std::chrono::milliseconds(500));
    
    std::cout << "Main: 백그라운드 스레드에 종료 신호 전송" << std::endl;
    stop_flag = true; // 스레드에 종료를 알림
    
    // 분리된 스레드가 완전히 종료될 시간을 줍니다.
    // (이걸 안 해주면 main이 먼저 끝나서 스레드가 강제 종료될 수 있음)
    std::this_thread::sleep_for(std::chrono::milliseconds(200));
    
    std::cout << "Main: 프로그램 종료." << std::endl;
    return 0;
}
```


#### `joinable()` 체크 

**`3_joinable_demo.cpp`**

```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <string>
#include <mutex>
#include <vector> // std::move 용

// 스레드 안전한 로깅
std::mutex cout_mutex;
void safe_print(const std::string& msg) {
    std::lock_guard<std::mutex> lock(cout_mutex);
    std::cout << msg << std::endl;
}

void shortTask(int id) {
    safe_print("Short task " + std::to_string(id) + " started/completed");
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
}

int main() {
    std::cout << "\n=== 3. joinable() Demonstration ===" << std::endl;
    std::cout << "join()이나 detach() 전에 항상 joinable()을 체크해야 합니다.\n" << std::endl;
    
    // Case 1: 기본 생성된 스레드 (실행 중이 아님)
    std::thread t1;
    std::cout << "Case 1: 기본 생성된 t1. Joinable? " 
              << (t1.joinable() ? "Yes" : "No") << std::endl;
    
    // Case 2: 작업이 완료되고 join()된 스레드
    std::thread t2(shortTask, 2);
    t2.join(); // 여기서 join
    std::cout << "Case 2: join()이 완료된 t2. Joinable? " 
              << (t2.joinable() ? "Yes" : "No") << std::endl;
    
    // Case 3: 작업이 완료되고 detach()된 스레드
    std::thread t3(shortTask, 3);
    t3.detach(); // 여기서 detach
    std::cout << "Case 3: detach()가 완료된 t3. Joinable? " 
              << (t3.joinable() ? "Yes" : "No") << std::endl;
              
    // Case 4: 소유권이 이전된(moved) 스레드
    std::thread t4(shortTask, 4);
    std::thread t5 = std::move(t4); // t4의 소유권이 t5로 이동
    std::cout << "Case 4: 소유권 이전 후 t4. Joinable? " << (t4.joinable() ? "Yes" : "No") << std::endl;
    std::cout << "Case 4: 소유권 이전 후 t5. Joinable? " << (t5.joinable() ? "Yes" : "No") << std::endl;
    
    if (t5.joinable()) {
        t5.join();
    }
    
    // 결론: joinable()이 false인 스레드에 join()을 호출하면 에러가 발생합니다.
    // if (t1.joinable()) t1.join(); // 항상 이렇게 체크
    
    return 0;
}
```

#### RAII (`ThreadGuard`) 

**`4_raii_guard_demo.cpp`**

```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <string>
#include <mutex>
#include <exception> // std::exception

// 스레드 안전한 로깅
std::mutex cout_mutex;
void safe_print(const std::string& msg) {
    std::lock_guard<std::mutex> lock(cout_mutex);
    std::cout << msg << std::endl;
}

void shortTask(int id) {
    safe_print("Task " + std::to_string(id) + " started");
    std::this_thread::sleep_for(std::chrono::milliseconds(500));
    safe_print("Task " + std::to_string(id) + " completed");
}

/**
 * @brief RAII 기법을 사용한 스레드 관리 클래스
 * 이 객체가 소멸(파괴)될 때, 자신이 감싸고(guard) 있던 스레드를
 * 자동으로 join()합니다.
 */
class ThreadGuard {
private:
    std::thread& thread_;
    
public:
    // 생성자: 관리할 스레드의 참조를 받습니다.
    explicit ThreadGuard(std::thread& t) : thread_(t) {}
    
    // 소멸자: 객체가 스코프를 벗어날 때 호출됩니다.
    ~ThreadGuard() {
        // 스레드가 여전히 join 가능한 상태인지(join/detach되지 않았는지) 확인
        if (thread_.joinable()) {
            thread_.join(); // 안전하게 join
            safe_print("ThreadGuard: 소멸자에서 스레드를 join() 했습니다.");
        }
    }
    
    // 복사 생성자/대입 연산자 삭제 (소유권 관리 단순화)
    ThreadGuard(const ThreadGuard&) = delete;
    ThreadGuard& operator=(const ThreadGuard&) = delete;
};

int main() {
    std::cout << "\n=== 4. RAII Thread Management ===" << std::endl;
    std::cout << "ThreadGuard는 예외가 발생해도 스레드가 안전하게 join()되도록 보장합니다.\n" << std::endl;
    
    try {
        std::thread t(shortTask, 1);
        
        // t 스레드를 관리하는 ThreadGuard 객체 생성
        // main 함수가 어떻게 종료되든(정상 종료 or 예외 발생)
        // 'guard' 객체가 파괴될 때 t.join()이 호출됩니다.
        ThreadGuard guard(t);
        
        // 여기서 예외를 강제로 발생시킵니다.
        safe_print("Main: 예외(exception)를 강제로 발생시킵니다!");
        throw std::runtime_error("시뮬레이션된 에러!");
        
        // 이 코드는 실행되지 않습니다.
        safe_print("Main: 이 메시지는 출력되지 않습니다.");
        
    } catch (const std::exception& e) {
        safe_print("Main: 예외를 catch했습니다: " + std::string(e.what()));
    }
    
    safe_print("Main: 프로그램 종료. (예외 발생 후에도 join()이 호출되었습니다)");
    return 0;
}
```


#### 스레드 풀 (간단한 구현) 

**`5_thread_pool_demo.cpp`**

```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <string>
#include <mutex>
#include <vector>
#include <atomic> // std::atomic

// 스레드 안전한 로깅
std::mutex cout_mutex;
void safe_print(const std::string& msg) {
    std::lock_guard<std::mutex> lock(cout_mutex);
    std::cout << msg << std::endl;
}

/**
 * @brief 간단한 스레드 풀 클래스
 * 큐(Queue) 없이, 정해진 수의 스레드가 멈춤 신호(stop_)가 올 때까지
 * 대기하는 가장 단순한 형태의 풀입니다.
 */
class SimpleThreadPool {
private:
    // 일꾼(worker) 스레드들을 저장하는 벡터
    std::vector<std::thread> workers_;
    // 모든 스레드를 중지시키기 위한 플래그
    std::atomic<bool> stop_;

    // 각 스레드가 실행할 함수
    void workerFunction(size_t id) {
        safe_print("Worker " + std::to_string(id) + " started");
        
        // stop_ 플래그가 false인 동안 계속 루프
        while (!stop_) {
            // 실제로는 여기서 '작업 큐'에서 작업을 가져와야 함
            // 지금은 그냥 대기
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
        
        safe_print("Worker " + std::to_string(id) + " stopped");
    }

public:
    // 생성자: 지정된 수(num_threads)만큼 스레드를 생성
    SimpleThreadPool(size_t num_threads) : stop_(false) {
        for (size_t i = 0; i < num_threads; ++i) {
            // emplace_back: 벡터에 직접 스레드 객체를 생성
            workers_.emplace_back([this, i]() {
                this->workerFunction(i);
            });
        }
        safe_print("Thread pool created with " + std::to_string(num_threads) + " threads");
    }
    
    // 소멸자: 스레드 풀이 파괴될 때
    ~SimpleThreadPool() {
        safe_print("Thread pool destroying...
모든 worker 스레드에 종료 신호 전송.");
        
        // 1. 모든 스레드에 'stop_' 신호를 보냄
        stop_ = true;
        
        // 2. 모든 스레드가 종료될 때까지 join()
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
        safe_print("Thread pool destroyed, all threads joined");
    }
};

int main() {
    std::cout << "\n=== 5. Thread Pool Demo ===" << std::endl;
    std::cout << "스레드 풀 객체가 생성될 때 스레드들이 시작되고,\n";
    std::cout << "객체가 소멸될(스코프를 벗어날) 때 스레드들이 정리(join)됩니다.\n" << std::endl;
    
    // 이 중괄호 { } 스코프 안에서만 pool 객체가 살아있습니다.
    {
        SimpleThreadPool pool(3); // 3개의 스레드로 풀 생성
        
        std::cout << "Main: 스레드 풀이 0.5초간 작동합니다..." << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
        
        std::cout << "Main: 스코프( } )를 곧 벗어납니다. (pool 객체 소멸자 호출됨)" << std::endl;
    } // <-- 이 지점에서 pool 객체가 소멸되면서 ~SimpleThreadPool() 호출
    
    std::cout << "Main: 스레드 풀 소멸 완료. 프로그램 종료." << std::endl;
    return 0;
}
```


#### 스레드 소유권 이전 (`std::move`) 

**`6_move_ownership_demo.cpp`**

```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <string>
#include <mutex>
#include <vector> // std::move

// 스레드 안전한 로깅
std::mutex cout_mutex;
void safe_print(const std::string& msg) {
    std::lock_guard<std::mutex> lock(cout_mutex);
    std::cout << msg << std::endl;
}

void shortTask(int id) {
    safe_print("Task " + std::to_string(id) + " started");
    std::this_thread::sleep_for(std::chrono::milliseconds(200));
    safe_print("Task " + std::to_string(id) + " completed");
}

int main() {
    std::cout << "\n=== 6. Thread Ownership Transfer (std::move) ===" << std::endl;
    std::cout << "std::thread 객체는 복사할 수 없고, 오직 '이동(move)'만 가능합니다.\n" << std::endl;

    std::thread t1(shortTask, 1);
    std::cout << "Main: t1 생성됨. t1 joinable? " << t1.joinable() << std::endl;

    // std::thread t2 = t1; // <-- 컴파일 에러! (복사 생성자 삭제됨)

    // std::move()를 사용해 t1의 소유권(실행 중인 스레드에 대한 제어권)을 t2로 이전
    std::thread t2 = std::move(t1);
    
    std::cout << "Main: t1의 소유권을 t2로 이동시킴" << std::endl;
    
    // 소유권을 잃은 t1은 더 이상 joinable()이 아님 (빈 껍데기)
    std::cout << "  t1.joinable() (소유권 잃음)? " << t1.joinable() << std::endl;
    // 소유권을 얻은 t2가 joinable()이 됨
    std::cout << "  t2.joinable() (소유권 얻음)? " << t2.joinable() << std::endl;
    
    // t1.join(); // <-- 에러 발생 (joinable()이 아님)
    
    // t2를 join해야 함
    if (t2.joinable()) {
        safe_print("Main: t2를 join합니다.");
        t2.join();
    }
    
    return 0;
}
```

  
### 실습: 읽기-쓰기 락을 활용한 스레드 안전 데이터 저장소
마지막으로 배운 모든 개념을 종합하여 실용적인 스레드 안전 데이터 저장소를 구현해보자. 이 저장소는 읽기-쓰기 락을 사용하여 높은 성능을 제공한다.
  
```
#include <iostream>
#include <thread>
#include <shared_mutex>
#include <mutex>
#include <unordered_map>
#include <vector>
#include <string>
#include <chrono>
#include <random>
#include <atomic>
#include <memory>
#include <optional>
#include <iomanip>

// 데이터 항목
struct DataItem {
    std::string value;
    std::chrono::system_clock::time_point last_modified;
    int version;
    
    DataItem(const std::string& val) 
        : value(val), 
          last_modified(std::chrono::system_clock::now()), 
          version(1) {}
};

// 스레드 안전 데이터 저장소
template<typename Key, typename Value>
class ThreadSafeDataStore {
private:
    mutable std::shared_mutex mutex_;
    std::unordered_map<Key, std::shared_ptr<Value>> data_;
    
    // 통계
    mutable std::atomic<size_t> read_count_{0};
    mutable std::atomic<size_t> write_count_{0};
    mutable std::atomic<size_t> cache_hits_{0};
    mutable std::atomic<size_t> cache_misses_{0};
    
    // 캐시 (최근 읽은 항목)
    mutable std::unordered_map<Key, std::weak_ptr<Value>> cache_;
    
public:
    // 데이터 삽입/업데이트
    void put(const Key& key, const Value& value) {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        write_count_++;
        
        auto it = data_.find(key);
        if (it != data_.end()) {
            // 업데이트
            it->second = std::make_shared<Value>(value);
        } else {
            // 새로 삽입
            data_[key] = std::make_shared<Value>(value);
        }
        
        // 캐시 무효화
        cache_.erase(key);
    }
    
    // 데이터 읽기
    std::optional<Value> get(const Key& key) const {
        // 먼저 캐시 확인 (읽기 락 없이)
        {
            auto cache_it = cache_.find(key);
            if (cache_it != cache_.end()) {
                if (auto cached = cache_it->second.lock()) {
                    cache_hits_++;
                    read_count_++;
                    return *cached;
                }
            }
        }
        
        // 캐시 미스 - 실제 데이터 읽기
        std::shared_lock<std::shared_mutex> lock(mutex_);
        cache_misses_++;
        read_count_++;
        
        auto it = data_.find(key);
        if (it != data_.end()) {
            cache_[key] = it->second;  // 캐시에 저장
            return *(it->second);
        }
        
        return std::nullopt;
    }
    
    // 조건부 업데이트 (Compare and Swap)
    bool update(const Key& key, const Value& old_value, const Value& new_value) {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        write_count_++;
        
        auto it = data_.find(key);
        if (it != data_.end() && *(it->second) == old_value) {
            it->second = std::make_shared<Value>(new_value);
            cache_.erase(key);
            return true;
        }
        
        return false;
    }
    
    // 데이터 삭제
    bool remove(const Key& key) {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        write_count_++;
        
        cache_.erase(key);
        return data_.erase(key) > 0;
    }
    
    // 여러 키 동시 읽기
    std::vector<std::pair<Key, Value>> getMultiple(const std::vector<Key>& keys) const {
        std::shared_lock<std::shared_mutex> lock(mutex_);
        read_count_ += keys.size();
        
        std::vector<std::pair<Key, Value>> results;
        for (const auto& key : keys) {
            auto it = data_.find(key);
            if (it != data_.end()) {
                results.emplace_back(key, *(it->second));
            }
        }
        
        return results;
    }
    
    // 범위 쿼리 (조건에 맞는 모든 항목)
    template<typename Predicate>
    std::vector<std::pair<Key, Value>> findWhere(Predicate pred) const {
        std::shared_lock<std::shared_mutex> lock(mutex_);
        
        std::vector<std::pair<Key, Value>> results;
        for (const auto& [key, value_ptr] : data_) {
            if (pred(key, *value_ptr)) {
                results.emplace_back(key, *value_ptr);
                read_count_++;
            }
        }
        
        return results;
    }
    
    // 원자적 작업 - 값 증가
    bool increment(const Key& key, int delta = 1) {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        write_count_++;
        
        auto it = data_.find(key);
        if (it != data_.end()) {
            // Value가 int 타입이라고 가정
            if constexpr (std::is_same_v<Value, int>) {
                *(it->second) += delta;
                cache_.erase(key);
                return true;
            }
        }
        
        return false;
    }
    
    // 통계 정보
    void getStats(size_t& reads, size_t& writes, size_t& hits, size_t& misses, size_t& size) const {
        std::shared_lock<std::shared_mutex> lock(mutex_);
        reads = read_count_;
        writes = write_count_;
        hits = cache_hits_;
        misses = cache_misses_;
        size = data_.size();
    }
    
    // 모든 데이터 클리어
    void clear() {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        data_.clear();
        cache_.clear();
    }
    
    size_t size() const {
        std::shared_lock<std::shared_mutex> lock(mutex_);
        return data_.size();
    }
};

// 테스트용 워커 스레드
class DataStoreWorker {
private:
    ThreadSafeDataStore<std::string, DataItem>& store_;
    int id_;
    std::mt19937 gen_;
    
public:
    DataStoreWorker(ThreadSafeDataStore<std::string, DataItem>& store, int id)
        : store_(store), id_(id), gen_(std::random_device{}()) {}
    
    void runReader(int operations) {
        std::uniform_int_distribution<> key_dist(0, 99);
        
        for (int i = 0; i < operations; ++i) {
            std::string key = "key_" + std::to_string(key_dist(gen_));
            
            auto value = store_.get(key);
            if (value) {
                std::cout << "[Reader " << id_ << "] Found " << key 
                         << " = " << value->value 
                         << " (v" << value->version << ")" << std::endl;
            }
            
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
    }
    
    void runWriter(int operations) {
        std::uniform_int_distribution<> key_dist(0, 99);
        
        for (int i = 0; i < operations; ++i) {
            std::string key = "key_" + std::to_string(key_dist(gen_));
            std::string value = "value_from_writer_" + std::to_string(id_) + "_" + std::to_string(i);
            
            store_.put(key, DataItem(value));
            std::cout << "[Writer " << id_ << "] Wrote " << key 
                     << " = " << value << std::endl;
            
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
        }
    }
    
    void runUpdater(int operations) {
        std::uniform_int_distribution<> key_dist(0, 99);
        
        for (int i = 0; i < operations; ++i) {
            std::string key = "key_" + std::to_string(key_dist(gen_));
            
            auto current = store_.get(key);
            if (current) {
                DataItem new_item = *current;
                new_item.value += "_updated";
                new_item.version++;
                new_item.last_modified = std::chrono::system_clock::now();
                
                if (store_.update(key, *current, new_item)) {
                    std::cout << "[Updater " << id_ << "] Updated " << key 
                             << " to version " << new_item.version << std::endl;
                }
            }
            
            std::this_thread::sleep_for(std::chrono::milliseconds(30));
        }
    }
};

// 성능 벤치마크
void performanceBenchmark() {
    std::cout << "\n=== Performance Benchmark ===" << std::endl;
    
    ThreadSafeDataStore<int, int> int_store;
    
    // 초기 데이터 삽입
    for (int i = 0; i < 1000; ++i) {
        int_store.put(i, i * 10);
    }
    
    const int num_threads = 8;
    const int operations_per_thread = 1000;
    
    auto start = std::chrono::high_resolution_clock::now();
    
    std::vector<std::thread> threads;
    
    // 읽기 중심 워크로드 (80% 읽기, 20% 쓰기)
    for (int i = 0; i < num_threads; ++i) {
        if (i < num_threads * 0.8) {
            // 읽기 스레드
            threads.emplace_back([&int_store, i, operations_per_thread]() {
                std::mt19937 gen(i);
                std::uniform_int_distribution<> dist(0, 999);
                
                for (int j = 0; j < operations_per_thread; ++j) {
                    int_store.get(dist(gen));
                }
            });
        } else {
            // 쓰기 스레드
            threads.emplace_back([&int_store, i, operations_per_thread]() {
                std::mt19937 gen(i);
                std::uniform_int_distribution<> dist(0, 999);
                
                for (int j = 0; j < operations_per_thread; ++j) {
                    int key = dist(gen);
                    int_store.put(key, key * 20 + j);
                }
            });
        }
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    size_t reads, writes, hits, misses, size;
    int_store.getStats(reads, writes, hits, misses, size);
    
    std::cout << "Benchmark Results:" << std::endl;
    std::cout << "  Duration: " << duration.count() << " ms" << std::endl;
    std::cout << "  Total operations: " << (reads + writes) << std::endl;
    std::cout << "  Operations/sec: " 
              << (reads + writes) * 1000.0 / duration.count() << std::endl;
    std::cout << "  Read operations: " << reads << std::endl;
    std::cout << "  Write operations: " << writes << std::endl;
    std::cout << "  Cache hit rate: " 
              << (hits * 100.0 / (hits + misses)) << "%" << std::endl;
}

int main() {
    std::cout << "=== Thread-Safe Data Store with Read-Write Locks ===" << std::endl;
    
    ThreadSafeDataStore<std::string, DataItem> store;
    
    // 초기 데이터 삽입
    std::cout << "\nInserting initial data..." << std::endl;
    for (int i = 0; i < 20; ++i) {
        std::string key = "key_" + std::to_string(i);
        store.put(key, DataItem("initial_value_" + std::to_string(i)));
    }
    std::cout << "Initial data size: " << store.size() << std::endl;
    
    // 동시 읽기/쓰기 테스트
    std::cout << "\n--- Concurrent Read/Write Test ---" << std::endl;
    
    std::vector<std::thread> threads;
    std::vector<std::unique_ptr<DataStoreWorker>> workers;
    
    // 읽기 워커 (많음)
    for (int i = 0; i < 3; ++i) {
        workers.push_back(std::make_unique<DataStoreWorker>(store, i));
        threads.emplace_back(&DataStoreWorker::runReader, workers.back().get(), 5);
    }
    
    // 쓰기 워커 (적음)
    for (int i = 3; i < 5; ++i) {
        workers.push_back(std::make_unique<DataStoreWorker>(store, i));
        threads.emplace_back(&DataStoreWorker::runWriter, workers.back().get(), 3);
    }
    
    // 업데이트 워커
    for (int i = 5; i < 6; ++i) {
        workers.push_back(std::make_unique<DataStoreWorker>(store, i));
        threads.emplace_back(&DataStoreWorker::runUpdater, workers.back().get(), 4);
    }
    
    // 모든 스레드 종료 대기
    for (auto& t : threads) {
        t.join();
    }
    
    // 최종 통계
    size_t reads, writes, hits, misses, size;
    store.getStats(reads, writes, hits, misses, size);
    
    std::cout << "\n=== Final Statistics ===" << std::endl;
    std::cout << "Store size: " << size << " items" << std::endl;
    std::cout << "Total reads: " << reads << std::endl;
    std::cout << "Total writes: " << writes << std::endl;
    std::cout << "Cache hits: " << hits << std::endl;
    std::cout << "Cache misses: " << misses << std::endl;
    if (hits + misses > 0) {
        std::cout << "Cache hit rate: " << std::fixed << std::setprecision(1)
                  << (hits * 100.0 / (hits + misses)) << "%" << std::endl;
    }
    
    // 성능 벤치마크 실행
    performanceBenchmark();
    
    std::cout << "\n=== Key Insights ===" << std::endl;
    std::cout << "1. Shared mutex allows multiple concurrent readers" << std::endl;
    std::cout << "2. Writers have exclusive access when modifying data" << std::endl;
    std::cout << "3. Cache layer improves read performance" << std::endl;
    std::cout << "4. RAII lock management prevents deadlocks" << std::endl;
    std::cout << "5. Atomic operations track statistics without locks" << std::endl;
    
    return 0;
}
```
  

### std::shared_timed_mutex 
* **정의**: 다중 리더–단일 라이터(MRSW, multiple-reader/single-writer) 동기화를 제공하는 뮤텍스로, **공유 잠금(shared/read)** 과 **배타 잠금(exclusive/write)** 을 모두 지원하고, 두 잠금 모두에 대해 **시간 제한 있는 시도**를 제공한다.
* **헤더**: `<shared_mutex>` 다.
* **표준**: C++14에서 도입되었다. C++17에서 `std::shared_mutex`가 추가되었는데, 타임드 API가 필요 없으면 보통 `shared_mutex`가 약간 더 가볍고 빠른 선택이다.
* **특성**: 복사/이동 불가, 기본 생성 가능, RAII 래퍼로 `std::unique_lock`, `std::lock_guard`, `std::shared_lock`와 함께 쓰는 것이 일반적이다.

  
#### 인터페이스(핵심 멤버)

```cpp
class shared_timed_mutex {
public:
  shared_timed_mutex();
  ~shared_timed_mutex();

  // 배타 잠금 (writer)
  void lock();                         // 블로킹
  bool try_lock();                     // 즉시 시도
  template<class Rep, class Period>
  bool try_lock_for(const std::chrono::duration<Rep,Period>& rel_time);
  template<class Clock, class Duration>
  bool try_lock_until(const std::chrono::time_point<Clock,Duration>& abs_time);
  void unlock();

  // 공유 잠금 (reader)
  void lock_shared();                  // 블로킹
  bool try_lock_shared();              // 즉시 시도
  template<class Rep, class Period>
  bool try_lock_shared_for(const std::chrono::duration<Rep,Period>& rel_time);
  template<class Clock, class Duration>
  bool try_lock_shared_until(const std::chrono::time_point<Clock,Duration>& abs_time);
  void unlock_shared();
};
```

* **배타 잠금**은 동시에 하나의 스레드만 들어갈 수 있다.
* **공유 잠금**은 여러 스레드가 동시에 들어갈 수 있지만, 배타 잠금과는 상호 배타적이다.
* `try_lock_for/try_lock_until` 계열은 지정한 시간 안에 잠금에 실패하면 `false`를 반환한다.

  
#### 언제 사용하나
* **읽기가 압도적으로 많은 워크로드**에서 전체 임계 구역을 하나의 일반 `mutex`로 막는 대신, 다수의 리더가 동시에 들어오게 하여 스루풋을 높이고 싶을 때 좋다.
* **잠금 대기에 대한 SLA/시간 제한**이 필요할 때 `try_lock*_for/Until`로 **포기 시점**을 명시하고 대체 경로를 구현할 수 있다.
* 온라인 게임 서버 관점에서는 **플레이어 상태, 매치 메타데이터, 아이템 테이블** 같은 **읽기 다수/쓰기 드문 캐시**에 적합하다.
  
  
#### 주의해야 하는 점
* **공정성/기아(starvation)**: 표준은 리더/라이터 공정성을 보장하지 않는다. 구현에 따라 리더가 계속 들어와 라이터가 굶거나, 반대로 라이터 우선 정책으로 리더가 지연될 수 있다. 긴 임계 구역을 피하고, 필요하면 쓰기 배치를 도입하는 것이 좋다.
* **업그레이드/다운그레이드 미지원**: 공유 → 배타로의 안전한 업그레이드, 배타 → 공유 다운그레이드를 위한 전용 API가 없다. 이런 패턴이 필요하면 설계를 바꾸거나 별도 프로토콜/락을 도입해야 한다.
* **락 순서 데드락**: 여러 `shared_timed_mutex`를 조합하면 잠금 순서를 엄격히 지켜야 한다. 가능하면 한 번에 하나만 잠그거나, 정해진 순서로 잠그고 RAII를 사용한다.
* **오버헤드**: 관리해야 할 상태가 `mutex`보다 많아 짧은 임계 구역에서는 오히려 손해일 수 있다. 아주 짧거나 자주 호출되는 구역은 lock-free/atomics, read-copy-update, 분할 락 등을 검토한다.
* **타이밍 부정확성**: `try_lock_for/until`의 시간 정확도는 OS 타이머/스케줄러에 의존하므로 요청보다 길어질 수 있다.


#### 예제 1: 읽기 많은 캐시

```cpp
#include <shared_mutex>
#include <unordered_map>
#include <optional>
#include <string>

class PlayerCache {
  mutable std::shared_timed_mutex m_;
  std::unordered_map<int, std::string> name_;

public:
  std::optional<std::string> get(int id) const {
    std::shared_lock lock(m_);                 // 공유 잠금
    if (auto it = name_.find(id); it != name_.end()) return it->second;
    return std::nullopt;
  }

  void put(int id, std::string name) {
    std::unique_lock lock(m_);                 // 배타 잠금
    name_[id] = std::move(name);
  }
};
```

* 다수의 리더는 `std::shared_lock`으로 동시 접근하고, 라이터는 `std::unique_lock`으로 단독 진입한다.
  
#### 예제 2: 타임드 공유 잠금으로 응답 유지

```cpp
#include <shared_mutex>
#include <chrono>
#include <optional>

class Snapshot {
  mutable std::shared_timed_mutex m_;
  int value_ = 0;

public:
  bool update(int v) {
    // 쓰기는 오래 걸릴 수 있으니 타임드 배타 잠금을 써도 된다
    if (!m_.try_lock_for(std::chrono::milliseconds(5))) return false;
    value_ = v;
    m_.unlock();
    return true;
  }

  std::optional<int> read_with_deadline() const {
    if (!m_.try_lock_shared_for(std::chrono::milliseconds(1))) {
      return std::nullopt;                     // SLA 초과 시 포기
    }
    int v = value_;
    m_.unlock_shared();
    return v;
  }
};
```

* 읽기/쓰기 모두에 타임드 잠금을 적용해, 지연이 임계값을 넘으면 포기하고 상위 레이어에서 대체 동작을 하게 할 수 있다.


#### 실전 팁
* **타임드 API가 필요 없으면 `std::shared_mutex`를 우선 고려**한다. 보통 구현이 더 단순하고 성능이 약간 더 낫다.
* **임계 구역 최소화**와 **락 보유 시간 단축**이 성능의 핵심이다. I/O, 긴 계산, 외부 호출은 가능하면 락 밖으로 빼야 한다.
* **RAII 사용**이 기본이다. `std::shared_lock`과 `std::unique_lock`을 습관적으로 쓰면 `unlock()` 누락으로 인한 버그를 줄일 수 있다.
* **여러 락을 함께 잡을 때는 순서를 고정**하고, 가능하면 하나의 상위 락으로 합치거나 분할(lock sharding) 전략을 고려한다.
  
  
      
## std::timed_mutex

### 개요
* **정의**: `std::mutex`와 거의 같지만, 잠금(lock)을 시도할 때 **시간 제한(timeout)** 을 둘 수 있다.
* **시그니처**:

  ```cpp
  class timed_mutex {
  public:
      timed_mutex();
      ~timed_mutex();

      void lock();                      // 블로킹
      bool try_lock();                  // 즉시 시도
      bool try_lock_for(duration);      // 상대 시간 대기
      bool try_lock_until(time_point);  // 절대 시간 대기
      void unlock();
  };
  ```
* **주요 기능**:
  * `try_lock_for` → 일정 시간 동안만 잠금을 기다림
  * `try_lock_until` → 특정 시각까지만 기다림

### 사용해야 하는 경우
* **데드락 위험이 있는 상황에서 타임아웃을 적용하고 싶을 때**
  예: 여러 자원을 동시에 잠글 때 순서 문제로 데드락 가능성이 있으면 일정 시간 후 포기하도록 구현할 수 있다.
* **외부 이벤트나 I/O와 조합할 때**
  예: 네트워크 응답이나 타이머 이벤트를 기다리는 중에 잠금이 일정 시간 내에 가능하지 않으면 다른 처리를 하고 넘어갈 수 있다.

### 조심해야 하는 경우
* **타임아웃으로 인해 논리적 경합이 발생할 수 있다**
  예: 일부 스레드가 잠금을 얻지 못하고 계속 재시도하면 기아(starvation) 현상이 생길 수 있다.
* **타이머 해상도에 따라 실제 대기 시간이 정확하지 않다**
  스케줄링 지연이나 시스템 타이머 해상도 때문에 지정 시간보다 더 오래 기다릴 수 있다.

### 예제 코드

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>

std::timed_mutex tm;

void worker(int id) {
    if (tm.try_lock_for(std::chrono::milliseconds(100))) {
        std::cout << "Worker " << id << " got the lock\n";
        std::this_thread::sleep_for(std::chrono::milliseconds(200));
        tm.unlock();
    } else {
        std::cout << "Worker " << id << " timed out\n";
    }
}

int main() {
    std::thread t1(worker, 1);
    std::thread t2(worker, 2);
    t1.join();
    t2.join();
}
```

  

## std::recursive_mutex

### 개요
* **정의**: 동일한 스레드가 **같은 뮤텍스를 여러 번 잠글 수 있는** `std::mutex`의 변형이다.
* **시그니처**:

  ```cpp
  class recursive_mutex {
  public:
      recursive_mutex();
      ~recursive_mutex();

      void lock();
      bool try_lock();
      void unlock();
  };
  ```
* **특징**:
  * 잠금 횟수를 내부 카운트로 관리한다.
  * 동일 스레드가 여러 번 `lock()`을 호출하면 잠금 카운트가 증가하고, 같은 횟수만큼 `unlock()` 해야 완전히 해제된다.

### 사용해야 하는 경우
* **재귀 함수나 멤버 함수 호출 체인 내에서 동일 객체를 여러 번 잠글 가능성이 있는 경우**
  예: `A::foo()`에서 `lock()` 후 내부적으로 `A::bar()`를 호출하는데, `bar()`도 같은 락을 사용한다면 일반 `std::mutex`는 데드락을 일으킨다. 이때 `recursive_mutex`가 필요하다.

### 조심해야 하는 경우
* **락 횟수를 관리하기 어렵다**
  `unlock()` 횟수가 잘못되면 논리적 오류가 발생한다.
* **불필요하게 남용하면 코드 구조가 복잡해지고, 설계가 잘못됐음을 숨길 수 있다**
  대부분의 경우는 설계 개선으로 재귀락이 필요 없게 만들 수 있다.
* **성능 오버헤드가 있다**
  내부적으로 잠금 카운트와 스레드 ID 추적이 필요하므로 `std::mutex`보다 느리다.

### 예제 코드

```cpp
#include <iostream>
#include <mutex>

class Counter {
    std::recursive_mutex mtx;
    int value = 0;

    void add_internal(int x) {
        std::lock_guard<std::recursive_mutex> lock(mtx);
        value += x;
    }

public:
    void add(int x) {
        std::lock_guard<std::recursive_mutex> lock(mtx);
        add_internal(x); // 내부에서도 동일한 락 사용
    }

    int get() {
        std::lock_guard<std::recursive_mutex> lock(mtx);
        return value;
    }
};

int main() {
    Counter c;
    c.add(10);
    std::cout << c.get() << '\n';
}
```
  


## std::recursive_timed_mutex

### 개요
* **정의**: `std::recursive_mutex` + `std::timed_mutex` 기능을 합친 타입이다.
  즉, 재귀 잠금을 지원하면서도 타임아웃이 있는 `try_lock_for`, `try_lock_until`을 제공한다.
* **시그니처**:

  ```cpp
  class recursive_timed_mutex {
  public:
      recursive_timed_mutex();
      ~recursive_timed_mutex();

      void lock();
      bool try_lock();
      bool try_lock_for(duration);
      bool try_lock_until(time_point);
      void unlock();
  };
  ```

### 사용해야 하는 경우
* **재귀적 호출 구조가 있고, 동시에 잠금 시한이 필요한 경우**
  예: 복잡한 상태 관리 객체에서 메서드 간 상호 호출이 발생하고, 잠금 대기 시간 제한이 필요할 때.

### 조심해야 하는 경우
* **`recursive_mutex`와 같은 문제점** (락 횟수 관리 어려움, 남용 위험)
* **타임아웃 로직 복잡도 증가**
  재귀적으로 여러 번 잠금 후 일부만 해제되면 예기치 않은 상태가 될 수 있다. 설계 단계에서 가능한 피하는 것이 좋다.

### 예제 코드

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>

std::recursive_timed_mutex rtm;

void recursive_task(int depth) {
    if (rtm.try_lock_for(std::chrono::milliseconds(100))) {
        std::cout << "Lock acquired at depth " << depth << '\n';
        if (depth > 0) {
            recursive_task(depth - 1); // 같은 스레드에서 재귀적으로 잠금
        }
        rtm.unlock();
    } else {
        std::cout << "Timeout at depth " << depth << '\n';
    }
}

int main() {
    std::thread t(recursive_task, 3);
    t.join();
}
```
  