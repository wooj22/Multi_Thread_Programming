# 7ì£¼ì°¨: C++ STL ìŠ¤ë ˆë“œ í”„ë¡œê·¸ë˜ë° 1

## std::thread
C++ì—ì„œ ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ëŠ” ë°©ë²•ì€ ì—¬ëŸ¬ ê°€ì§€ê°€ ìˆë‹¤. std::thread ê°ì²´ë¥¼ ìƒì„±í•  ë•Œ ì‹¤í–‰í•  í•¨ìˆ˜ë¥¼ ì „ë‹¬í•˜ë©´, ìƒˆë¡œìš´ ìŠ¤ë ˆë“œê°€ ìƒì„±ë˜ê³  í•´ë‹¹ í•¨ìˆ˜ê°€ ì‹¤í–‰ëœë‹¤.

### í•¨ìˆ˜ í¬ì¸í„°ë¥¼ ì‚¬ìš©í•œ ìŠ¤ë ˆë“œ ìƒì„±
ê°€ì¥ ê¸°ë³¸ì ì¸ ë°©ë²•ì€ ì¼ë°˜ í•¨ìˆ˜ë¥¼ ìŠ¤ë ˆë“œë¡œ ì‹¤í–‰í•˜ëŠ” ê²ƒì´ë‹¤.

```
#include <iostream>
#include <thread>
#include <chrono>

// ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰í•  í•¨ìˆ˜
void workerFunction(int id, int iterations) {
    for (int i = 0; i < iterations; ++i) {
        std::cout << "Thread " << id << " is working: " << i << std::endl;
        // ì‘ì—… ì‹œë®¬ë ˆì´ì…˜ì„ ìœ„í•œ ì§§ì€ ëŒ€ê¸°
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    std::cout << "Thread " << id << " completed!" << std::endl;
}

int main() {
    std::cout << "Main thread starting..." << std::endl;
    
    // ì„¸ ê°œì˜ ìŠ¤ë ˆë“œ ìƒì„±
    std::thread t1(workerFunction, 1, 3);
    std::thread t2(workerFunction, 2, 4);
    std::thread t3(workerFunction, 3, 2);
    
    // ëª¨ë“  ìŠ¤ë ˆë“œê°€ ì™„ë£Œë  ë•Œê¹Œì§€ ëŒ€ê¸°
    t1.join();
    t2.join();
    t3.join();
    
    std::cout << "All threads completed. Main thread exiting." << std::endl;
    return 0;
}
```  


### std::this_thread::get_id
* **ì—­í• **: í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ ìŠ¤ë ˆë“œì˜ ì‹ë³„ì(`std::thread::id`)ë¥¼ ë°˜í™˜í•œë‹¤.
* **ì‹œê·¸ë‹ˆì²˜/ì†ì„±**: `std::thread::id get_id() noexcept` ë‹¤.
* **íŠ¹ì§•**: `std::thread::id`ëŠ” ë¹„êµ ì—°ì‚°ê³¼ ìŠ¤íŠ¸ë¦¼ ì¶œë ¥, `std::hash`ê°€ ì œê³µë˜ì–´ ë§µ/ì…‹ì˜ í‚¤ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. ê°™ì€ ìŠ¤ë ˆë“œì— ëŒ€í•´ í•­ìƒ ê°™ì€ ê°’ì„ ë°˜í™˜í•˜ë©° ì„œë¡œ ë‹¤ë¥¸ ìŠ¤ë ˆë“œëŠ” ì„œë¡œ ë‹¤ë¥¸ ê°’ì„ ê°–ëŠ”ë‹¤. ê¸°ë³¸ìƒì„±ëœ `std::thread::id{}`ëŠ” â€œì–´ë–¤ ìŠ¤ë ˆë“œì—ë„ ì†í•˜ì§€ ì•ŠìŒâ€ì„ ëœ»í•˜ë©° `std::thread{}`ì˜ `get_id()`ì™€ ë™ì¼í•˜ë‹¤.
* **ì˜ˆì‹œ**:

  ```cpp
  #include <thread>
  #include <iostream>

  int main() {
    std::cout << "main id = " << std::this_thread::get_id() << '\n';
    std::thread t([]{
      std::cout << "worker id = " << std::this_thread::get_id() << '\n';
    });
    t.join();
  }
  ```

### std::this_thread::yield
* **ì—­í• **: ìŠ¤ì¼€ì¤„ëŸ¬ì— â€œë‹¤ë¥¸ ì¤€ë¹„ëœ ìŠ¤ë ˆë“œë¥¼ ë¨¼ì € ì‹¤í–‰í•´ë„ ëœë‹¤â€ëŠ” íŒíŠ¸ë¥¼ ì¤€ë‹¤. í˜„ì¬ ìŠ¤ë ˆë“œì˜ ì‹¤í–‰ì„ ì¦‰ì‹œ ì–‘ë³´í•˜ê³  ë‹¤ì‹œ ìŠ¤ì¼€ì¤„ë  ìˆ˜ ìˆë‹¤.
* **ì‹œê·¸ë‹ˆì²˜/ì†ì„±**: `void yield() noexcept` ë‹¤.
* **ë³´ì¥/ì£¼ì˜**: ì‹¤ì œë¡œ ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹˜ê°€ ì¼ì–´ë‚ ì§€, ì–´ëŠ ì •ë„ ëŒ€ê¸°í• ì§€ëŠ” êµ¬í˜„ê³¼ ì‹œìŠ¤í…œ ìƒíƒœì— ë”°ë¼ ë‹¤ë¥´ë‹¤. ì¤€ë¹„ëœ ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ì—†ìœ¼ë©´ ì•„ë¬´ ë³€í™”ê°€ ì—†ì„ ìˆ˜ ìˆë‹¤. ê³¼ë„í•œ ì‚¬ìš©ì€ ì„±ëŠ¥ì„ í•´ì¹  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ìŠ¤í•€ ëŒ€ê¸°ì—ì„œì˜ ë°±ì˜¤í”„ ë‹¨ê³„ ë“±ì— ì œí•œì ìœ¼ë¡œ ì“°ëŠ” ê²ƒì´ ì¢‹ë‹¤. ë™ê¸°í™”ì—ëŠ” `condition_variable`, ì„¸ë§ˆí¬ì–´, `atomic::wait/notify` ê°™ì€ í”„ë¦¬ë¯¸í‹°ë¸Œê°€ ë” ì ì ˆí•˜ë‹¤.
* **ì˜ˆì‹œ(ìŠ¤í•€ ëŒ€ê¸° ë°±ì˜¤í”„)**:

  ```cpp
  #include <atomic>
  #include <thread>

  std::atomic<bool> ready = false;

  void wait_ready() {
    int spins = 0;
    while (!ready.load(std::memory_order_acquire)) {
      if (spins < 100) {
        ++spins; // ì•„ì£¼ ì§§ê²Œ ë°”ìœ ëŒ€ê¸°
      } else {
        std::this_thread::yield(); // ê·¸ë‹¤ìŒì—” ì–‘ë³´
      }
    }
  }
  ```

### std::this_thread::sleep_for
* **ì—­í• **: í˜„ì¬ ìŠ¤ë ˆë“œë¥¼ **ìƒëŒ€ ì‹œê°„**ë§Œí¼ ì°¨ë‹¨í•œë‹¤. ìµœì†Œí•œ ì§€ì •í•œ ê¸°ê°„ ë™ì•ˆ ê¹¨ì–´ë‚˜ì§€ ì•ŠëŠ”ë‹¤.
* **ì‹œê·¸ë‹ˆì²˜/ì†ì„±**:

  ```cpp
  template<class Rep, class Period>
  void sleep_for(const std::chrono::duration<Rep, Period>& rel_time);
  ```

  êµ¬í˜„ì€ ë³´í†µ `noexcept`ë¡œ ì œê³µí•˜ë©°, `rel_time <= 0`ì´ë©´ ì¦‰ì‹œ ë°˜í™˜í•œë‹¤.
* **ë³´ì¥/ì£¼ì˜**: ìŠ¤ì¼€ì¤„ë§ ì§€ì—°, íƒ€ì´ë¨¸ í•´ìƒë„ ë“±ì˜ ì´ìœ ë¡œ **ìš”ì²­í•œ ì‹œê°„ë³´ë‹¤ ë” ì˜¤ë˜** ì ë“¤ ìˆ˜ ìˆë‹¤. ì •í™•í•œ ì£¼ê¸°ë¥¼ ë³´ì¥í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ, ì£¼ê¸° ìœ ì§€ê°€ ì¤‘ìš”í•˜ë©´ ì‹¤ì œ ê²½ê³¼ ì‹œê°„ì„ ì¸¡ì •í•´ ë³´ì •í•˜ëŠ” ë£¨í”„ë¥¼ êµ¬ì„±í•´ì•¼ í•œë‹¤. í´ë§ ìš©ë„ë¡œ ë‚¨ìš©í•˜ì§€ ë§ê³ , ê°€ëŠ¥í•˜ë©´ ì¡°ê±´ë³€ìˆ˜ë‚˜ ì„¸ë§ˆí¬ì–´ë¡œ ì´ë²¤íŠ¸ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ê²ƒì´ ë‚«ë‹¤.
* **ì˜ˆì‹œ(60Hz ë£¨í”„ ë³´ì •)**:

  ```cpp
  #include <chrono>
  #include <thread>

  using clock = std::chrono::steady_clock;

  int main() {
    const auto frame = std::chrono::milliseconds(1000 / 60);
    auto next = clock::now();
    for (;;) {
      // ì‘ì—… ìˆ˜í–‰
      // ...

      next += frame;
      std::this_thread::sleep_until(next); // sleep_for ëŒ€ì‹  ì˜¤ì°¨ ëˆ„ì ì„ ì¤„ì¸ë‹¤
    }
  }
  ```
  
### std::this_thread::sleep_until
* **ì—­í• **: í˜„ì¬ ìŠ¤ë ˆë“œë¥¼ **ì ˆëŒ€ ì‹œê°**ê¹Œì§€ ì°¨ë‹¨í•œë‹¤. ì§€ì •í•œ ì‹œê°ì´ ë„ë‹¬í•˜ë©´ ê¹¨ì–´ë‚œë‹¤.
* **ì‹œê·¸ë‹ˆì²˜/ì†ì„±**:

  ```cpp
  template<class Clock, class Duration>
  void sleep_until(const std::chrono::time_point<Clock, Duration>& abs_time);
  ```

  `abs_time`ê°€ ì´ë¯¸ ê³¼ê±°ë©´ ì¦‰ì‹œ ë°˜í™˜í•œë‹¤.
* **ë³´ì¥/ì£¼ì˜**: `Clock`ì˜ ì„±ì§ˆì„ ë”°ë¥¸ë‹¤. `std::chrono::steady_clock`ë¥¼ ì“°ë©´ ì‹œìŠ¤í…œ ì‹œê°„ ì¡°ì •(NTP, ì‚¬ìš©ìì˜ ìˆ˜ë™ ì‹œê°„ ë³€ê²½) ì˜í–¥ì„ ë°›ì§€ ì•Šì•„ íƒ€ì´ë°ì´ ì•ˆì •ì ì´ë‹¤. `std::chrono::system_clock`ë¡œ ì§€ì •í•˜ë©´ ì‹œê³„ê°€ ë’¤ë¡œ/ì•ìœ¼ë¡œ ì í”„í•  ë•Œ ëŒ€ê¸° ì‹œê°„ì´ ì˜ˆìƒê³¼ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆë‹¤. ë˜í•œ ìŠ¤ì¼€ì¤„ë§ ì§€ì—°ìœ¼ë¡œ ëª©í‘œ ì‹œê° **ì´í›„**ì— ê¹¨ì–´ë‚  ìˆ˜ ìˆë‹¤.
* **ì˜ˆì‹œ(íŠ¹ì • ì ˆëŒ€ ì‹œê°ê¹Œì§€ ëŒ€ê¸°)**:

  ```cpp
  #include <chrono>
  #include <thread>
  #include <iostream>

  int main() {
    using clock = std::chrono::steady_clock;
    auto wake = clock::now() + std::chrono::seconds(2);
    std::this_thread::sleep_until(wake);
    std::cout << "woke up\n";
  }
  ```

>> ì‘ì€ íŒ
>> * ì•„ì£¼ ì§§ì€ ì§€ì—°ì„ `sleep_for(1us)`ì²˜ëŸ¼ ìš”ì²­í•´ë„ ì‹¤ì œ ëŒ€ê¸°ì‹œê°„ì€ ìš´ì˜ì²´ì œ íƒ€ì´ë¨¸ í•´ìƒë„ì— ì˜í•´ í›¨ì”¬ ê¸¸ì–´ì§ˆ ìˆ˜ ìˆë‹¤. ê³ í•´ìƒë„ íƒ€ì´ë°ì´ í•„ìš”í•˜ë©´ ë°”ìœ ëŒ€ê¸°ì™€ ë°±ì˜¤í”„, ë˜ëŠ” í”Œë«í¼ì˜ ê³ í•´ìƒë„ íƒ€ì´ë¨¸ë¥¼ ê²€í† í•´ì•¼ í•œë‹¤.
>> * ìŠ¤ë ˆë“œ ìš°ì„ ìˆœìœ„ì™€ íƒ€ì´ë¨¸ ì •í™•ë„ëŠ” ìš´ì˜ì²´ì œë§ˆë‹¤ ë‹¤ë¥´ë¯€ë¡œ, ì„±ëŠ¥/ì •í™•ë„ ìš”êµ¬ê°€ ë†’ë‹¤ë©´ ëŒ€ìƒ í”Œë«í¼ì—ì„œ ì‹¤ì¸¡í•˜ëŠ” ê²ƒì´ ì•ˆì „í•˜ë‹¤.
       
    
### í•¨ìˆ˜ ê°ì²´(Functor)ë¥¼ ì‚¬ìš©í•œ ìŠ¤ë ˆë“œ ìƒì„±
í•¨ìˆ˜ ê°ì²´ëŠ” operator()ë¥¼ ì˜¤ë²„ë¡œë“œí•œ í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ë‹¤. ì´ ë°©ë²•ì€ ìŠ¤ë ˆë“œê°€ ì‹¤í–‰ë  ë•Œ ìƒíƒœë¥¼ ìœ ì§€í•  ìˆ˜ ìˆë‹¤ëŠ” ì¥ì ì´ ìˆë‹¤.    
  
```
#include <iostream>
#include <thread>
#include <chrono>

// í•¨ìˆ˜ ê°ì²´ í´ë˜ìŠ¤
class WorkerTask {
private:
    int id_;
    int iterations_;
    
public:
    WorkerTask(int id, int iterations) : id_(id), iterations_(iterations) {}
    
    // í•¨ìˆ˜ í˜¸ì¶œ ì—°ì‚°ì ì˜¤ë²„ë¡œë“œ
    void operator()() {
        for (int i = 0; i < iterations_; ++i) {
            std::cout << "Worker " << id_ << " processing: " << i << std::endl;
            std::this_thread::sleep_for(std::chrono::milliseconds(150));
        }
        std::cout << "Worker " << id_ << " finished!" << std::endl;
    }
};

int main() {
    std::cout << "Creating threads with functors..." << std::endl;
    
    // í•¨ìˆ˜ ê°ì²´ë¥¼ ì‚¬ìš©í•œ ìŠ¤ë ˆë“œ ìƒì„±
    WorkerTask task1(1, 3);
    WorkerTask task2(2, 2);
    
    std::thread t1(task1);
    std::thread t2(task2);
    
    // ë˜ëŠ” ì„ì‹œ ê°ì²´ë¥¼ ì§ì ‘ ì „ë‹¬
    std::thread t3(WorkerTask(3, 4));
    
    t1.join();
    t2.join();
    t3.join();
    
    std::cout << "All workers completed." << std::endl;
    return 0;
}
```  
    
  
### ëŒë‹¤ í‘œí˜„ì‹ì„ ì‚¬ìš©í•œ ìŠ¤ë ˆë“œ ìƒì„±
C++11ì˜ ëŒë‹¤ í‘œí˜„ì‹ì€ ìŠ¤ë ˆë“œ ìƒì„±ì„ ë”ìš± ê°„ê²°í•˜ê³  ìœ ì—°í•˜ê²Œ ë§Œë“ ë‹¤. ëŒë‹¤ëŠ” ì§€ì—­ ë³€ìˆ˜ë¥¼ ìº¡ì²˜í•  ìˆ˜ ìˆì–´ ë§¤ìš° í¸ë¦¬í•˜ë‹¤.
  
```
#include <iostream>
#include <thread>
#include <vector>
#include <chrono>

int main() {
    std::cout << "Creating threads with lambda expressions..." << std::endl;
    
    // ì§€ì—­ ë³€ìˆ˜
    int sharedValue = 100;
    std::vector<std::thread> threads;
    
    // ê°’ìœ¼ë¡œ ìº¡ì²˜í•˜ëŠ” ëŒë‹¤
    threads.emplace_back([sharedValue]() {
        std::cout << "Thread 1: Captured value = " << sharedValue << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    });
    
    // ì°¸ì¡°ë¡œ ìº¡ì²˜í•˜ëŠ” ëŒë‹¤ (ì£¼ì˜: ë™ê¸°í™” í•„ìš”)
    threads.emplace_back([&sharedValue]() {
        std::cout << "Thread 2: Captured reference = " << sharedValue << std::endl;
        sharedValue += 50;  // ì‹¤ì œë¡œëŠ” mutexë¡œ ë³´í˜¸í•´ì•¼ í•¨
        std::cout << "Thread 2: Modified value to " << sharedValue << std::endl;
    });
    
    // ë§¤ê°œë³€ìˆ˜ë¥¼ ë°›ëŠ” ëŒë‹¤
    auto worker = [](int id, const std::string& message) {
        for (int i = 0; i < 3; ++i) {
            std::cout << "Thread " << id << ": " << message << " (" << i << ")" << std::endl;
            std::this_thread::sleep_for(std::chrono::milliseconds(200));
        }
    };
    
    threads.emplace_back(worker, 3, "Processing data");
    threads.emplace_back(worker, 4, "Calculating results");
    
    // ëª¨ë“  ìŠ¤ë ˆë“œ ì¢…ë£Œ ëŒ€ê¸°
    for (auto& t : threads) {
        t.join();
    }
    
    std::cout << "Final sharedValue: " << sharedValue << std::endl;
    return 0;
}
``` 
   
  
### ìŠ¤ë ˆë“œ ë§¤ê°œë³€ìˆ˜ ì „ë‹¬ ë°©ë²•
ìŠ¤ë ˆë“œì— ë§¤ê°œë³€ìˆ˜ë¥¼ ì „ë‹¬í•  ë•ŒëŠ” ê°’, ì°¸ì¡°, í¬ì¸í„° ë°©ì‹ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. ê° ë°©ì‹ì€ ì¥ë‹¨ì ì´ ìˆìœ¼ë©°, íŠ¹íˆ ì°¸ì¡°ì™€ í¬ì¸í„°ë¥¼ ì‚¬ìš©í•  ë•ŒëŠ” ì£¼ì˜ê°€ í•„ìš”í•˜ë‹¤.  

```
#include <iostream>
#include <thread>
#include <string>
#include <functional>

// ê°’ìœ¼ë¡œ ë°›ëŠ” í•¨ìˆ˜
void byValue(int x, std::string str) {
    x += 10;
    str += " modified";
    std::cout << "By value - x: " << x << ", str: " << str << std::endl;
}

// ì°¸ì¡°ë¡œ ë°›ëŠ” í•¨ìˆ˜
void byReference(int& x, std::string& str) {
    x += 20;
    str += " changed";
    std::cout << "By reference - x: " << x << ", str: " << str << std::endl;
}

// í¬ì¸í„°ë¡œ ë°›ëŠ” í•¨ìˆ˜
void byPointer(int* x, std::string* str) {
    if (x && str) {
        *x += 30;
        *str += " updated";
        std::cout << "By pointer - x: " << *x << ", str: " << *str << std::endl;
    }
}

// const ì°¸ì¡°ë¡œ ë°›ëŠ” í•¨ìˆ˜ (ì½ê¸° ì „ìš©)
void byConstReference(const int& x, const std::string& str) {
    std::cout << "By const reference - x: " << x << ", str: " << str << std::endl;
}

int main() {
    int num = 100;
    std::string text = "Hello";
    
    std::cout << "Initial values - num: " << num << ", text: " << text << std::endl;
    std::cout << "----------------------------------------" << std::endl;
    
    // 1. ê°’ìœ¼ë¡œ ì „ë‹¬ (ì›ë³¸ ë³€ê²½ ì—†ìŒ)
    std::thread t1(byValue, num, text);
    t1.join();
    std::cout << "After byValue - num: " << num << ", text: " << text << std::endl;
    std::cout << "----------------------------------------" << std::endl;
    
    // 2. ì°¸ì¡°ë¡œ ì „ë‹¬ (std::ref í•„ìš”)
    std::thread t2(byReference, std::ref(num), std::ref(text));
    t2.join();
    std::cout << "After byReference - num: " << num << ", text: " << text << std::endl;
    std::cout << "----------------------------------------" << std::endl;
    
    // 3. í¬ì¸í„°ë¡œ ì „ë‹¬
    std::thread t3(byPointer, &num, &text);
    t3.join();
    std::cout << "After byPointer - num: " << num << ", text: " << text << std::endl;
    std::cout << "----------------------------------------" << std::endl;
    
    // 4. const ì°¸ì¡°ë¡œ ì „ë‹¬ (std::cref ì‚¬ìš©)
    std::thread t4(byConstReference, std::cref(num), std::cref(text));
    t4.join();
    std::cout << "After byConstReference - num: " << num << ", text: " << text << std::endl;
    
    return 0;
}
```  
  
**ì£¼ì˜ì‚¬í•­:**
- std::threadëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ëª¨ë“  ì¸ìë¥¼ ê°’ìœ¼ë¡œ ë³µì‚¬í•œë‹¤
- ì°¸ì¡°ë¥¼ ì „ë‹¬í•˜ë ¤ë©´ std::ref() ë˜ëŠ” std::cref()ë¥¼ ì‚¬ìš©í•´ì•¼ í•œë‹¤
- í¬ì¸í„°ë¥¼ ì „ë‹¬í•  ë•ŒëŠ” í¬ì¸í„°ê°€ ê°€ë¦¬í‚¤ëŠ” ê°ì²´ì˜ ìƒëª…ì£¼ê¸°ë¥¼ ì£¼ì˜í•´ì•¼ í•œë‹¤
- ì§€ì—­ ë³€ìˆ˜ì˜ ì£¼ì†Œë¥¼ ìŠ¤ë ˆë“œì— ì „ë‹¬í•  ë•ŒëŠ” ìŠ¤ë ˆë“œê°€ ì¢…ë£Œë˜ê¸° ì „ì— ë³€ìˆ˜ê°€ ì†Œë©¸ë˜ì§€ ì•Šë„ë¡ ì£¼ì˜í•´ì•¼ í•œë‹¤
  
  
</br>    
  
## std::mutex  
  
### ê²½ìŸ ìƒíƒœ(Race Condition)ì™€ ì„ê³„ ì˜ì—­
ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ê°™ì€ ë°ì´í„°ì— ì ‘ê·¼í•  ë•Œ ê²½ìŸ ìƒíƒœê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤. ê²½ìŸ ìƒíƒœëŠ” í”„ë¡œê·¸ë¨ì˜ ì‹¤í–‰ ê²°ê³¼ê°€ ìŠ¤ë ˆë“œì˜ ì‹¤í–‰ ìˆœì„œì— ë”°ë¼ ë‹¬ë¼ì§€ëŠ” í˜„ìƒì´ë‹¤.

```
     Thread 1                    Thread 2
         â”‚                           â”‚
         â–¼                           â–¼
    Read value (100)            Read value (100)
         â”‚                           â”‚
         â–¼                           â–¼
    Add 10 (110)                Add 20 (120)
         â”‚                           â”‚
         â–¼                           â–¼
    Write value (110)           Write value (120)
         â”‚                           â”‚
         â–¼                           â–¼
    
    ì˜ˆìƒ ê²°ê³¼: 130 (100 + 10 + 20)
    ì‹¤ì œ ê²°ê³¼: 110 ë˜ëŠ” 120 (ê²½ìŸ ìƒíƒœ)
```
  
  
### std::mutex ê¸°ë³¸ ì‚¬ìš©ë²•
ë®¤í…ìŠ¤(Mutual Exclusion)ëŠ” ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ê³µìœ  ìì›ì— ë™ì‹œì— ì ‘ê·¼í•˜ëŠ” ê²ƒì„ ë°©ì§€í•˜ëŠ” ë™ê¸°í™” ê¸°ë²•ì´ë‹¤. std::mutexëŠ” C++ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ì œê³µí•˜ëŠ” ê¸°ë³¸ì ì¸ ë®¤í…ìŠ¤ í´ë˜ìŠ¤ë‹¤.

```
    Thread 1                Thread 2
        â”‚                       â”‚
        â–¼                       â–¼
    Lock Mutex              Try Lock
        â”‚                    (Wait)
        â–¼                       â”‚
    Access Resource             â”‚
        â”‚                       â”‚
        â–¼                       â”‚
    Unlock Mutex                â”‚
        â”‚                       â–¼
        â”‚                   Lock Mutex
        â”‚                       â”‚
        â”‚                       â–¼
        â”‚                 Access Resource
        â”‚                       â”‚
        â”‚                       â–¼
        â”‚                  Unlock Mutex
``` 
    
```
#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <chrono>

// ì „ì—­ ë®¤í…ìŠ¤ì™€ ê³µìœ  ë°ì´í„°
std::mutex mtx;
int shared_counter = 0;

// ë®¤í…ìŠ¤ë¥¼ ìˆ˜ë™ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” ë°©ë²• (ê¶Œì¥í•˜ì§€ ì•ŠìŒ)
void unsafeIncrement(int id, int iterations) {
    for (int i = 0; i < iterations; ++i) {
        mtx.lock();  // ë®¤í…ìŠ¤ ì ê¸ˆ
        
        // ì„ê³„ ì˜ì—­ (Critical Section)
        int temp = shared_counter;
        temp++;
        std::this_thread::sleep_for(std::chrono::microseconds(10));
        shared_counter = temp;
        
        mtx.unlock();  // ë®¤í…ìŠ¤ í•´ì œ
    }
}

// try_lockì„ ì‚¬ìš©í•œ ë¹„ì°¨ë‹¨ ì ê¸ˆ ì‹œë„
void tryLockExample(int id) {
    for (int attempt = 0; attempt < 5; ++attempt) {
        if (mtx.try_lock()) {
            std::cout << "Thread " << id << " acquired lock on attempt " << attempt << std::endl;
            
            // ì„ê³„ ì˜ì—­
            shared_counter += 10;
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            
            mtx.unlock();
            break;
        } else {
            std::cout << "Thread " << id << " failed to acquire lock on attempt " << attempt << std::endl;
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
        }
    }
}

int main() {
    std::cout << "=== Manual Mutex Usage Example ===" << std::endl;
    
    // 1. ê¸°ë³¸ lock/unlock ì‚¬ìš©
    shared_counter = 0;
    std::vector<std::thread> threads;
    
    for (int i = 0; i < 3; ++i) {
        threads.emplace_back(unsafeIncrement, i, 100);
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    std::cout << "Counter after manual locking: " << shared_counter << " (Expected: 300)" << std::endl;
    
    // 2. try_lock ì‚¬ìš© ì˜ˆì œ
    std::cout << "\n=== Try Lock Example ===" << std::endl;
    shared_counter = 0;
    threads.clear();
    
    for (int i = 0; i < 3; ++i) {
        threads.emplace_back(tryLockExample, i);
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    std::cout << "Final counter: " << shared_counter << std::endl;
    
    return 0;
}
```  
  
  
### std::lock_guardì™€ RAII íŒ¨í„´
ìˆ˜ë™ìœ¼ë¡œ lock()ê³¼ unlock()ì„ í˜¸ì¶œí•˜ëŠ” ê²ƒì€ ìœ„í—˜í•˜ë‹¤. ì˜ˆì™¸ê°€ ë°œìƒí•˜ê±°ë‚˜ í•¨ìˆ˜ê°€ ì¡°ê¸°ì— ë°˜í™˜ë˜ë©´ unlock()ì´ í˜¸ì¶œë˜ì§€ ì•Šì•„ ë°ë“œë½ì´ ë°œìƒí•  ìˆ˜ ìˆë‹¤. **std::lock_guardëŠ” RAII(Resource Acquisition Is Initialization) íŒ¨í„´** ì„ ì‚¬ìš©í•˜ì—¬ ì´ ë¬¸ì œë¥¼ í•´ê²°í•œë‹¤.
   
```
void deposit(double amount) 
{
    std::lock_guard<std::mutex> lock(mtx_);  // ìë™ ì ê¸ˆ
    
    if (amount <= 0) {
        throw std::invalid_argument("Deposit amount must be positive");
    }
    
    double old_balance = balance_;
    balance_ += amount;
        
}  // lock_guard ì†Œë©¸ìì—ì„œ ìë™ìœ¼ë¡œ unlock
```  
  
```
#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <exception>
#include <chrono>

class BankAccount {
private:
    mutable std::mutex mtx_;
    double balance_;
    std::string account_name_;
    
public:
    BankAccount(const std::string& name, double initial_balance) 
        : account_name_(name), balance_(initial_balance) {}
    
    // ì…ê¸ˆ - lock_guard ì‚¬ìš©
    void deposit(double amount) {
        std::lock_guard<std::mutex> lock(mtx_);  // ìë™ ì ê¸ˆ
        
        if (amount <= 0) {
            throw std::invalid_argument("Deposit amount must be positive");
        }
        
        double old_balance = balance_;
        balance_ += amount;
        
        std::cout << account_name_ << " - Deposit: $" << amount 
                  << " (Balance: $" << old_balance << " -> $" << balance_ << ")" 
                  << std::endl;
    }  // lock_guard ì†Œë©¸ìì—ì„œ ìë™ìœ¼ë¡œ unlock
    
    // ì¶œê¸ˆ - lock_guard ì‚¬ìš©
    bool withdraw(double amount) {
        std::lock_guard<std::mutex> lock(mtx_);
        
        if (amount <= 0) {
            throw std::invalid_argument("Withdrawal amount must be positive");
        }
        
        if (balance_ >= amount) {
            double old_balance = balance_;
            balance_ -= amount;
            
            std::cout << account_name_ << " - Withdraw: $" << amount 
                      << " (Balance: $" << old_balance << " -> $" << balance_ << ")" 
                      << std::endl;
            return true;
        }
        
        std::cout << account_name_ << " - Withdrawal failed: Insufficient funds" 
                  << " (Requested: $" << amount << ", Available: $" << balance_ << ")" 
                  << std::endl;
        return false;
    }
    
    // ì”ì•¡ ì¡°íšŒ - const ë©”ì„œë“œì—ì„œë„ lock_guard ì‚¬ìš©
    double getBalance() const {
        std::lock_guard<std::mutex> lock(mtx_);
        return balance_;
    }
    
    // ê³„ì¢Œ ì´ì²´ - ë‘ ê°œì˜ ë®¤í…ìŠ¤ë¥¼ ì•ˆì „í•˜ê²Œ ê´€ë¦¬
    static void transfer(BankAccount& from, BankAccount& to, double amount) {
        // std::lockì„ ì‚¬ìš©í•˜ì—¬ ë°ë“œë½ ë°©ì§€
        std::lock(from.mtx_, to.mtx_);
        
        // adopt_lock: ì´ë¯¸ ì ê¸´ ë®¤í…ìŠ¤ë¥¼ ê´€ë¦¬
        std::lock_guard<std::mutex> lock1(from.mtx_, std::adopt_lock);
        std::lock_guard<std::mutex> lock2(to.mtx_, std::adopt_lock);
        
        if (from.balance_ >= amount) {
            from.balance_ -= amount;
            to.balance_ += amount;
            
            std::cout << "Transfer: $" << amount 
                      << " from " << from.account_name_ 
                      << " to " << to.account_name_ << " successful" << std::endl;
        } else {
            std::cout << "Transfer failed: Insufficient funds in " 
                      << from.account_name_ << std::endl;
        }
    }
};

// ì—¬ëŸ¬ íŠ¸ëœì­ì…˜ì„ ìˆ˜í–‰í•˜ëŠ” ìŠ¤ë ˆë“œ í•¨ìˆ˜
void performTransactions(BankAccount& account, int thread_id) {
    try {
        for (int i = 0; i < 5; ++i) {
            if (i % 2 == 0) {
                account.deposit(10.0 * (thread_id + 1));
            } else {
                account.withdraw(5.0 * (thread_id + 1));
            }
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
    } catch (const std::exception& e) {
        std::cout << "Thread " << thread_id << " exception: " << e.what() << std::endl;
    }
}

int main() {
    std::cout << "=== Bank Account Thread Safety Demo ===" << std::endl;
    
    BankAccount account1("Checking", 1000.0);
    BankAccount account2("Savings", 500.0);
    
    std::cout << "\nInitial balances:" << std::endl;
    std::cout << "Checking: $" << account1.getBalance() << std::endl;
    std::cout << "Savings: $" << account2.getBalance() << std::endl;
    
    // ì—¬ëŸ¬ ìŠ¤ë ˆë“œì—ì„œ ë™ì‹œì— ê³„ì¢Œ ì‘ì—… ìˆ˜í–‰
    std::vector<std::thread> threads;
    
    for (int i = 0; i < 3; ++i) {
        threads.emplace_back(performTransactions, std::ref(account1), i);
    }
    
    // ê³„ì¢Œ ì´ì²´ ìŠ¤ë ˆë“œ
    threads.emplace_back([&account1, &account2]() {
        std::this_thread::sleep_for(std::chrono::milliseconds(250));
        BankAccount::transfer(account1, account2, 100.0);
    });
    
    for (auto& t : threads) {
        t.join();
    }
    
    std::cout << "\nFinal balances:" << std::endl;
    std::cout << "Checking: $" << account1.getBalance() << std::endl;
    std::cout << "Savings: $" << account2.getBalance() << std::endl;
    
    return 0;
}
```
  
  
### ì‹¤ìŠµ: ë©€í‹°ìŠ¤ë ˆë“œ ì¹´ìš´í„° í”„ë¡œê·¸ë¨
ì´ì œ ë°°ìš´ ë‚´ìš©ì„ ì¢…í•©í•˜ì—¬ ë™ê¸°í™”ëœ ë©€í‹°ìŠ¤ë ˆë“œ ì¹´ìš´í„° í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•´ë³´ì. ì´ í”„ë¡œê·¸ë¨ì€ ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ì¹´ìš´í„°ë¥¼ ì¦ê°€ì‹œí‚¤ê³ , ê°ì†Œì‹œí‚¤ë©°, í˜„ì¬ ê°’ì„ ì½ëŠ” ì‘ì—…ì„ ìˆ˜í–‰í•œë‹¤.
  
```
#include <iostream>
#include <thread>
#include <mutex>
#include <atomic>
#include <vector>
#include <chrono>
#include <random>
#include <iomanip>

// ìŠ¤ë ˆë“œ ì•ˆì „ ì¹´ìš´í„° í´ë˜ìŠ¤
class ThreadSafeCounter {
private:
    mutable std::mutex mtx_;
    int value_;
    int increment_count_;
    int decrement_count_;
    int read_count_;
    
public:
    ThreadSafeCounter(int initial_value = 0) 
        : value_(initial_value), increment_count_(0), 
          decrement_count_(0), read_count_(0) {}
    
    void increment() {
        std::lock_guard<std::mutex> lock(mtx_);
        ++value_;
        ++increment_count_;
    }
    
    void decrement() {
        std::lock_guard<std::mutex> lock(mtx_);
        --value_;
        ++decrement_count_;
    }
    
    int getValue() const {
        std::lock_guard<std::mutex> lock(mtx_);
        const_cast<ThreadSafeCounter*>(this)->read_count_++;
        return value_;
    }
    
    void getStatistics(int& value, int& inc_count, int& dec_count, int& read_count) const {
        std::lock_guard<std::mutex> lock(mtx_);
        value = value_;
        inc_count = increment_count_;
        dec_count = decrement_count_;
        read_count = read_count_;
    }
};

// ì‘ì—… íƒ€ì… ì—´ê±°í˜•
enum class Operation {
    INCREMENT,
    DECREMENT,
    READ
};

// ì›Œì»¤ ìŠ¤ë ˆë“œ í•¨ìˆ˜
void worker(ThreadSafeCounter& counter, int thread_id, int operations) {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> op_dist(0, 2);
    std::uniform_int_distribution<> delay_dist(1, 10);
    
    for (int i = 0; i < operations; ++i) {
        Operation op = static_cast<Operation>(op_dist(gen));
        
        switch (op) {
            case Operation::INCREMENT:
                counter.increment();
                std::cout << "[Thread " << std::setw(2) << thread_id 
                         << "] Incremented counter" << std::endl;
                break;
                
            case Operation::DECREMENT:
                counter.decrement();
                std::cout << "[Thread " << std::setw(2) << thread_id 
                         << "] Decremented counter" << std::endl;
                break;
                
            case Operation::READ:
                int value = counter.getValue();
                std::cout << "[Thread " << std::setw(2) << thread_id 
                         << "] Read value: " << value << std::endl;
                break;
        }
        
        // ëœë¤ ì§€ì—°ìœ¼ë¡œ ì‹¤ì œ ë™ì‹œì„± ì‹œë®¬ë ˆì´ì…˜
        std::this_thread::sleep_for(std::chrono::milliseconds(delay_dist(gen)));
    }
}

// ëª¨ë‹ˆí„°ë§ ìŠ¤ë ˆë“œ í•¨ìˆ˜
void monitor(ThreadSafeCounter& counter, std::atomic<bool>& stop_flag) {
    while (!stop_flag) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
        
        int value, inc_count, dec_count, read_count;
        counter.getStatistics(value, inc_count, dec_count, read_count);
        
        std::cout << "\n>>> Monitor Report: Value=" << value 
                  << ", Increments=" << inc_count 
                  << ", Decrements=" << dec_count 
                  << ", Reads=" << read_count 
                  << " <<<\n" << std::endl;
    }
}

int main() {
    std::cout << "=== Multi-threaded Counter Program ===" << std::endl;
    std::cout << "This program demonstrates thread-safe counter operations.\n" << std::endl;
    
    const int num_threads = 5;
    const int operations_per_thread = 10;
    
    ThreadSafeCounter counter(100);  // ì´ˆê¸°ê°’ 100
    std::atomic<bool> stop_monitor(false);
    
    std::cout << "Starting " << num_threads << " worker threads..." << std::endl;
    std::cout << "Each thread will perform " << operations_per_thread 
              << " random operations.\n" << std::endl;
    
    // ëª¨ë‹ˆí„°ë§ ìŠ¤ë ˆë“œ ì‹œì‘
    std::thread monitor_thread(monitor, std::ref(counter), std::ref(stop_monitor));
    
    // ì›Œì»¤ ìŠ¤ë ˆë“œë“¤ ì‹œì‘
    auto start_time = std::chrono::high_resolution_clock::now();
    std::vector<std::thread> workers;
    
    for (int i = 0; i < num_threads; ++i) {
        workers.emplace_back(worker, std::ref(counter), i, operations_per_thread);
    }
    
    // ëª¨ë“  ì›Œì»¤ ìŠ¤ë ˆë“œ ì¢…ë£Œ ëŒ€ê¸°
    for (auto& t : workers) {
        t.join();
    }
    
    auto end_time = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);
    
    // ëª¨ë‹ˆí„°ë§ ìŠ¤ë ˆë“œ ì¢…ë£Œ
    stop_monitor = true;
    monitor_thread.join();
    
    // ìµœì¢… í†µê³„ ì¶œë ¥
    int final_value, total_inc, total_dec, total_reads;
    counter.getStatistics(final_value, total_inc, total_dec, total_reads);
    
    std::cout << "\n=== Final Statistics ===" << std::endl;
    std::cout << "Execution time: " << duration.count() << " ms" << std::endl;
    std::cout << "Final counter value: " << final_value << std::endl;
    std::cout << "Total increments: " << total_inc << std::endl;
    std::cout << "Total decrements: " << total_dec << std::endl;
    std::cout << "Total reads: " << total_reads << std::endl;
    std::cout << "Total operations: " << (total_inc + total_dec + total_reads) << std::endl;
    std::cout << "Expected final value: " << (100 + total_inc - total_dec) << std::endl;
    
    if (final_value == (100 + total_inc - total_dec)) {
        std::cout << "\nâœ“ Counter synchronization successful!" << std::endl;
    } else {
        std::cout << "\nâœ— Counter synchronization failed!" << std::endl;
    }
    
    return 0;
}
```
  
  
## ê³ ê¸‰ ë½ ê´€ë¦¬ì™€ ì½ê¸°-ì“°ê¸° ë½

### std::unique_lockì˜ í™œìš©ê³¼ ìœ ì—°í•œ ë½ ê´€ë¦¬
std::unique_lockì€ std::lock_guardë³´ë‹¤ ë” ìœ ì—°í•œ ë½ ê´€ë¦¬ë¥¼ ì œê³µí•œë‹¤. ë½ì„ ì§€ì—°ì‹œí‚¤ê±°ë‚˜, ì‹œê°„ ì œí•œì„ ë‘ê±°ë‚˜, ì¡°ê±´ ë³€ìˆ˜ì™€ í•¨ê»˜ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

```
 std::lock_guard vs std::unique_lock
 
 lock_guard:                    unique_lock:
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚  ìƒì„± ì‹œ     â”‚               â”‚   ìœ ì—°í•œ     â”‚
 â”‚  ìë™ ì ê¸ˆ   â”‚               â”‚   ì ê¸ˆ ì œì–´   â”‚
 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤               â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 â”‚  ì†Œë©¸ ì‹œ     â”‚               â”‚  lock()     â”‚
 â”‚  ìë™ í•´ì œ   â”‚               â”‚  unlock()   â”‚
 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤               â”‚  try_lock() â”‚
 â”‚             â”‚               â”‚  try_lock_  â”‚
 â”‚  ë‹¨ìˆœí•˜ê³     â”‚               â”‚   for()     â”‚
 â”‚   ë¹ ë¦„       â”‚               â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚ ì¡°ê±´ë³€ìˆ˜ì™€    â”‚
                               â”‚  ì‚¬ìš© ê°€ëŠ¥    â”‚ 
                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```
  
```
#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>
#include <vector>
#include <condition_variable>

class ResourceManager {
private:
    std::mutex mtx_;
    std::condition_variable cv_;
    int resource_count_;
    bool resource_ready_;
    
public:
    ResourceManager() : resource_count_(0), resource_ready_(false) {}
    
    // 1. ì§€ì—°ëœ ì ê¸ˆ (Deferred Locking)
    void deferredLockExample(int thread_id) {
        std::unique_lock<std::mutex> lock(mtx_, std::defer_lock);
        
        // ë½ ì—†ì´ ì‘ì—… ìˆ˜í–‰
        std::cout << "[Thread " << thread_id << "] Doing work without lock..." << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        
        // í•„ìš”í•  ë•Œ ë½ íšë“
        lock.lock();
        std::cout << "[Thread " << thread_id << "] Lock acquired, accessing resource" << std::endl;
        resource_count_++;
        // ìë™ìœ¼ë¡œ unlock (RAII)
    }

    
    // 2. ì‹œê°„ ì œí•œ ì ê¸ˆ (Timed Locking)
    void timedLockExample(int thread_id) {
        std::unique_lock<std::mutex> lock(mtx_, std::defer_lock);
        
        // 100ms ë™ì•ˆ ë½ íšë“ ì‹œë„
        if (lock.try_lock_for(std::chrono::milliseconds(100))) {
            std::cout << "[Thread " << thread_id << "] Timed lock acquired!" << std::endl;
            resource_count_++;
            std::this_thread::sleep_for(std::chrono::milliseconds(200));
        } else {
            std::cout << "[Thread " << thread_id << "] Timed lock failed - timeout!" << std::endl;
        }
    }

    
    // 3. ì¡°ê±´ ë³€ìˆ˜ì™€ í•¨ê»˜ ì‚¬ìš©
    void waitForResource(int thread_id) {
        std::unique_lock<std::mutex> lock(mtx_);
        
        std::cout << "[Thread " << thread_id << "] Waiting for resource..." << std::endl;
        
        // ì¡°ê±´ì´ ì¶©ì¡±ë  ë•Œê¹Œì§€ ëŒ€ê¸°
        cv_.wait(lock, [this] { return resource_ready_; });
        
        std::cout << "[Thread " << thread_id << "] Resource available! Processing..." << std::endl;
        resource_count_++;
    }
    
    void makeResourceReady() {
        std::this_thread::sleep_for(std::chrono::seconds(1));
        
        {
            std::lock_guard<std::mutex> lock(mtx_);
            resource_ready_ = true;
            std::cout << "[Main] Resource is now ready!" << std::endl;
        }
        
        cv_.notify_all();  // ëª¨ë“  ëŒ€ê¸° ì¤‘ì¸ ìŠ¤ë ˆë“œ ê¹¨ìš°ê¸°
    }

    
    // 4. ë½ ì†Œìœ ê¶Œ ì´ì „ (Lock Ownership Transfer)
    std::unique_lock<std::mutex> acquireLock() {
        std::unique_lock<std::mutex> lock(mtx_);
        std::cout << "Lock acquired in function" << std::endl;
        resource_count_++;
        return lock;  // ì´ë™ ìƒì„±ìë¡œ ì†Œìœ ê¶Œ ì´ì „
    }
    
    void useLock(std::unique_lock<std::mutex> lock) {
        if (lock.owns_lock()) {
            std::cout << "Lock ownership transferred successfully" << std::endl;
            resource_count_++;
        }
    }
    

    // 5. ìˆ˜ë™ ì ê¸ˆ/í•´ì œ
    void manualLockUnlock(int thread_id) {
        std::unique_lock<std::mutex> lock(mtx_);
        
        std::cout << "[Thread " << thread_id << "] First critical section" << std::endl;
        resource_count_++;
        
        lock.unlock();  // ìˆ˜ë™ìœ¼ë¡œ í•´ì œ
        
        // ë½ ì—†ì´ ì‘ì—…
        std::cout << "[Thread " << thread_id << "] Non-critical work" << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
        
        lock.lock();  // ë‹¤ì‹œ íšë“
        
        std::cout << "[Thread " << thread_id << "] Second critical section" << std::endl;
        resource_count_++;
    }
    
    int getResourceCount() const {
        return resource_count_;
    }
};

int main() {
    std::cout << "=== std::unique_lock Advanced Features Demo ===" << std::endl;
    
    ResourceManager manager;
    
    // 1. Deferred Locking í…ŒìŠ¤íŠ¸
    std::cout << "\n--- Deferred Locking ---" << std::endl;
    {
        std::vector<std::thread> threads;
        for (int i = 0; i < 3; ++i) {
            threads.emplace_back(&ResourceManager::deferredLockExample, &manager, i);
        }
        for (auto& t : threads) {
            t.join();
        }
    }
    
    // 2. Timed Locking í…ŒìŠ¤íŠ¸
    std::cout << "\n--- Timed Locking ---" << std::endl;
    {
        std::thread t1(&ResourceManager::timedLockExample, &manager, 1);
        std::thread t2(&ResourceManager::timedLockExample, &manager, 2);
        t1.join();
        t2.join();
    }
    
    // 3. Condition Variable í…ŒìŠ¤íŠ¸
    std::cout << "\n--- Condition Variable ---" << std::endl;
    {
        std::vector<std::thread> waiters;
        for (int i = 0; i < 3; ++i) {
            waiters.emplace_back(&ResourceManager::waitForResource, &manager, i);
        }
        
        std::thread notifier(&ResourceManager::makeResourceReady, &manager);
        
        for (auto& t : waiters) {
            t.join();
        }
        notifier.join();
    }
    
    // 4. Lock Ownership Transfer í…ŒìŠ¤íŠ¸
    std::cout << "\n--- Lock Ownership Transfer ---" << std::endl;
    {
        auto lock = manager.acquireLock();
        manager.useLock(std::move(lock));
    }
    
    // 5. Manual Lock/Unlock í…ŒìŠ¤íŠ¸
    std::cout << "\n--- Manual Lock/Unlock ---" << std::endl;
    {
        std::thread t1(&ResourceManager::manualLockUnlock, &manager, 1);
        std::thread t2(&ResourceManager::manualLockUnlock, &manager, 2);
        t1.join();
        t2.join();
    }
    
    std::cout << "\nFinal resource count: " << manager.getResourceCount() << std::endl;
    
    return 0;
}
```


### std::shared_mutexì™€ ì½ê¸°-ì“°ê¸° ë½
ë§ì€ ìŠ¤ë ˆë“œê°€ ë°ì´í„°ë¥¼ ì½ê¸°ë§Œ í•˜ê³ , ê°€ë” ì“°ê¸° ì‘ì—…ì´ ë°œìƒí•˜ëŠ” ê²½ìš°, std::shared_mutexë¥¼ ì‚¬ìš©í•˜ë©´ ì„±ëŠ¥ì„ í¬ê²Œ í–¥ìƒì‹œí‚¬ ìˆ˜ ìˆë‹¤. ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ì½ê¸° ë½ì„ íšë“í•  ìˆ˜ ìˆì§€ë§Œ, ì“°ê¸° ë½ì€ ë°°íƒ€ì ì´ë‹¤.

```
 Shared Mutex ë™ì‘ ë°©ì‹
 
 ì½ê¸° ìŠ¤ë ˆë“œë“¤ (ê³µìœ  ë½):        ì“°ê¸° ìŠ¤ë ˆë“œ (ë°°íƒ€ì  ë½):
 â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚Readerâ”‚ â”‚Readerâ”‚ â”‚Readerâ”‚     â”‚  Writer  â”‚
 â”‚  1   â”‚ â”‚  2   â”‚ â”‚  3   â”‚     â”‚          â”‚
 â””â”€â”€â”¬â”€â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
    â”‚        â”‚        â”‚               â”‚
    â–¼        â–¼        â–¼               â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚   Shared Lock (ë™ì‹œ)    â”‚     â”‚Exclusiveâ”‚
 â”‚   ì—¬ëŸ¬ ì½ê¸° ê°€ëŠ¥         â”‚     â”‚  Lock   â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                         â”‚
            â–¼                         â–¼
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚   Data   â”‚              â”‚   Data   â”‚
     â”‚  (ì½ê¸°)   â”‚              â”‚  (ì“°ê¸°)  â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

- Reader (ì½ê¸° ìŠ¤ë ˆë“œ): ì—¬ëŸ¬ ê°œê°€ ë™ì‹œì— ë°ì´í„°ì— ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. (std::shared_lock ì‚¬ìš©)
- Writer (ì“°ê¸° ìŠ¤ë ˆë“œ): ì˜¤ì§ í•˜ë‚˜ë§Œ ë°ì´í„°ì— ì ‘ê·¼í•  ìˆ˜ ìˆìœ¼ë©°, ì´ ìŠ¤ë ˆë“œê°€ ì ‘ê·¼ ì¤‘ì¼ ë•ŒëŠ” ë‹¤ë¥¸ ëª¨ë“  ìŠ¤ë ˆë“œ(Reader í¬í•¨)ê°€ ëŒ€ê¸°í•´ì•¼ í•œë‹¤. (std::unique_lock ì‚¬ìš©)

#### 1. ê¸°ë³¸ Read/Write (get/put) ë°ëª¨
`shared_lock` (ì½ê¸°)ê³¼ `unique_lock` (ì“°ê¸°)ì˜ ê°€ì¥ ê¸°ë³¸ì ì¸ ì‚¬ìš©ë²•ì„ ë³´ì—¬wnsë‹¤.

**`1_basic_read_write.cpp`**

```cpp
#include <iostream>
#include <thread>
#include <shared_mutex>
#include <mutex>
#include <vector>
#include <map>
#include <string>
#include <chrono>
#include <random>
#include <iomanip>
#include <optional>

// ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ë‹¨ì¶•
namespace ch = std::chrono;

/**
 * @brief ìŠ¤ë ˆë“œ ì•ˆì „í•œ ìºì‹œ í´ë˜ìŠ¤ (std::shared_mutex ì‚¬ìš©)
 */
template<typename Key, typename Value>
class ThreadSafeCache {
private:
    mutable std::shared_mutex mutex_;
    std::map<Key, Value> cache_;
    mutable size_t read_count_ = 0;
    mutable size_t write_count_ = 0;
    
public:
    // ì½ê¸° ì‘ì—… - ê³µìœ  ë½ (ì—¬ëŸ¬ ìŠ¤ë ˆë“œ ë™ì‹œ ì ‘ê·¼ ê°€ëŠ¥)
    std::optional<Value> get(const Key& key) const {
        std::shared_lock<std::shared_mutex> lock(mutex_);
        read_count_++;
        std::cout << "[Cache] (Shared Lock) Reading key " << key << "..." << std::endl;
        
        auto it = cache_.find(key);
        if (it != cache_.end()) {
            std::this_thread::sleep_for(ch::milliseconds(10));
            return it->second;
        }
        return std::nullopt;
    }
    
    // ì“°ê¸° ì‘ì—… - ë°°íƒ€ì  ë½ (í•œ ë²ˆì— í•œ ìŠ¤ë ˆë“œë§Œ ì ‘ê·¼ ê°€ëŠ¥)
    void put(const Key& key, const Value& value) {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        write_count_++;
        std::cout << "[Cache] (Unique Lock) Writing key " << key << "..." << std::endl;
        
        std::this_thread::sleep_for(ch::milliseconds(50));
        cache_[key] = value;
    }

    // (ì´í›„ ë°ëª¨ì—ì„œ ì‚¬ìš©ë  í•¨ìˆ˜ë“¤ - ì§€ê¸ˆì€ í•„ìš” ì—†ì§€ë§Œ í´ë˜ìŠ¤ ì™„ê²°ì„±ì„ ìœ„í•´ í¬í•¨)
    void remove(const Key& key) {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        cache_.erase(key);
    }
    bool update_v1_flawed(const Key& key, const Value& new_value) { /* (ë°ëª¨ 6 ì°¸ê³ ) */ return false; }
    bool update(const Key& key, const Value& new_value) { /* (ë°ëª¨ 7 ì°¸ê³ ) */ return false; }

    // ìºì‹œ ë‚´ìš© ì¶œë ¥ (ë””ë²„ê¹…ìš©)
    void print() const {
        std::shared_lock<std::shared_mutex> lock(mutex_);
        std::cout << "\n--- Cache Contents (" << cache_.size() << " items) ---" << std::endl;
        for (const auto& [key, value] : cache_) {
            std::cout << "  " << std::setw(5) << key << " -> " << value << std::endl;
        }
        std::cout << "--------------------------------\n" << std::endl;
    }
};


int main() {
    std::cout << "--- 1. ê¸°ë³¸ Read/Write (get/put) ë°ëª¨ ---" << std::endl;
    ThreadSafeCache<int, std::string> cache;
    
    std::cout << "Putting (1, 'Apple')..." << std::endl;
    cache.put(1, "Apple");
    
    std::cout << "Putting (2, 'Banana')..." << std::endl;
    cache.put(2, "Banana");
    
    cache.print();
    
    std::cout << "Getting key 1..." << std::endl;
    if (auto val = cache.get(1)) {
        std::cout << "Found: " << *val << std::endl;
    }
    
    std::cout << "Getting key 3 (not found)..." << std::endl;
    if (auto val = cache.get(3)) {
        std::cout << "Found: " << *val << std::endl;
    } else {
        std::cout << "Key 3 not found." << std::endl;
    }
    
    std::cout << "--------------------------------------" << std::endl;
    return 0;
}
```


#### "Check-then-Act"(í™•ì¸ í›„ ì‹¤í–‰) ì˜¤ë¥˜

1.  **í™•ì¸ (Check):** ë‹¹ì‹ (ìŠ¤ë ˆë“œ A)ì´ ATMì—ì„œ ê³„ì¢Œ ì”ì•¡ì„ í™•ì¸í•œë‹¤. "10ë§Œ ì› ìˆë„¤!" (ì´ë•Œ **ì½ê¸° ë½** ğŸ”’ì„ ì‚¬ìš©)
2.  **ë½ í•´ì œ (Release):** í™•ì¸í–ˆìœ¼ë‹ˆ ì¼ë‹¨ ë½ì„ í‘¼ë‹¤.
3.  **í‹ˆ (The Gap):** ğŸ˜± ë‹¹ì‹ ì´ 'ì¶œê¸ˆ' ë²„íŠ¼ì„ ëˆ„ë¥´ëŸ¬ ê°€ëŠ” **ë°”ë¡œ ê·¸ 1ì´ˆ í‹ˆì—...**
4.  **ë‚œì… (Interrupt):** ë‹¤ë¥¸ ì‚¬ëŒ(ìŠ¤ë ˆë“œ B)ì´ ëª¨ë°”ì¼ ë±…í‚¹ìœ¼ë¡œ 10ë§Œ ì›ì„ ì „ë¶€ ì¸ì¶œí•´ ê°„ë‹¤. (ì´ë•Œ **ì“°ê¸° ë½** ğŸ”‘ì„ ì‚¬ìš©)
5.  **ì‹¤í–‰ (Act):** ë‹¹ì‹ ì€ "10ë§Œ ì› ìˆìœ¼ë‹ˆ 5ë§Œ ì› ì¶œê¸ˆí•´ì•¼ì§€"ë¼ê³  ìƒê°í•˜ë©° 'ì¶œê¸ˆ' ë²„íŠ¼ì„ ëˆ„ë¥¸ë‹¤. (ë‹¤ì‹œ **ì“°ê¸° ë½** ğŸ”‘ì„ ì¡ìŒ)
6.  **ê²°ê³¼:** âŒ ì”ì•¡ì´ 0ì›ì´ë¯€ë¡œ ì¶œê¸ˆì— ì‹¤íŒ¨í•œë‹¤.

**ë¬¸ì œì˜ í•µì‹¬:** ë‹¹ì‹ ì´ **í™•ì¸(Check)í•œ ì‹œì **ì˜ ì •ë³´(10ë§Œ ì›)ê°€, **ì‹¤í–‰(Act)í•˜ëŠ” ì‹œì **ì—ëŠ” ì´ë¯¸ ì˜›ë‚  ì •ë³´ê°€ ë˜ì–´ë²„ë¦° ê²ƒì´ë‹¤.

```cpp
// `flawed_updater` (ë‹¹ì‹ ): ë°ì´í„°ë¥¼ "Original"ì¸ì§€ í™•ì¸í•˜ê³  "Updated"ë¡œ ì‹¤í–‰(ìˆ˜ì •)í•˜ë ¤ í•œë‹¤.
// `remover` (ë‹¤ë¥¸ ì‚¬ëŒ): ë°ì´í„°ë¥¼ "Empty"ë¡œ ì‹¤í–‰(ìˆ˜ì •) í•œë‹¤.

#include <iostream>
#include <thread>
#include <shared_mutex>
#include <string>
#include <chrono>       // sleep_for ìš©
#include <iomanip>      // std::setw (ì¶œë ¥ ì •ë ¬ìš©)

// ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ë‹¨ì¶•
namespace ch = std::chrono;

// --- ë‹¨ìˆœí™”ëœ ì „ì—­ ìì› ---
std::shared_mutex mtx;
std::string shared_data;

/**
 * @brief [ë¬¸ì œì˜ í•¨ìˆ˜] í™•ì¸(Check)ê³¼ ì‹¤í–‰(Act) ì‚¬ì´ì— 'í‹ˆ'ì´ ìˆëŠ” í•¨ìˆ˜
 */
void flawed_updater() {
    // 1. í™•ì¸ (Check) - "ì½ê¸° ë½"
    {
        std::shared_lock lock(mtx);
        std::cout << "[Updater] (ì½ê¸° ë½) ë°ì´í„° í™•ì¸ ì¤‘...\n";
        if (shared_data != "Original") {
            std::cout << "[Updater] (ì½ê¸° ë½) 'Original'ì´ ì•„ë‹ˆë¼ì„œ ì¢…ë£Œ.\n";
            return;
        }
        std::cout << "[Updater] (ì½ê¸° ë½) 'Original' í™•ì¸! ë½ í•´ì œ.\n";
        std::this_thread::sleep_for(ch::milliseconds(10));
    } // <-- ğŸ”’ (ì½ê¸° ë½) ì—¬ê¸°ì„œ í•´ì œë¨

    // 2. í‹ˆ (The Gap) ğŸ˜±
    //    ì´ í•¨ìˆ˜ëŠ” ì“°ê¸° ë½ì„ ì¡ê¸° ì „ì— ì ì‹œ ë©ˆì¶¥ë‹ˆë‹¤.
    //    ì´ 'í‹ˆ' ë™ì•ˆ ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ë¼ì–´ë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤!
    std::cout << "[Updater] (ë½ ì—†ìŒ) ì“°ê¸° ë½ ì¡ëŠ” ì¤‘... (í‹ˆ ë°œìƒ)\n";
    std::this_thread::sleep_for(ch::milliseconds(100)); // í‹ˆì„ ì¸ìœ„ì ìœ¼ë¡œ ê¸¸ê²Œ ë§Œë“¦

    // 3. ì‹¤í–‰ (Act) - "ì“°ê¸° ë½"
    {
        std::unique_lock lock(mtx);
        std::cout << "[Updater] (ì“°ê¸° ë½) 'Updated'ë¡œ ë³€ê²½ ì‹œë„...\n";
        
        // ì¤‘ìš”: ë½ì„ ë‹¤ì‹œ ì¡ì•˜ìœ¼ë©´, ë°˜ë“œì‹œ ë°ì´í„°ë¥¼ 'ë‹¤ì‹œ í™•ì¸'í•´ì•¼ í•©ë‹ˆë‹¤.
        if (shared_data == "Original") {
            shared_data = "Updated";
            std::cout << "[Updater] (ì“°ê¸° ë½) â˜…â˜…â˜… ë³€ê²½ ì„±ê³µ! â˜…â˜…â˜…\n";
        } else {
            std::cout << "[Updater] (ì“°ê¸° ë½) âŒ ì´ëŸ°! ê·¸ìƒˆ ë°ì´í„°ê°€ ë°”ë€œ! âŒ\n";
            std::cout << "          (í˜„ì¬ ê°’: '" << shared_data << "')\n";
        }
    }
}

/**
 * @brief [ë‚œì…í•˜ëŠ” í•¨ìˆ˜] ë°ì´í„°ë¥¼ ê·¸ëƒ¥ ìˆ˜ì •í•˜ëŠ” í•¨ìˆ˜
 */
void remover() {
    std::unique_lock lock(mtx);
    std::cout << "          [Remover] (ì“°ê¸° ë½) ë°ì´í„° 'Empty'ë¡œ ë³€ê²½!\n";
    shared_data = "Empty";
}

int main() {
    shared_data = "Original";
    std::cout << "--- 'Check-then-Act' ë¬¸ì œ ë°ëª¨ --- \n";
    std::cout << "Updaterê°€ ë°ì´í„°ë¥¼ í™•ì¸(Check)í•œ 'í‹ˆ'ì— Removerê°€ ë¼ì–´ë“¤ ê²ƒì…ë‹ˆë‹¤.\n";
    std::cout << "ì´ˆê¸° ë°ì´í„°: " << shared_data << "\n\n";

    // 1. Updater ìŠ¤ë ˆë“œ ì‹œì‘
    std::thread updater_thread(flawed_updater);

    // 2. Updaterê°€ 'í‹ˆ'ì— ë¹ ì§ˆ ë•Œê¹Œì§€ ì ì‹œ ëŒ€ê¸° (ì•½ 30ms)
    std::this_thread::sleep_for(ch::milliseconds(30));

    // 3. Remover ìŠ¤ë ˆë“œ ì‹œì‘ (ë°”ë¡œ 'í‹ˆ'ì„ ë¹„ì§‘ê³  ë“¤ì–´ê°)
    std::cout << "          [Main] Remover ë¼ì–´ë“¤ê¸° ì‹œì‘! ->\n";
    std::thread remover_thread(remover);

    // 4. ëª¨ë“  ìŠ¤ë ˆë“œ ì¢…ë£Œ ëŒ€ê¸°
    updater_thread.join();
    remover_thread.join();

    std::cout << "\n--- ëª¨ë“  ì‘ì—… ì™„ë£Œ --- \n";
    std::cout << "ìµœì¢… ë°ì´í„°: '" << shared_data << "'\n";
    std::cout << "(Updaterê°€ ì‹¤íŒ¨í•˜ê³  'Empty'ê°€ ë˜ì–´ì•¼ ì •ìƒ)\n";

    return 0;
}
```

ì˜ˆìƒ ì‹¤í–‰ ê²°ê³¼

```
--- 'Check-then-Act' ë¬¸ì œ ë°ëª¨ --- 
Updaterê°€ ë°ì´í„°ë¥¼ í™•ì¸(Check)í•œ 'í‹ˆ'ì— Removerê°€ ë¼ì–´ë“¤ ê²ƒì…ë‹ˆë‹¤.
ì´ˆê¸° ë°ì´í„°: Original

[Updater] (ì½ê¸° ë½) ë°ì´í„° í™•ì¸ ì¤‘...
[Updater] (ì½ê¸° ë½) 'Original' í™•ì¸! ë½ í•´ì œ.
[Updater] (ë½ ì—†ìŒ) ì“°ê¸° ë½ ì¡ëŠ” ì¤‘... (í‹ˆ ë°œìƒ)
          [Main] Remover ë¼ì–´ë“¤ê¸° ì‹œì‘! ->
          [Remover] (ì“°ê¸° ë½) ë°ì´í„° 'Empty'ë¡œ ë³€ê²½!
[Updater] (ì“°ê¸° ë½) 'Updated'ë¡œ ë³€ê²½ ì‹œë„...
[Updater] (ì“°ê¸° ë½) âŒ ì´ëŸ°! ê·¸ìƒˆ ë°ì´í„°ê°€ ë°”ë€œ! âŒ
          (í˜„ì¬ ê°’: 'Empty')

--- ëª¨ë“  ì‘ì—… ì™„ë£Œ --- 
ìµœì¢… ë°ì´í„°: 'Empty'
(Updaterê°€ ì‹¤íŒ¨í•˜ê³  'Empty'ê°€ ë˜ì–´ì•¼ ì •ìƒ)
```

#### "Check-then-Act" ë¬¸ì œ: upgrade_lock ìœ¼ë¡œ í•´ê²°í•˜ê¸°

1.  **í™•ì¸ (Check) - "ìŠ¹ê¸‰ìš© ë½" ğŸ–ï¸:** ë‹¹ì‹ (ìŠ¤ë ˆë“œ A)ì´ ATMì—ì„œ "ì¶œê¸ˆí•  **ìˆ˜ë„ ìˆìœ¼ë‹ˆ** ì”ì•¡ í™•ì¸ ì¢€ í• ê²Œìš”"ë¼ê³  ìš”ì²­í•œë‹¤. (ì´ë•Œ **`upgrade_lock`** ğŸ”’ ì‚¬ìš©)
      * ì´ ë½ì€ ë‹¤ë¥¸ **ì½ê¸° ì „ìš©** ì†ë‹˜ë“¤(`shared_lock`)ì€ í—ˆìš©í•œë‹¤.
      * í•˜ì§€ë§Œ ë‹¤ë¥¸ **ì“°ê¸°** ì†ë‹˜(`unique_lock`)ì´ë‚˜ **ë‹¤ë¥¸ ìŠ¹ê¸‰ìš©** ì†ë‹˜(`upgrade_lock`)ì€ ë§‰ëŠ”ë‹¤.
2.  **í™•ì¸:** "10ë§Œ ì› ìˆë„¤!"
3.  **ìŠ¹ê¸‰ (Promote) - "ì“°ê¸° ë½" ğŸ”‘:** ë‹¹ì‹ ì€ ë½ì„ í’€ì§€ ì•Šê³ , ê·¸ ìë¦¬ì—ì„œ ë°”ë¡œ "ì´ì œ ì§„ì§œ ì¶œê¸ˆí• ê²Œìš”!"ë¼ë©° ì°½êµ¬ ì§ì›ì—ê²Œ **`unique_lock`**ìœ¼ë¡œ ë°”ê¿”ë‹¬ë¼ê³  ìš”ì²­í•œë‹¤. (ì´ë•Œ `std::upgrade_to_unique_lock` ì‚¬ìš©)
      * **í‹ˆì´ ì—†ë‹¤.** ë½ì´ í’€ë¦° ì ì´ ì—†ê¸° ë•Œë¬¸ì´ë‹¤.
      * (ë§Œì•½ ë™ì‹œì— ìˆë˜ ë‹¤ë¥¸ 'ì½ê¸°' ì†ë‹˜ë“¤ì´ ìˆë‹¤ë©´, ê·¸ë“¤ì´ ë‚˜ê°ˆ ë•Œê¹Œì§€ ì ê¹ ê¸°ë‹¤ë¦° í›„ ë½ì„ ìŠ¹ê¸‰ì‹œí‚¨ë‹¤.)
4.  **ì‹¤í–‰ (Act):** "5ë§Œ ì› ì¶œê¸ˆ ì™„ë£Œ."
5.  **ê²°ê³¼:** âœ… ë‹¹ì‹ ì´ í™•ì¸í•œ ì •ë³´(10ë§Œ ì›)ê°€ ì‹¤í–‰ ì‹œì ì—ë„ ìœ íš¨í•¨ì´ ë³´ì¥ëœë‹¤. ê·¸ì‚¬ì´ ì•„ë¬´ë„ ë¼ì–´ë“¤ì§€ ëª»í–ˆë‹¤.
  
`flawed_updater` ëŒ€ì‹  `correct_updater` í•¨ìˆ˜ë¥¼ ë§Œë“¤ì—ˆë‹¤. `remover` ìŠ¤ë ˆë“œëŠ” ì´ì „ê³¼ ë™ì¼í•˜ë‹¤.

```cpp
#include <iostream>
#include <thread>
#include <shared_mutex> // upgrade_lock, upgrade_to_unique_lock í¬í•¨
#include <string>
#include <chrono>       // sleep_for ìš©
#include <iomanip>      // std::setw (ì¶œë ¥ ì •ë ¬ìš©)

// ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ë‹¨ì¶•
namespace ch = std::chrono;

// --- ë‹¨ìˆœí™”ëœ ì „ì—­ ìì› ---
std::shared_mutex mtx;
std::string shared_data;

/**
 * @brief [í•´ê²°ëœ í•¨ìˆ˜] 'upgrade_lock'ì„ ì‚¬ìš©í•´ í‹ˆ(Gap) ì—†ì´ ì•ˆì „í•˜ê²Œ ì—…ë°ì´íŠ¸
 */
void correct_updater() {
    
    // 1. í™•ì¸ (Check) - "ìŠ¹ê¸‰ìš© ë½" ğŸ–ï¸
    //    (ë‹¤ë¥¸ shared_lockì€ í—ˆìš©, unique/upgrade ë½ì€ ì°¨ë‹¨)
    std::upgrade_lock<std::shared_mutex> lock(mtx);
    std::cout << "[Updater] (Upgrade Lock ğŸ–ï¸) ë°ì´í„° í™•ì¸ ì¤‘...\n";

    if (shared_data != "Original") {
        std::cout << "[Updater] (Upgrade Lock ğŸ–ï¸) 'Original'ì´ ì•„ë‹ˆë¼ì„œ ì¢…ë£Œ.\n";
        return; // ë½ ìë™ í•´ì œ
    }

    std::cout << "[Updater] (Upgrade Lock ğŸ–ï¸) 'Original' í™•ì¸! ì“°ê¸° ë½ìœ¼ë¡œ ìŠ¹ê¸‰ ì‹œë„...\n";
    std::this_thread::sleep_for(ch::milliseconds(10));

    // 2. ìŠ¹ê¸‰ (Promote) & 3. ì‹¤í–‰ (Act) - "ì“°ê¸° ë½" ğŸ”‘
    //    (ë½ì„ í’€ì§€ ì•Šê³ , ê·¸ ìë¦¬ì—ì„œ ë°”ë¡œ 'unique_lock'ìœ¼ë¡œ ìŠ¹ê¸‰)
    std::upgrade_to_unique_lock<std::shared_mutex> unique_lock(std::move(lock));
    
    std::cout << "[Updater] (Unique Lock ğŸ”‘) â˜…â˜…â˜… ìŠ¹ê¸‰ ì„±ê³µ! ë³€ê²½ ì‹¤í–‰! â˜…â˜…â˜…\n";
    shared_data = "Updated";
    std::cout << "[Updater] (Unique Lock ğŸ”‘) ë³€ê²½ ì™„ë£Œ. ë½ í•´ì œ.\n";
    std::this_thread::sleep_for(ch::milliseconds(50));
    
    // 'unique_lock'ì´ ì—¬ê¸°ì„œ í•´ì œë¨ (ì›ë˜ 'lock'ë„ ê°™ì´)
}

/**
 * @brief [ìˆ˜ì • í•¨ìˆ˜] ë°ì´í„°ë¥¼ ê·¸ëƒ¥ ìˆ˜ì •í•˜ëŠ” í•¨ìˆ˜ (ì´ì „ê³¼ ë™ì¼)
 */
void remover() {
    // 'correct_updater'ê°€ ë½ì„ ì¡ê³  ìˆìœ¼ë¯€ë¡œ(Upgradeë“  Uniqueë“ ) ëŒ€ê¸°í•´ì•¼ í•¨
    std::cout << "          [Remover] (ëŒ€ê¸° ì¤‘) ì“°ê¸° ë½ ğŸ”‘ ìš”ì²­...\n";
    std::unique_lock lock(mtx);
    std::cout << "          [Remover] (ì“°ê¸° ë½ ğŸ”‘) íšë“! 'Empty'ë¡œ ë³€ê²½!\n";
    shared_data = "Empty";
}

int main() {
    shared_data = "Original";
    std::cout << "--- 'upgrade_lock' í•´ê²° ë°ëª¨ --- \n";
    std::cout << "Updaterê°€ ë½ì„ ìŠ¹ê¸‰í•˜ëŠ” ë™ì•ˆ RemoverëŠ” ë¼ì–´ë“¤ì§€ ëª»í•˜ê³  ëŒ€ê¸°í•©ë‹ˆë‹¤.\n";
    std::cout << "ì´ˆê¸° ë°ì´í„°: " << shared_data << "\n\n";

    // 1. Updater ìŠ¤ë ˆë“œ ì‹œì‘
    std::thread updater_thread(correct_updater);

    // 2. Updaterê°€ 'upgrade_lock'ì„ ì¡ì„ ì‹œê°„ì„ ì¤Œ
    std::this_thread::sleep_for(ch::milliseconds(5));

    // 3. Remover ìŠ¤ë ˆë“œ ì‹œì‘ (Updaterê°€ ë½ì„ ì¥ê³  ìˆìœ¼ë¯€ë¡œ ëŒ€ê¸°í•¨)
    std::cout << "          [Main] Remover ì‹œì‘ (ëŒ€ê¸°í•´ì•¼ í•¨) ->\n";
    std::thread remover_thread(remover);

    // 4. ëª¨ë“  ìŠ¤ë ˆë“œ ì¢…ë£Œ ëŒ€ê¸°
    updater_thread.join();
    remover_thread.join();

    std::cout << "\n--- ëª¨ë“  ì‘ì—… ì™„ë£Œ --- \n";
    std::cout << "ìµœì¢… ë°ì´í„°: '" << shared_data << "'\n";
    std::cout << "(Updaterê°€ ë¨¼ì € ì„±ê³µ('Updated')í•˜ê³ , Removerê°€ ë®ì–´ì¨('Empty')ì•¼ ì •ìƒ)\n";

    return 0;
}
```

  
### ë°ë“œë½ ë°©ì§€ ê¸°ë²•ê³¼ std::lock()
ë°ë“œë½ì€ ë‘ ê°œ ì´ìƒì˜ ìŠ¤ë ˆë“œê°€ ì„œë¡œê°€ ë³´ìœ í•œ ë¦¬ì†ŒìŠ¤ë¥¼ ê¸°ë‹¤ë¦¬ë©° ë¬´í•œ ëŒ€ê¸°í•˜ëŠ” ìƒí™©ì´ë‹¤. C++ëŠ” std::lock()ê³¼ std::scoped_lockì„ ì œê³µí•˜ì—¬ ë°ë“œë½ì„ ë°©ì§€í•œë‹¤.

`std::lock()` í•¨ìˆ˜ëŠ” **ì—¬ëŸ¬ ê°œì˜ ë®¤í…ìŠ¤(mutex)ë¥¼ í•œêº¼ë²ˆì— ì ê¸€ ë•Œ** ì‚¬ìš©í•œë‹¤.

ê°€ì¥ ì¤‘ìš”í•œ ê¸°ëŠ¥ì€ **êµì°© ìƒíƒœ(Deadlock)ë¥¼ ë°©ì§€**í•´ì¤€ë‹¤ëŠ” ê²ƒì´ë‹¤.

#### ğŸ¤·â€â™‚ï¸ ì´ê²Œ ì™œ í•„ìš”í•œê°€? (êµì°© ìƒíƒœ ë¬¸ì œ)
ë§Œì•½ ë‘ ê°œì˜ ë®¤í…ìŠ¤ `m1`ê³¼ `m2`ê°€ ìˆê³ , ë‘ ìŠ¤ë ˆë“œê°€ ì´ ë½ì„ ì¡ìœ¼ë ¤ í•œë‹¤ê³  ê°€ì •í•´ ë³´ì.

  * **ìŠ¤ë ˆë“œ 1:** `m1`ì„ ì ê·¸ê³  â¡ï¸ `m2`ë¥¼ ì ê·¸ë ¤ í•¨
  * **ìŠ¤ë ˆë“œ 2:** `m2`ë¥¼ ì ê·¸ê³  â¡ï¸ `m1`ì„ ì ê·¸ë ¤ í•¨ (ìˆœì„œê°€ ë°˜ëŒ€)

ìš´ì´ ë‚˜ì˜ë©´ ì´ëŸ° ìƒí™©ì´ ë°œìƒí•œë‹¤:

1.  ìŠ¤ë ˆë“œ 1ì´ `m1`ì„ ì ê·¼ë‹¤. ğŸ”’
2.  ë™ì‹œì— ìŠ¤ë ˆë“œ 2ê°€ `m2`ë¥¼ ì ê·¼ë‹¤. ğŸ”‘
3.  ìŠ¤ë ˆë“œ 1ì€ `m2`ê°€ í’€ë¦¬ê¸°ë¥¼ ì˜ì›íˆ ê¸°ë‹¤ë¦¬ê³ , ìŠ¤ë ˆë“œ 2ëŠ” `m1`ì´ í’€ë¦¬ê¸°ë¥¼ ì˜ì›íˆ ê¸°ë‹¤ë¦°ë‹¤.
4.  âŒ **êµì°© ìƒíƒœ (Deadlock) ë°œìƒ\!** í”„ë¡œê·¸ë¨ì´ ë©ˆì¶˜ë‹¤.

#### âœ… `std::lock()`ì˜ í•´ê²°ì±…
`std::lock(m1, m2);`ëŠ” **"ì „ë¶€ ë‹¤ ì ê·¸ê±°ë‚˜, ì•„ë‹ˆë©´ í•˜ë‚˜ë„ ì ê·¸ì§€ ì•Šê±°ë‚˜"** ë°©ì‹ìœ¼ë¡œ ë™ì‘í•œë‹¤.

`std::lock()`ì€ ë‚´ë¶€ì ìœ¼ë¡œ ë°ë“œë½ì„ í”¼í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜(ì˜ˆ: ë½ì„ ìˆœì„œëŒ€ë¡œ ì •ë ¬í•´ì„œ ì¡ê¸°)ì„ ì‚¬ìš©í•´ì„œ, ë‘ ë®¤í…ìŠ¤ë¥¼ í•œ ë²ˆì— ì ê·¼ ê²ƒì²˜ëŸ¼ ì²˜ë¦¬í•´ ì¤€ë‹¤. ìœ„ì™€ ê°™ì€ êµì°© ìƒíƒœê°€ ì ˆëŒ€ë¡œ ë°œìƒí•˜ì§€ ì•ŠëŠ”ë‹¤.


#### ì‚¬ìš© ë°©ë²• (RAII)
`std::lock()` í•¨ìˆ˜ëŠ” ë½ì„ **ì ê·¸ê¸°ë§Œ** í•  ë¿, **ìë™ìœ¼ë¡œ í•´ì œí•´ì£¼ì§€ ì•ŠëŠ”ë‹¤.**

```cpp
// âŒ ë‚˜ìœ ë°©ë²•: ì§ì ‘ unlock()ì„ í˜¸ì¶œí•´ì•¼ í•´ì„œ ìŠì–´ë²„ë¦¬ê¸° ì‰½ìŠµë‹ˆë‹¤.
std::lock(m1, m2);
// ... ìœ„í—˜í•œ ì‘ì—… ...
if (/*...*/) {
    m1.unlock(); // ì—¬ê¸°ì„œ unlock()ì„ ìŠìœ¼ë©´ í°ì¼!
    m2.unlock();
    return;
}
m1.unlock();
m2.unlock();
```

ë”°ë¼ì„œ `std::lock_guard`ì™€ `std::adopt_lock` íƒœê·¸ë¥¼ í•¨ê»˜ ì“°ëŠ” ê²ƒì´ ì •ì„ì´ë‹¤.

```cpp
#include <mutex>
#include <thread>

std::mutex m1;
std::mutex m2;

void safe_function() {
    // 1. ë¨¼ì € ë°ë“œë½ ë°©ì§€ ì ê¸ˆì„ ì‹¤í–‰
    std::lock(m1, m2);

    // 2. ë½ì˜ "ì†Œìœ ê¶Œ"ë§Œ lock_guardì—ê²Œ ë„˜ê¹€ (adopt_lock)
    // (adopt_lock: "ì´ë¯¸ ì ê²¨ìˆìœ¼ë‹ˆ ë‹¤ì‹œ ì ê·¸ì§€ ë§ê³ , ëë‚˜ë©´ 'í’€ì–´ì£¼ê¸°'ë§Œ í•´")
    std::lock_guard<std::mutex> guard1(m1, std::adopt_lock);
    std::lock_guard<std::mutex> guard2(m2, std::adopt_lock);

    // ... m1ê³¼ m2ê°€ ëª¨ë‘ í•„ìš”í•œ ì•ˆì „í•œ ì‘ì—… ...

} // <-- í•¨ìˆ˜ê°€ ëë‚˜ë©´ guard1, guard2ê°€ ìë™ìœ¼ë¡œ m1, m2ë¥¼ unlock() í•´ì¤Œ
```

#### C++17 ì´ìƒ: ë” ì‰¬ìš´ ë°©ë²• `std::scoped_lock`
C++17ë¶€í„°ëŠ” ì´ ëª¨ë“  ê³¼ì •ì„ í•œ ë²ˆì— í•´ì£¼ëŠ” `std::scoped_lock`ì´ ìˆìŠµë‹ˆë‹¤. **ì´ê²ƒì„ ì“°ëŠ” ê²ƒì´ ê°€ì¥ ì¢‹ë‹¤.**

`std::scoped_lock`ì€ ìƒì„±ìì—ì„œ `std::lock()`ê³¼ ê°™ì€ ë°©ì‹ìœ¼ë¡œ ëª¨ë“  ë®¤í…ìŠ¤ë¥¼ ì ê·¸ê³ , ì†Œë©¸ìì—ì„œ ëª¨ë“  ë½ì„ ìë™ìœ¼ë¡œ í•´ì œ(unlock)í•œë‹¤.

```cpp
#include <mutex>
#include <thread>

std::mutex m1;
std::mutex m2;

void best_safe_function() {
    // 1. ìƒì„±ìì—ì„œ m1, m2ë¥¼ ë°ë“œë½ ì—†ì´ í•œ ë²ˆì— ì ê¸ˆ
    std::scoped_lock lock(m1, m2); 

    // ... m1ê³¼ m2ê°€ ëª¨ë‘ í•„ìš”í•œ ì•ˆì „í•œ ì‘ì—… ...

} // <-- í•¨ìˆ˜ê°€ ëë‚˜ë©´ lockì´ ìë™ìœ¼ë¡œ m1, m2ë¥¼ unlock() í•´ì¤Œ
```

**ìš”ì•½:**
* **`std::lock`**: ì—¬ëŸ¬ ë®¤í…ìŠ¤ë¥¼ **ë°ë“œë½ ì—†ì´** ì ê°€ì£¼ëŠ” *í•¨ìˆ˜*. (ìˆ˜ë™ í•´ì œ í•„ìš”)
* **`std::scoped_lock`**: ì—¬ëŸ¬ ë®¤í…ìŠ¤ë¥¼ **ë°ë“œë½ ì—†ì´** ì ê·¸ê³  *ìë™ìœ¼ë¡œ í•´ì œ*í•´ì£¼ëŠ” *í´ë˜ìŠ¤*. (C++17 ì´ìƒ ê¶Œì¥)

      
### ìŠ¤ë ˆë“œ ìƒëª…ì£¼ê¸° ê´€ë¦¬
ìŠ¤ë ˆë“œì˜ ìƒëª…ì£¼ê¸°ë¥¼ ì˜¬ë°”ë¥´ê²Œ ê´€ë¦¬í•˜ëŠ” ê²ƒì€ ì•ˆì •ì ì¸ ë©€í‹°ìŠ¤ë ˆë“œ í”„ë¡œê·¸ë¨ ì‘ì„±ì˜ í•µì‹¬ì´ë‹¤. join(), detach(), joinable() ë©”ì„œë“œë¥¼ ì ì ˆíˆ ì‚¬ìš©í•´ì•¼ í•œë‹¤.

```
 ìŠ¤ë ˆë“œ ìƒëª…ì£¼ê¸° ìƒíƒœ:
 
    [ìƒì„±]
      â”‚
      â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚Joinable â”‚ â”€â”€â”€â”€â”€â”€â–º detach() â”€â”€â”€â”€â”€â”€â–º [Detached]
 â”‚ ìƒíƒœ    â”‚                          (ë…ë¦½ ì‹¤í–‰)
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â–¼
   join()
      â”‚
      â–¼
  [Joined]
 (ì¢…ë£Œ ëŒ€ê¸°)
```
    

#### `join()`  

**`1_join_demo.cpp`**

```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <string>
#include <mutex>

// ìŠ¤ë ˆë“œ ì•ˆì „í•œ ë¡œê¹…ì„ ìœ„í•œ ë®¤í…ìŠ¤
std::mutex cout_mutex;

void safe_print(const std::string& msg) {
    std::lock_guard<std::mutex> lock(cout_mutex);
    std::cout << msg << std::endl;
}

// ìŠ¤ë ˆë“œê°€ ì‹¤í–‰í•  ì‘ì—… í•¨ìˆ˜
void shortTask(int id) {
    safe_print("Short task " + std::to_string(id) + " started");
    std::this_thread::sleep_for(std::chrono::milliseconds(500));
    safe_print("Short task " + std::to_string(id) + " completed");
}

int main() {
    std::cout << "\n=== 1. join() Demonstration ===" << std::endl;
    std::cout << "join()ì€ ìŠ¤ë ˆë“œê°€ ì™„ë£Œë  ë•Œê¹Œì§€ ë©”ì¸ ìŠ¤ë ˆë“œë¥¼ ì°¨ë‹¨(block)í•©ë‹ˆë‹¤.\n" << std::endl;
    
    std::thread t1(shortTask, 1);
    std::cout << "Main: ìŠ¤ë ˆë“œ ìƒì„±ë¨. Joinable? " << (t1.joinable() ? "Yes" : "No") << std::endl;
    
    std::cout << "Main: t1ì´ ì™„ë£Œë  ë•Œê¹Œì§€ ëŒ€ê¸°í•©ë‹ˆë‹¤..." << std::endl;
    
    // t1 ìŠ¤ë ˆë“œê°€ ì¢…ë£Œë  ë•Œê¹Œì§€ ì—¬ê¸°ì„œ ëŒ€ê¸°í•©ë‹ˆë‹¤.
    t1.join(); 
    
    std::cout << "Main: t1.join() ì™„ë£Œë¨." << std::endl;
    std::cout << "Main: join() í˜¸ì¶œ í›„ Joinable? " << (t1.joinable() ? "Yes" : "No") << std::endl;
    
    return 0;
}
```


#### `detach()` (ë…ë¦½ ì‹¤í–‰)

**`2_detach_demo.cpp`**

```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <string>
#include <mutex>
#include <atomic> // std::atomic

// ìŠ¤ë ˆë“œ ì•ˆì „í•œ ë¡œê¹…
std::mutex cout_mutex;
void safe_print(const std::string& msg) {
    std::lock_guard<std::mutex> lock(cout_mutex);
    std::cout << msg << std::endl;
}

// ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì˜¤ë˜ ì‹¤í–‰ë  ì‘ì—…
void longTask(int id, std::atomic<bool>& should_stop) {
    safe_print("Long task " + std::to_string(id) + " started (ë°±ê·¸ë¼ìš´ë“œ ì‹¤í–‰)");
    
    // should_stop í”Œë˜ê·¸ê°€ trueê°€ ë  ë•Œê¹Œì§€ 100msë§ˆë‹¤ ì²´í¬
    while (!should_stop) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    
    safe_print("Long task " + std::to_string(id) + " stopped");
}

int main() {
    std::cout << "\n=== 2. detach() Demonstration ===" << std::endl;
    std::cout << "detach()ëŠ” ìŠ¤ë ˆë“œë¥¼ ë©”ì¸ ìŠ¤ë ˆë“œì™€ ë¶„ë¦¬í•˜ì—¬ ë…ë¦½ì ìœ¼ë¡œ ì‹¤í–‰ì‹œí‚µë‹ˆë‹¤.\n" << std::endl;
    
    // ë¶„ë¦¬ëœ ìŠ¤ë ˆë“œë¥¼ ì œì–´í•˜ê¸° ìœ„í•œ í”Œë˜ê·¸
    std::atomic<bool> stop_flag(false);
    
    std::thread t2(longTask, 2, std::ref(stop_flag));
    std::cout << "Main: ìŠ¤ë ˆë“œ ìƒì„±ë¨. Joinable? " << (t2.joinable() ? "Yes" : "No") << std::endl;
    
    // ìŠ¤ë ˆë“œë¥¼ ë¶„ë¦¬í•©ë‹ˆë‹¤.
    // ì´ì œ t2 ê°ì²´ëŠ” ë” ì´ìƒ ì‹¤ì œ ì‹¤í–‰ ìŠ¤ë ˆë“œë¥¼ ì°¸ì¡°í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
    t2.detach(); 
    
    std::cout << "Main: ìŠ¤ë ˆë“œ ë¶„ë¦¬ë¨. Joinable? " << (t2.joinable() ? "Yes" : "No") << std::endl;
    
    std::cout << "Main: 0.5ì´ˆ ëŒ€ê¸°... (ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œëŠ” ê³„ì† ì‹¤í–‰ ì¤‘)" << std::endl;
    std::this_thread::sleep_for(std::chrono::milliseconds(500));
    
    std::cout << "Main: ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œì— ì¢…ë£Œ ì‹ í˜¸ ì „ì†¡" << std::endl;
    stop_flag = true; // ìŠ¤ë ˆë“œì— ì¢…ë£Œë¥¼ ì•Œë¦¼
    
    // ë¶„ë¦¬ëœ ìŠ¤ë ˆë“œê°€ ì™„ì „íˆ ì¢…ë£Œë  ì‹œê°„ì„ ì¤ë‹ˆë‹¤.
    // (ì´ê±¸ ì•ˆ í•´ì£¼ë©´ mainì´ ë¨¼ì € ëë‚˜ì„œ ìŠ¤ë ˆë“œê°€ ê°•ì œ ì¢…ë£Œë  ìˆ˜ ìˆìŒ)
    std::this_thread::sleep_for(std::chrono::milliseconds(200));
    
    std::cout << "Main: í”„ë¡œê·¸ë¨ ì¢…ë£Œ." << std::endl;
    return 0;
}
```


#### `joinable()` ì²´í¬ 

**`3_joinable_demo.cpp`**

```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <string>
#include <mutex>
#include <vector> // std::move ìš©

// ìŠ¤ë ˆë“œ ì•ˆì „í•œ ë¡œê¹…
std::mutex cout_mutex;
void safe_print(const std::string& msg) {
    std::lock_guard<std::mutex> lock(cout_mutex);
    std::cout << msg << std::endl;
}

void shortTask(int id) {
    safe_print("Short task " + std::to_string(id) + " started/completed");
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
}

int main() {
    std::cout << "\n=== 3. joinable() Demonstration ===" << std::endl;
    std::cout << "join()ì´ë‚˜ detach() ì „ì— í•­ìƒ joinable()ì„ ì²´í¬í•´ì•¼ í•©ë‹ˆë‹¤.\n" << std::endl;
    
    // Case 1: ê¸°ë³¸ ìƒì„±ëœ ìŠ¤ë ˆë“œ (ì‹¤í–‰ ì¤‘ì´ ì•„ë‹˜)
    std::thread t1;
    std::cout << "Case 1: ê¸°ë³¸ ìƒì„±ëœ t1. Joinable? " 
              << (t1.joinable() ? "Yes" : "No") << std::endl;
    
    // Case 2: ì‘ì—…ì´ ì™„ë£Œë˜ê³  join()ëœ ìŠ¤ë ˆë“œ
    std::thread t2(shortTask, 2);
    t2.join(); // ì—¬ê¸°ì„œ join
    std::cout << "Case 2: join()ì´ ì™„ë£Œëœ t2. Joinable? " 
              << (t2.joinable() ? "Yes" : "No") << std::endl;
    
    // Case 3: ì‘ì—…ì´ ì™„ë£Œë˜ê³  detach()ëœ ìŠ¤ë ˆë“œ
    std::thread t3(shortTask, 3);
    t3.detach(); // ì—¬ê¸°ì„œ detach
    std::cout << "Case 3: detach()ê°€ ì™„ë£Œëœ t3. Joinable? " 
              << (t3.joinable() ? "Yes" : "No") << std::endl;
              
    // Case 4: ì†Œìœ ê¶Œì´ ì´ì „ëœ(moved) ìŠ¤ë ˆë“œ
    std::thread t4(shortTask, 4);
    std::thread t5 = std::move(t4); // t4ì˜ ì†Œìœ ê¶Œì´ t5ë¡œ ì´ë™
    std::cout << "Case 4: ì†Œìœ ê¶Œ ì´ì „ í›„ t4. Joinable? " << (t4.joinable() ? "Yes" : "No") << std::endl;
    std::cout << "Case 4: ì†Œìœ ê¶Œ ì´ì „ í›„ t5. Joinable? " << (t5.joinable() ? "Yes" : "No") << std::endl;
    
    if (t5.joinable()) {
        t5.join();
    }
    
    // ê²°ë¡ : joinable()ì´ falseì¸ ìŠ¤ë ˆë“œì— join()ì„ í˜¸ì¶œí•˜ë©´ ì—ëŸ¬ê°€ ë°œìƒí•©ë‹ˆë‹¤.
    // if (t1.joinable()) t1.join(); // í•­ìƒ ì´ë ‡ê²Œ ì²´í¬
    
    return 0;
}
```

#### RAII (`ThreadGuard`) 

**`4_raii_guard_demo.cpp`**

```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <string>
#include <mutex>
#include <exception> // std::exception

// ìŠ¤ë ˆë“œ ì•ˆì „í•œ ë¡œê¹…
std::mutex cout_mutex;
void safe_print(const std::string& msg) {
    std::lock_guard<std::mutex> lock(cout_mutex);
    std::cout << msg << std::endl;
}

void shortTask(int id) {
    safe_print("Task " + std::to_string(id) + " started");
    std::this_thread::sleep_for(std::chrono::milliseconds(500));
    safe_print("Task " + std::to_string(id) + " completed");
}

/**
 * @brief RAII ê¸°ë²•ì„ ì‚¬ìš©í•œ ìŠ¤ë ˆë“œ ê´€ë¦¬ í´ë˜ìŠ¤
 * ì´ ê°ì²´ê°€ ì†Œë©¸(íŒŒê´´)ë  ë•Œ, ìì‹ ì´ ê°ì‹¸ê³ (guard) ìˆë˜ ìŠ¤ë ˆë“œë¥¼
 * ìë™ìœ¼ë¡œ join()í•©ë‹ˆë‹¤.
 */
class ThreadGuard {
private:
    std::thread& thread_;
    
public:
    // ìƒì„±ì: ê´€ë¦¬í•  ìŠ¤ë ˆë“œì˜ ì°¸ì¡°ë¥¼ ë°›ìŠµë‹ˆë‹¤.
    explicit ThreadGuard(std::thread& t) : thread_(t) {}
    
    // ì†Œë©¸ì: ê°ì²´ê°€ ìŠ¤ì½”í”„ë¥¼ ë²—ì–´ë‚  ë•Œ í˜¸ì¶œë©ë‹ˆë‹¤.
    ~ThreadGuard() {
        // ìŠ¤ë ˆë“œê°€ ì—¬ì „íˆ join ê°€ëŠ¥í•œ ìƒíƒœì¸ì§€(join/detachë˜ì§€ ì•Šì•˜ëŠ”ì§€) í™•ì¸
        if (thread_.joinable()) {
            thread_.join(); // ì•ˆì „í•˜ê²Œ join
            safe_print("ThreadGuard: ì†Œë©¸ìì—ì„œ ìŠ¤ë ˆë“œë¥¼ join() í–ˆìŠµë‹ˆë‹¤.");
        }
    }
    
    // ë³µì‚¬ ìƒì„±ì/ëŒ€ì… ì—°ì‚°ì ì‚­ì œ (ì†Œìœ ê¶Œ ê´€ë¦¬ ë‹¨ìˆœí™”)
    ThreadGuard(const ThreadGuard&) = delete;
    ThreadGuard& operator=(const ThreadGuard&) = delete;
};

int main() {
    std::cout << "\n=== 4. RAII Thread Management ===" << std::endl;
    std::cout << "ThreadGuardëŠ” ì˜ˆì™¸ê°€ ë°œìƒí•´ë„ ìŠ¤ë ˆë“œê°€ ì•ˆì „í•˜ê²Œ join()ë˜ë„ë¡ ë³´ì¥í•©ë‹ˆë‹¤.\n" << std::endl;
    
    try {
        std::thread t(shortTask, 1);
        
        // t ìŠ¤ë ˆë“œë¥¼ ê´€ë¦¬í•˜ëŠ” ThreadGuard ê°ì²´ ìƒì„±
        // main í•¨ìˆ˜ê°€ ì–´ë–»ê²Œ ì¢…ë£Œë˜ë“ (ì •ìƒ ì¢…ë£Œ or ì˜ˆì™¸ ë°œìƒ)
        // 'guard' ê°ì²´ê°€ íŒŒê´´ë  ë•Œ t.join()ì´ í˜¸ì¶œë©ë‹ˆë‹¤.
        ThreadGuard guard(t);
        
        // ì—¬ê¸°ì„œ ì˜ˆì™¸ë¥¼ ê°•ì œë¡œ ë°œìƒì‹œí‚µë‹ˆë‹¤.
        safe_print("Main: ì˜ˆì™¸(exception)ë¥¼ ê°•ì œë¡œ ë°œìƒì‹œí‚µë‹ˆë‹¤!");
        throw std::runtime_error("ì‹œë®¬ë ˆì´ì…˜ëœ ì—ëŸ¬!");
        
        // ì´ ì½”ë“œëŠ” ì‹¤í–‰ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
        safe_print("Main: ì´ ë©”ì‹œì§€ëŠ” ì¶œë ¥ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
        
    } catch (const std::exception& e) {
        safe_print("Main: ì˜ˆì™¸ë¥¼ catchí–ˆìŠµë‹ˆë‹¤: " + std::string(e.what()));
    }
    
    safe_print("Main: í”„ë¡œê·¸ë¨ ì¢…ë£Œ. (ì˜ˆì™¸ ë°œìƒ í›„ì—ë„ join()ì´ í˜¸ì¶œë˜ì—ˆìŠµë‹ˆë‹¤)");
    return 0;
}
```


#### ìŠ¤ë ˆë“œ í’€ (ê°„ë‹¨í•œ êµ¬í˜„) 

**`5_thread_pool_demo.cpp`**

```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <string>
#include <mutex>
#include <vector>
#include <atomic> // std::atomic

// ìŠ¤ë ˆë“œ ì•ˆì „í•œ ë¡œê¹…
std::mutex cout_mutex;
void safe_print(const std::string& msg) {
    std::lock_guard<std::mutex> lock(cout_mutex);
    std::cout << msg << std::endl;
}

/**
 * @brief ê°„ë‹¨í•œ ìŠ¤ë ˆë“œ í’€ í´ë˜ìŠ¤
 * í(Queue) ì—†ì´, ì •í•´ì§„ ìˆ˜ì˜ ìŠ¤ë ˆë“œê°€ ë©ˆì¶¤ ì‹ í˜¸(stop_)ê°€ ì˜¬ ë•Œê¹Œì§€
 * ëŒ€ê¸°í•˜ëŠ” ê°€ì¥ ë‹¨ìˆœí•œ í˜•íƒœì˜ í’€ì…ë‹ˆë‹¤.
 */
class SimpleThreadPool {
private:
    // ì¼ê¾¼(worker) ìŠ¤ë ˆë“œë“¤ì„ ì €ì¥í•˜ëŠ” ë²¡í„°
    std::vector<std::thread> workers_;
    // ëª¨ë“  ìŠ¤ë ˆë“œë¥¼ ì¤‘ì§€ì‹œí‚¤ê¸° ìœ„í•œ í”Œë˜ê·¸
    std::atomic<bool> stop_;

    // ê° ìŠ¤ë ˆë“œê°€ ì‹¤í–‰í•  í•¨ìˆ˜
    void workerFunction(size_t id) {
        safe_print("Worker " + std::to_string(id) + " started");
        
        // stop_ í”Œë˜ê·¸ê°€ falseì¸ ë™ì•ˆ ê³„ì† ë£¨í”„
        while (!stop_) {
            // ì‹¤ì œë¡œëŠ” ì—¬ê¸°ì„œ 'ì‘ì—… í'ì—ì„œ ì‘ì—…ì„ ê°€ì ¸ì™€ì•¼ í•¨
            // ì§€ê¸ˆì€ ê·¸ëƒ¥ ëŒ€ê¸°
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
        
        safe_print("Worker " + std::to_string(id) + " stopped");
    }

public:
    // ìƒì„±ì: ì§€ì •ëœ ìˆ˜(num_threads)ë§Œí¼ ìŠ¤ë ˆë“œë¥¼ ìƒì„±
    SimpleThreadPool(size_t num_threads) : stop_(false) {
        for (size_t i = 0; i < num_threads; ++i) {
            // emplace_back: ë²¡í„°ì— ì§ì ‘ ìŠ¤ë ˆë“œ ê°ì²´ë¥¼ ìƒì„±
            workers_.emplace_back([this, i]() {
                this->workerFunction(i);
            });
        }
        safe_print("Thread pool created with " + std::to_string(num_threads) + " threads");
    }
    
    // ì†Œë©¸ì: ìŠ¤ë ˆë“œ í’€ì´ íŒŒê´´ë  ë•Œ
    ~SimpleThreadPool() {
        safe_print("Thread pool destroying...
ëª¨ë“  worker ìŠ¤ë ˆë“œì— ì¢…ë£Œ ì‹ í˜¸ ì „ì†¡.");
        
        // 1. ëª¨ë“  ìŠ¤ë ˆë“œì— 'stop_' ì‹ í˜¸ë¥¼ ë³´ëƒ„
        stop_ = true;
        
        // 2. ëª¨ë“  ìŠ¤ë ˆë“œê°€ ì¢…ë£Œë  ë•Œê¹Œì§€ join()
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
        safe_print("Thread pool destroyed, all threads joined");
    }
};

int main() {
    std::cout << "\n=== 5. Thread Pool Demo ===" << std::endl;
    std::cout << "ìŠ¤ë ˆë“œ í’€ ê°ì²´ê°€ ìƒì„±ë  ë•Œ ìŠ¤ë ˆë“œë“¤ì´ ì‹œì‘ë˜ê³ ,\n";
    std::cout << "ê°ì²´ê°€ ì†Œë©¸ë (ìŠ¤ì½”í”„ë¥¼ ë²—ì–´ë‚ ) ë•Œ ìŠ¤ë ˆë“œë“¤ì´ ì •ë¦¬(join)ë©ë‹ˆë‹¤.\n" << std::endl;
    
    // ì´ ì¤‘ê´„í˜¸ { } ìŠ¤ì½”í”„ ì•ˆì—ì„œë§Œ pool ê°ì²´ê°€ ì‚´ì•„ìˆìŠµë‹ˆë‹¤.
    {
        SimpleThreadPool pool(3); // 3ê°œì˜ ìŠ¤ë ˆë“œë¡œ í’€ ìƒì„±
        
        std::cout << "Main: ìŠ¤ë ˆë“œ í’€ì´ 0.5ì´ˆê°„ ì‘ë™í•©ë‹ˆë‹¤..." << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
        
        std::cout << "Main: ìŠ¤ì½”í”„( } )ë¥¼ ê³§ ë²—ì–´ë‚©ë‹ˆë‹¤. (pool ê°ì²´ ì†Œë©¸ì í˜¸ì¶œë¨)" << std::endl;
    } // <-- ì´ ì§€ì ì—ì„œ pool ê°ì²´ê°€ ì†Œë©¸ë˜ë©´ì„œ ~SimpleThreadPool() í˜¸ì¶œ
    
    std::cout << "Main: ìŠ¤ë ˆë“œ í’€ ì†Œë©¸ ì™„ë£Œ. í”„ë¡œê·¸ë¨ ì¢…ë£Œ." << std::endl;
    return 0;
}
```


#### ìŠ¤ë ˆë“œ ì†Œìœ ê¶Œ ì´ì „ (`std::move`) 

**`6_move_ownership_demo.cpp`**

```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <string>
#include <mutex>
#include <vector> // std::move

// ìŠ¤ë ˆë“œ ì•ˆì „í•œ ë¡œê¹…
std::mutex cout_mutex;
void safe_print(const std::string& msg) {
    std::lock_guard<std::mutex> lock(cout_mutex);
    std::cout << msg << std::endl;
}

void shortTask(int id) {
    safe_print("Task " + std::to_string(id) + " started");
    std::this_thread::sleep_for(std::chrono::milliseconds(200));
    safe_print("Task " + std::to_string(id) + " completed");
}

int main() {
    std::cout << "\n=== 6. Thread Ownership Transfer (std::move) ===" << std::endl;
    std::cout << "std::thread ê°ì²´ëŠ” ë³µì‚¬í•  ìˆ˜ ì—†ê³ , ì˜¤ì§ 'ì´ë™(move)'ë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤.\n" << std::endl;

    std::thread t1(shortTask, 1);
    std::cout << "Main: t1 ìƒì„±ë¨. t1 joinable? " << t1.joinable() << std::endl;

    // std::thread t2 = t1; // <-- ì»´íŒŒì¼ ì—ëŸ¬! (ë³µì‚¬ ìƒì„±ì ì‚­ì œë¨)

    // std::move()ë¥¼ ì‚¬ìš©í•´ t1ì˜ ì†Œìœ ê¶Œ(ì‹¤í–‰ ì¤‘ì¸ ìŠ¤ë ˆë“œì— ëŒ€í•œ ì œì–´ê¶Œ)ì„ t2ë¡œ ì´ì „
    std::thread t2 = std::move(t1);
    
    std::cout << "Main: t1ì˜ ì†Œìœ ê¶Œì„ t2ë¡œ ì´ë™ì‹œí‚´" << std::endl;
    
    // ì†Œìœ ê¶Œì„ ìƒì€ t1ì€ ë” ì´ìƒ joinable()ì´ ì•„ë‹˜ (ë¹ˆ ê»ë°ê¸°)
    std::cout << "  t1.joinable() (ì†Œìœ ê¶Œ ìƒìŒ)? " << t1.joinable() << std::endl;
    // ì†Œìœ ê¶Œì„ ì–»ì€ t2ê°€ joinable()ì´ ë¨
    std::cout << "  t2.joinable() (ì†Œìœ ê¶Œ ì–»ìŒ)? " << t2.joinable() << std::endl;
    
    // t1.join(); // <-- ì—ëŸ¬ ë°œìƒ (joinable()ì´ ì•„ë‹˜)
    
    // t2ë¥¼ joiní•´ì•¼ í•¨
    if (t2.joinable()) {
        safe_print("Main: t2ë¥¼ joiní•©ë‹ˆë‹¤.");
        t2.join();
    }
    
    return 0;
}
```

  
### ì‹¤ìŠµ: ì½ê¸°-ì“°ê¸° ë½ì„ í™œìš©í•œ ìŠ¤ë ˆë“œ ì•ˆì „ ë°ì´í„° ì €ì¥ì†Œ
ë§ˆì§€ë§‰ìœ¼ë¡œ ë°°ìš´ ëª¨ë“  ê°œë…ì„ ì¢…í•©í•˜ì—¬ ì‹¤ìš©ì ì¸ ìŠ¤ë ˆë“œ ì•ˆì „ ë°ì´í„° ì €ì¥ì†Œë¥¼ êµ¬í˜„í•´ë³´ì. ì´ ì €ì¥ì†ŒëŠ” ì½ê¸°-ì“°ê¸° ë½ì„ ì‚¬ìš©í•˜ì—¬ ë†’ì€ ì„±ëŠ¥ì„ ì œê³µí•œë‹¤.
  
```
#include <iostream>
#include <thread>
#include <shared_mutex>
#include <mutex>
#include <unordered_map>
#include <vector>
#include <string>
#include <chrono>
#include <random>
#include <atomic>
#include <memory>
#include <optional>
#include <iomanip>

// ë°ì´í„° í•­ëª©
struct DataItem {
    std::string value;
    std::chrono::system_clock::time_point last_modified;
    int version;
    
    DataItem(const std::string& val) 
        : value(val), 
          last_modified(std::chrono::system_clock::now()), 
          version(1) {}
};

// ìŠ¤ë ˆë“œ ì•ˆì „ ë°ì´í„° ì €ì¥ì†Œ
template<typename Key, typename Value>
class ThreadSafeDataStore {
private:
    mutable std::shared_mutex mutex_;
    std::unordered_map<Key, std::shared_ptr<Value>> data_;
    
    // í†µê³„
    mutable std::atomic<size_t> read_count_{0};
    mutable std::atomic<size_t> write_count_{0};
    mutable std::atomic<size_t> cache_hits_{0};
    mutable std::atomic<size_t> cache_misses_{0};
    
    // ìºì‹œ (ìµœê·¼ ì½ì€ í•­ëª©)
    mutable std::unordered_map<Key, std::weak_ptr<Value>> cache_;
    
public:
    // ë°ì´í„° ì‚½ì…/ì—…ë°ì´íŠ¸
    void put(const Key& key, const Value& value) {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        write_count_++;
        
        auto it = data_.find(key);
        if (it != data_.end()) {
            // ì—…ë°ì´íŠ¸
            it->second = std::make_shared<Value>(value);
        } else {
            // ìƒˆë¡œ ì‚½ì…
            data_[key] = std::make_shared<Value>(value);
        }
        
        // ìºì‹œ ë¬´íš¨í™”
        cache_.erase(key);
    }
    
    // ë°ì´í„° ì½ê¸°
    std::optional<Value> get(const Key& key) const {
        // ë¨¼ì € ìºì‹œ í™•ì¸ (ì½ê¸° ë½ ì—†ì´)
        {
            auto cache_it = cache_.find(key);
            if (cache_it != cache_.end()) {
                if (auto cached = cache_it->second.lock()) {
                    cache_hits_++;
                    read_count_++;
                    return *cached;
                }
            }
        }
        
        // ìºì‹œ ë¯¸ìŠ¤ - ì‹¤ì œ ë°ì´í„° ì½ê¸°
        std::shared_lock<std::shared_mutex> lock(mutex_);
        cache_misses_++;
        read_count_++;
        
        auto it = data_.find(key);
        if (it != data_.end()) {
            cache_[key] = it->second;  // ìºì‹œì— ì €ì¥
            return *(it->second);
        }
        
        return std::nullopt;
    }
    
    // ì¡°ê±´ë¶€ ì—…ë°ì´íŠ¸ (Compare and Swap)
    bool update(const Key& key, const Value& old_value, const Value& new_value) {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        write_count_++;
        
        auto it = data_.find(key);
        if (it != data_.end() && *(it->second) == old_value) {
            it->second = std::make_shared<Value>(new_value);
            cache_.erase(key);
            return true;
        }
        
        return false;
    }
    
    // ë°ì´í„° ì‚­ì œ
    bool remove(const Key& key) {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        write_count_++;
        
        cache_.erase(key);
        return data_.erase(key) > 0;
    }
    
    // ì—¬ëŸ¬ í‚¤ ë™ì‹œ ì½ê¸°
    std::vector<std::pair<Key, Value>> getMultiple(const std::vector<Key>& keys) const {
        std::shared_lock<std::shared_mutex> lock(mutex_);
        read_count_ += keys.size();
        
        std::vector<std::pair<Key, Value>> results;
        for (const auto& key : keys) {
            auto it = data_.find(key);
            if (it != data_.end()) {
                results.emplace_back(key, *(it->second));
            }
        }
        
        return results;
    }
    
    // ë²”ìœ„ ì¿¼ë¦¬ (ì¡°ê±´ì— ë§ëŠ” ëª¨ë“  í•­ëª©)
    template<typename Predicate>
    std::vector<std::pair<Key, Value>> findWhere(Predicate pred) const {
        std::shared_lock<std::shared_mutex> lock(mutex_);
        
        std::vector<std::pair<Key, Value>> results;
        for (const auto& [key, value_ptr] : data_) {
            if (pred(key, *value_ptr)) {
                results.emplace_back(key, *value_ptr);
                read_count_++;
            }
        }
        
        return results;
    }
    
    // ì›ìì  ì‘ì—… - ê°’ ì¦ê°€
    bool increment(const Key& key, int delta = 1) {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        write_count_++;
        
        auto it = data_.find(key);
        if (it != data_.end()) {
            // Valueê°€ int íƒ€ì…ì´ë¼ê³  ê°€ì •
            if constexpr (std::is_same_v<Value, int>) {
                *(it->second) += delta;
                cache_.erase(key);
                return true;
            }
        }
        
        return false;
    }
    
    // í†µê³„ ì •ë³´
    void getStats(size_t& reads, size_t& writes, size_t& hits, size_t& misses, size_t& size) const {
        std::shared_lock<std::shared_mutex> lock(mutex_);
        reads = read_count_;
        writes = write_count_;
        hits = cache_hits_;
        misses = cache_misses_;
        size = data_.size();
    }
    
    // ëª¨ë“  ë°ì´í„° í´ë¦¬ì–´
    void clear() {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        data_.clear();
        cache_.clear();
    }
    
    size_t size() const {
        std::shared_lock<std::shared_mutex> lock(mutex_);
        return data_.size();
    }
};

// í…ŒìŠ¤íŠ¸ìš© ì›Œì»¤ ìŠ¤ë ˆë“œ
class DataStoreWorker {
private:
    ThreadSafeDataStore<std::string, DataItem>& store_;
    int id_;
    std::mt19937 gen_;
    
public:
    DataStoreWorker(ThreadSafeDataStore<std::string, DataItem>& store, int id)
        : store_(store), id_(id), gen_(std::random_device{}()) {}
    
    void runReader(int operations) {
        std::uniform_int_distribution<> key_dist(0, 99);
        
        for (int i = 0; i < operations; ++i) {
            std::string key = "key_" + std::to_string(key_dist(gen_));
            
            auto value = store_.get(key);
            if (value) {
                std::cout << "[Reader " << id_ << "] Found " << key 
                         << " = " << value->value 
                         << " (v" << value->version << ")" << std::endl;
            }
            
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
    }
    
    void runWriter(int operations) {
        std::uniform_int_distribution<> key_dist(0, 99);
        
        for (int i = 0; i < operations; ++i) {
            std::string key = "key_" + std::to_string(key_dist(gen_));
            std::string value = "value_from_writer_" + std::to_string(id_) + "_" + std::to_string(i);
            
            store_.put(key, DataItem(value));
            std::cout << "[Writer " << id_ << "] Wrote " << key 
                     << " = " << value << std::endl;
            
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
        }
    }
    
    void runUpdater(int operations) {
        std::uniform_int_distribution<> key_dist(0, 99);
        
        for (int i = 0; i < operations; ++i) {
            std::string key = "key_" + std::to_string(key_dist(gen_));
            
            auto current = store_.get(key);
            if (current) {
                DataItem new_item = *current;
                new_item.value += "_updated";
                new_item.version++;
                new_item.last_modified = std::chrono::system_clock::now();
                
                if (store_.update(key, *current, new_item)) {
                    std::cout << "[Updater " << id_ << "] Updated " << key 
                             << " to version " << new_item.version << std::endl;
                }
            }
            
            std::this_thread::sleep_for(std::chrono::milliseconds(30));
        }
    }
};

// ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬
void performanceBenchmark() {
    std::cout << "\n=== Performance Benchmark ===" << std::endl;
    
    ThreadSafeDataStore<int, int> int_store;
    
    // ì´ˆê¸° ë°ì´í„° ì‚½ì…
    for (int i = 0; i < 1000; ++i) {
        int_store.put(i, i * 10);
    }
    
    const int num_threads = 8;
    const int operations_per_thread = 1000;
    
    auto start = std::chrono::high_resolution_clock::now();
    
    std::vector<std::thread> threads;
    
    // ì½ê¸° ì¤‘ì‹¬ ì›Œí¬ë¡œë“œ (80% ì½ê¸°, 20% ì“°ê¸°)
    for (int i = 0; i < num_threads; ++i) {
        if (i < num_threads * 0.8) {
            // ì½ê¸° ìŠ¤ë ˆë“œ
            threads.emplace_back([&int_store, i, operations_per_thread]() {
                std::mt19937 gen(i);
                std::uniform_int_distribution<> dist(0, 999);
                
                for (int j = 0; j < operations_per_thread; ++j) {
                    int_store.get(dist(gen));
                }
            });
        } else {
            // ì“°ê¸° ìŠ¤ë ˆë“œ
            threads.emplace_back([&int_store, i, operations_per_thread]() {
                std::mt19937 gen(i);
                std::uniform_int_distribution<> dist(0, 999);
                
                for (int j = 0; j < operations_per_thread; ++j) {
                    int key = dist(gen);
                    int_store.put(key, key * 20 + j);
                }
            });
        }
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    size_t reads, writes, hits, misses, size;
    int_store.getStats(reads, writes, hits, misses, size);
    
    std::cout << "Benchmark Results:" << std::endl;
    std::cout << "  Duration: " << duration.count() << " ms" << std::endl;
    std::cout << "  Total operations: " << (reads + writes) << std::endl;
    std::cout << "  Operations/sec: " 
              << (reads + writes) * 1000.0 / duration.count() << std::endl;
    std::cout << "  Read operations: " << reads << std::endl;
    std::cout << "  Write operations: " << writes << std::endl;
    std::cout << "  Cache hit rate: " 
              << (hits * 100.0 / (hits + misses)) << "%" << std::endl;
}

int main() {
    std::cout << "=== Thread-Safe Data Store with Read-Write Locks ===" << std::endl;
    
    ThreadSafeDataStore<std::string, DataItem> store;
    
    // ì´ˆê¸° ë°ì´í„° ì‚½ì…
    std::cout << "\nInserting initial data..." << std::endl;
    for (int i = 0; i < 20; ++i) {
        std::string key = "key_" + std::to_string(i);
        store.put(key, DataItem("initial_value_" + std::to_string(i)));
    }
    std::cout << "Initial data size: " << store.size() << std::endl;
    
    // ë™ì‹œ ì½ê¸°/ì“°ê¸° í…ŒìŠ¤íŠ¸
    std::cout << "\n--- Concurrent Read/Write Test ---" << std::endl;
    
    std::vector<std::thread> threads;
    std::vector<std::unique_ptr<DataStoreWorker>> workers;
    
    // ì½ê¸° ì›Œì»¤ (ë§ìŒ)
    for (int i = 0; i < 3; ++i) {
        workers.push_back(std::make_unique<DataStoreWorker>(store, i));
        threads.emplace_back(&DataStoreWorker::runReader, workers.back().get(), 5);
    }
    
    // ì“°ê¸° ì›Œì»¤ (ì ìŒ)
    for (int i = 3; i < 5; ++i) {
        workers.push_back(std::make_unique<DataStoreWorker>(store, i));
        threads.emplace_back(&DataStoreWorker::runWriter, workers.back().get(), 3);
    }
    
    // ì—…ë°ì´íŠ¸ ì›Œì»¤
    for (int i = 5; i < 6; ++i) {
        workers.push_back(std::make_unique<DataStoreWorker>(store, i));
        threads.emplace_back(&DataStoreWorker::runUpdater, workers.back().get(), 4);
    }
    
    // ëª¨ë“  ìŠ¤ë ˆë“œ ì¢…ë£Œ ëŒ€ê¸°
    for (auto& t : threads) {
        t.join();
    }
    
    // ìµœì¢… í†µê³„
    size_t reads, writes, hits, misses, size;
    store.getStats(reads, writes, hits, misses, size);
    
    std::cout << "\n=== Final Statistics ===" << std::endl;
    std::cout << "Store size: " << size << " items" << std::endl;
    std::cout << "Total reads: " << reads << std::endl;
    std::cout << "Total writes: " << writes << std::endl;
    std::cout << "Cache hits: " << hits << std::endl;
    std::cout << "Cache misses: " << misses << std::endl;
    if (hits + misses > 0) {
        std::cout << "Cache hit rate: " << std::fixed << std::setprecision(1)
                  << (hits * 100.0 / (hits + misses)) << "%" << std::endl;
    }
    
    // ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬ ì‹¤í–‰
    performanceBenchmark();
    
    std::cout << "\n=== Key Insights ===" << std::endl;
    std::cout << "1. Shared mutex allows multiple concurrent readers" << std::endl;
    std::cout << "2. Writers have exclusive access when modifying data" << std::endl;
    std::cout << "3. Cache layer improves read performance" << std::endl;
    std::cout << "4. RAII lock management prevents deadlocks" << std::endl;
    std::cout << "5. Atomic operations track statistics without locks" << std::endl;
    
    return 0;
}
```
  

### std::shared_timed_mutex 
* **ì •ì˜**: ë‹¤ì¤‘ ë¦¬ë”â€“ë‹¨ì¼ ë¼ì´í„°(MRSW, multiple-reader/single-writer) ë™ê¸°í™”ë¥¼ ì œê³µí•˜ëŠ” ë®¤í…ìŠ¤ë¡œ, **ê³µìœ  ì ê¸ˆ(shared/read)** ê³¼ **ë°°íƒ€ ì ê¸ˆ(exclusive/write)** ì„ ëª¨ë‘ ì§€ì›í•˜ê³ , ë‘ ì ê¸ˆ ëª¨ë‘ì— ëŒ€í•´ **ì‹œê°„ ì œí•œ ìˆëŠ” ì‹œë„**ë¥¼ ì œê³µí•œë‹¤.
* **í—¤ë”**: `<shared_mutex>` ë‹¤.
* **í‘œì¤€**: C++14ì—ì„œ ë„ì…ë˜ì—ˆë‹¤. C++17ì—ì„œ `std::shared_mutex`ê°€ ì¶”ê°€ë˜ì—ˆëŠ”ë°, íƒ€ì„ë“œ APIê°€ í•„ìš” ì—†ìœ¼ë©´ ë³´í†µ `shared_mutex`ê°€ ì•½ê°„ ë” ê°€ë³ê³  ë¹ ë¥¸ ì„ íƒì´ë‹¤.
* **íŠ¹ì„±**: ë³µì‚¬/ì´ë™ ë¶ˆê°€, ê¸°ë³¸ ìƒì„± ê°€ëŠ¥, RAII ë˜í¼ë¡œ `std::unique_lock`, `std::lock_guard`, `std::shared_lock`ì™€ í•¨ê»˜ ì“°ëŠ” ê²ƒì´ ì¼ë°˜ì ì´ë‹¤.

  
#### ì¸í„°í˜ì´ìŠ¤(í•µì‹¬ ë©¤ë²„)

```cpp
class shared_timed_mutex {
public:
  shared_timed_mutex();
  ~shared_timed_mutex();

  // ë°°íƒ€ ì ê¸ˆ (writer)
  void lock();                         // ë¸”ë¡œí‚¹
  bool try_lock();                     // ì¦‰ì‹œ ì‹œë„
  template<class Rep, class Period>
  bool try_lock_for(const std::chrono::duration<Rep,Period>& rel_time);
  template<class Clock, class Duration>
  bool try_lock_until(const std::chrono::time_point<Clock,Duration>& abs_time);
  void unlock();

  // ê³µìœ  ì ê¸ˆ (reader)
  void lock_shared();                  // ë¸”ë¡œí‚¹
  bool try_lock_shared();              // ì¦‰ì‹œ ì‹œë„
  template<class Rep, class Period>
  bool try_lock_shared_for(const std::chrono::duration<Rep,Period>& rel_time);
  template<class Clock, class Duration>
  bool try_lock_shared_until(const std::chrono::time_point<Clock,Duration>& abs_time);
  void unlock_shared();
};
```

* **ë°°íƒ€ ì ê¸ˆ**ì€ ë™ì‹œì— í•˜ë‚˜ì˜ ìŠ¤ë ˆë“œë§Œ ë“¤ì–´ê°ˆ ìˆ˜ ìˆë‹¤.
* **ê³µìœ  ì ê¸ˆ**ì€ ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ë“¤ì–´ê°ˆ ìˆ˜ ìˆì§€ë§Œ, ë°°íƒ€ ì ê¸ˆê³¼ëŠ” ìƒí˜¸ ë°°íƒ€ì ì´ë‹¤.
* `try_lock_for/try_lock_until` ê³„ì—´ì€ ì§€ì •í•œ ì‹œê°„ ì•ˆì— ì ê¸ˆì— ì‹¤íŒ¨í•˜ë©´ `false`ë¥¼ ë°˜í™˜í•œë‹¤.

  
#### ì–¸ì œ ì‚¬ìš©í•˜ë‚˜
* **ì½ê¸°ê°€ ì••ë„ì ìœ¼ë¡œ ë§ì€ ì›Œí¬ë¡œë“œ**ì—ì„œ ì „ì²´ ì„ê³„ êµ¬ì—­ì„ í•˜ë‚˜ì˜ ì¼ë°˜ `mutex`ë¡œ ë§‰ëŠ” ëŒ€ì‹ , ë‹¤ìˆ˜ì˜ ë¦¬ë”ê°€ ë™ì‹œì— ë“¤ì–´ì˜¤ê²Œ í•˜ì—¬ ìŠ¤ë£¨í’‹ì„ ë†’ì´ê³  ì‹¶ì„ ë•Œ ì¢‹ë‹¤.
* **ì ê¸ˆ ëŒ€ê¸°ì— ëŒ€í•œ SLA/ì‹œê°„ ì œí•œ**ì´ í•„ìš”í•  ë•Œ `try_lock*_for/Until`ë¡œ **í¬ê¸° ì‹œì **ì„ ëª…ì‹œí•˜ê³  ëŒ€ì²´ ê²½ë¡œë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.
* ì˜¨ë¼ì¸ ê²Œì„ ì„œë²„ ê´€ì ì—ì„œëŠ” **í”Œë ˆì´ì–´ ìƒíƒœ, ë§¤ì¹˜ ë©”íƒ€ë°ì´í„°, ì•„ì´í…œ í…Œì´ë¸”** ê°™ì€ **ì½ê¸° ë‹¤ìˆ˜/ì“°ê¸° ë“œë¬¸ ìºì‹œ**ì— ì í•©í•˜ë‹¤.
  
  
#### ì£¼ì˜í•´ì•¼ í•˜ëŠ” ì 
* **ê³µì •ì„±/ê¸°ì•„(starvation)**: í‘œì¤€ì€ ë¦¬ë”/ë¼ì´í„° ê³µì •ì„±ì„ ë³´ì¥í•˜ì§€ ì•ŠëŠ”ë‹¤. êµ¬í˜„ì— ë”°ë¼ ë¦¬ë”ê°€ ê³„ì† ë“¤ì–´ì™€ ë¼ì´í„°ê°€ êµ¶ê±°ë‚˜, ë°˜ëŒ€ë¡œ ë¼ì´í„° ìš°ì„  ì •ì±…ìœ¼ë¡œ ë¦¬ë”ê°€ ì§€ì—°ë  ìˆ˜ ìˆë‹¤. ê¸´ ì„ê³„ êµ¬ì—­ì„ í”¼í•˜ê³ , í•„ìš”í•˜ë©´ ì“°ê¸° ë°°ì¹˜ë¥¼ ë„ì…í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.
* **ì—…ê·¸ë ˆì´ë“œ/ë‹¤ìš´ê·¸ë ˆì´ë“œ ë¯¸ì§€ì›**: ê³µìœ  â†’ ë°°íƒ€ë¡œì˜ ì•ˆì „í•œ ì—…ê·¸ë ˆì´ë“œ, ë°°íƒ€ â†’ ê³µìœ  ë‹¤ìš´ê·¸ë ˆì´ë“œë¥¼ ìœ„í•œ ì „ìš© APIê°€ ì—†ë‹¤. ì´ëŸ° íŒ¨í„´ì´ í•„ìš”í•˜ë©´ ì„¤ê³„ë¥¼ ë°”ê¾¸ê±°ë‚˜ ë³„ë„ í”„ë¡œí† ì½œ/ë½ì„ ë„ì…í•´ì•¼ í•œë‹¤.
* **ë½ ìˆœì„œ ë°ë“œë½**: ì—¬ëŸ¬ `shared_timed_mutex`ë¥¼ ì¡°í•©í•˜ë©´ ì ê¸ˆ ìˆœì„œë¥¼ ì—„ê²©íˆ ì§€ì¼œì•¼ í•œë‹¤. ê°€ëŠ¥í•˜ë©´ í•œ ë²ˆì— í•˜ë‚˜ë§Œ ì ê·¸ê±°ë‚˜, ì •í•´ì§„ ìˆœì„œë¡œ ì ê·¸ê³  RAIIë¥¼ ì‚¬ìš©í•œë‹¤.
* **ì˜¤ë²„í—¤ë“œ**: ê´€ë¦¬í•´ì•¼ í•  ìƒíƒœê°€ `mutex`ë³´ë‹¤ ë§ì•„ ì§§ì€ ì„ê³„ êµ¬ì—­ì—ì„œëŠ” ì˜¤íˆë ¤ ì†í•´ì¼ ìˆ˜ ìˆë‹¤. ì•„ì£¼ ì§§ê±°ë‚˜ ìì£¼ í˜¸ì¶œë˜ëŠ” êµ¬ì—­ì€ lock-free/atomics, read-copy-update, ë¶„í•  ë½ ë“±ì„ ê²€í† í•œë‹¤.
* **íƒ€ì´ë° ë¶€ì •í™•ì„±**: `try_lock_for/until`ì˜ ì‹œê°„ ì •í™•ë„ëŠ” OS íƒ€ì´ë¨¸/ìŠ¤ì¼€ì¤„ëŸ¬ì— ì˜ì¡´í•˜ë¯€ë¡œ ìš”ì²­ë³´ë‹¤ ê¸¸ì–´ì§ˆ ìˆ˜ ìˆë‹¤.


#### ì˜ˆì œ 1: ì½ê¸° ë§ì€ ìºì‹œ

```cpp
#include <shared_mutex>
#include <unordered_map>
#include <optional>
#include <string>

class PlayerCache {
  mutable std::shared_timed_mutex m_;
  std::unordered_map<int, std::string> name_;

public:
  std::optional<std::string> get(int id) const {
    std::shared_lock lock(m_);                 // ê³µìœ  ì ê¸ˆ
    if (auto it = name_.find(id); it != name_.end()) return it->second;
    return std::nullopt;
  }

  void put(int id, std::string name) {
    std::unique_lock lock(m_);                 // ë°°íƒ€ ì ê¸ˆ
    name_[id] = std::move(name);
  }
};
```

* ë‹¤ìˆ˜ì˜ ë¦¬ë”ëŠ” `std::shared_lock`ìœ¼ë¡œ ë™ì‹œ ì ‘ê·¼í•˜ê³ , ë¼ì´í„°ëŠ” `std::unique_lock`ìœ¼ë¡œ ë‹¨ë… ì§„ì…í•œë‹¤.
  
#### ì˜ˆì œ 2: íƒ€ì„ë“œ ê³µìœ  ì ê¸ˆìœ¼ë¡œ ì‘ë‹µ ìœ ì§€

```cpp
#include <shared_mutex>
#include <chrono>
#include <optional>

class Snapshot {
  mutable std::shared_timed_mutex m_;
  int value_ = 0;

public:
  bool update(int v) {
    // ì“°ê¸°ëŠ” ì˜¤ë˜ ê±¸ë¦´ ìˆ˜ ìˆìœ¼ë‹ˆ íƒ€ì„ë“œ ë°°íƒ€ ì ê¸ˆì„ ì¨ë„ ëœë‹¤
    if (!m_.try_lock_for(std::chrono::milliseconds(5))) return false;
    value_ = v;
    m_.unlock();
    return true;
  }

  std::optional<int> read_with_deadline() const {
    if (!m_.try_lock_shared_for(std::chrono::milliseconds(1))) {
      return std::nullopt;                     // SLA ì´ˆê³¼ ì‹œ í¬ê¸°
    }
    int v = value_;
    m_.unlock_shared();
    return v;
  }
};
```

* ì½ê¸°/ì“°ê¸° ëª¨ë‘ì— íƒ€ì„ë“œ ì ê¸ˆì„ ì ìš©í•´, ì§€ì—°ì´ ì„ê³„ê°’ì„ ë„˜ìœ¼ë©´ í¬ê¸°í•˜ê³  ìƒìœ„ ë ˆì´ì–´ì—ì„œ ëŒ€ì²´ ë™ì‘ì„ í•˜ê²Œ í•  ìˆ˜ ìˆë‹¤.


#### ì‹¤ì „ íŒ
* **íƒ€ì„ë“œ APIê°€ í•„ìš” ì—†ìœ¼ë©´ `std::shared_mutex`ë¥¼ ìš°ì„  ê³ ë ¤**í•œë‹¤. ë³´í†µ êµ¬í˜„ì´ ë” ë‹¨ìˆœí•˜ê³  ì„±ëŠ¥ì´ ì•½ê°„ ë” ë‚«ë‹¤.
* **ì„ê³„ êµ¬ì—­ ìµœì†Œí™”**ì™€ **ë½ ë³´ìœ  ì‹œê°„ ë‹¨ì¶•**ì´ ì„±ëŠ¥ì˜ í•µì‹¬ì´ë‹¤. I/O, ê¸´ ê³„ì‚°, ì™¸ë¶€ í˜¸ì¶œì€ ê°€ëŠ¥í•˜ë©´ ë½ ë°–ìœ¼ë¡œ ë¹¼ì•¼ í•œë‹¤.
* **RAII ì‚¬ìš©**ì´ ê¸°ë³¸ì´ë‹¤. `std::shared_lock`ê³¼ `std::unique_lock`ì„ ìŠµê´€ì ìœ¼ë¡œ ì“°ë©´ `unlock()` ëˆ„ë½ìœ¼ë¡œ ì¸í•œ ë²„ê·¸ë¥¼ ì¤„ì¼ ìˆ˜ ìˆë‹¤.
* **ì—¬ëŸ¬ ë½ì„ í•¨ê»˜ ì¡ì„ ë•ŒëŠ” ìˆœì„œë¥¼ ê³ ì •**í•˜ê³ , ê°€ëŠ¥í•˜ë©´ í•˜ë‚˜ì˜ ìƒìœ„ ë½ìœ¼ë¡œ í•©ì¹˜ê±°ë‚˜ ë¶„í• (lock sharding) ì „ëµì„ ê³ ë ¤í•œë‹¤.
  
  
      
## std::timed_mutex

### ê°œìš”
* **ì •ì˜**: `std::mutex`ì™€ ê±°ì˜ ê°™ì§€ë§Œ, ì ê¸ˆ(lock)ì„ ì‹œë„í•  ë•Œ **ì‹œê°„ ì œí•œ(timeout)** ì„ ë‘˜ ìˆ˜ ìˆë‹¤.
* **ì‹œê·¸ë‹ˆì²˜**:

  ```cpp
  class timed_mutex {
  public:
      timed_mutex();
      ~timed_mutex();

      void lock();                      // ë¸”ë¡œí‚¹
      bool try_lock();                  // ì¦‰ì‹œ ì‹œë„
      bool try_lock_for(duration);      // ìƒëŒ€ ì‹œê°„ ëŒ€ê¸°
      bool try_lock_until(time_point);  // ì ˆëŒ€ ì‹œê°„ ëŒ€ê¸°
      void unlock();
  };
  ```
* **ì£¼ìš” ê¸°ëŠ¥**:
  * `try_lock_for` â†’ ì¼ì • ì‹œê°„ ë™ì•ˆë§Œ ì ê¸ˆì„ ê¸°ë‹¤ë¦¼
  * `try_lock_until` â†’ íŠ¹ì • ì‹œê°ê¹Œì§€ë§Œ ê¸°ë‹¤ë¦¼

### ì‚¬ìš©í•´ì•¼ í•˜ëŠ” ê²½ìš°
* **ë°ë“œë½ ìœ„í—˜ì´ ìˆëŠ” ìƒí™©ì—ì„œ íƒ€ì„ì•„ì›ƒì„ ì ìš©í•˜ê³  ì‹¶ì„ ë•Œ**
  ì˜ˆ: ì—¬ëŸ¬ ìì›ì„ ë™ì‹œì— ì ê¸€ ë•Œ ìˆœì„œ ë¬¸ì œë¡œ ë°ë“œë½ ê°€ëŠ¥ì„±ì´ ìˆìœ¼ë©´ ì¼ì • ì‹œê°„ í›„ í¬ê¸°í•˜ë„ë¡ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.
* **ì™¸ë¶€ ì´ë²¤íŠ¸ë‚˜ I/Oì™€ ì¡°í•©í•  ë•Œ**
  ì˜ˆ: ë„¤íŠ¸ì›Œí¬ ì‘ë‹µì´ë‚˜ íƒ€ì´ë¨¸ ì´ë²¤íŠ¸ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘ì— ì ê¸ˆì´ ì¼ì • ì‹œê°„ ë‚´ì— ê°€ëŠ¥í•˜ì§€ ì•Šìœ¼ë©´ ë‹¤ë¥¸ ì²˜ë¦¬ë¥¼ í•˜ê³  ë„˜ì–´ê°ˆ ìˆ˜ ìˆë‹¤.

### ì¡°ì‹¬í•´ì•¼ í•˜ëŠ” ê²½ìš°
* **íƒ€ì„ì•„ì›ƒìœ¼ë¡œ ì¸í•´ ë…¼ë¦¬ì  ê²½í•©ì´ ë°œìƒí•  ìˆ˜ ìˆë‹¤**
  ì˜ˆ: ì¼ë¶€ ìŠ¤ë ˆë“œê°€ ì ê¸ˆì„ ì–»ì§€ ëª»í•˜ê³  ê³„ì† ì¬ì‹œë„í•˜ë©´ ê¸°ì•„(starvation) í˜„ìƒì´ ìƒê¸¸ ìˆ˜ ìˆë‹¤.
* **íƒ€ì´ë¨¸ í•´ìƒë„ì— ë”°ë¼ ì‹¤ì œ ëŒ€ê¸° ì‹œê°„ì´ ì •í™•í•˜ì§€ ì•Šë‹¤**
  ìŠ¤ì¼€ì¤„ë§ ì§€ì—°ì´ë‚˜ ì‹œìŠ¤í…œ íƒ€ì´ë¨¸ í•´ìƒë„ ë•Œë¬¸ì— ì§€ì • ì‹œê°„ë³´ë‹¤ ë” ì˜¤ë˜ ê¸°ë‹¤ë¦´ ìˆ˜ ìˆë‹¤.

### ì˜ˆì œ ì½”ë“œ

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>

std::timed_mutex tm;

void worker(int id) {
    if (tm.try_lock_for(std::chrono::milliseconds(100))) {
        std::cout << "Worker " << id << " got the lock\n";
        std::this_thread::sleep_for(std::chrono::milliseconds(200));
        tm.unlock();
    } else {
        std::cout << "Worker " << id << " timed out\n";
    }
}

int main() {
    std::thread t1(worker, 1);
    std::thread t2(worker, 2);
    t1.join();
    t2.join();
}
```

  

## std::recursive_mutex

### ê°œìš”
* **ì •ì˜**: ë™ì¼í•œ ìŠ¤ë ˆë“œê°€ **ê°™ì€ ë®¤í…ìŠ¤ë¥¼ ì—¬ëŸ¬ ë²ˆ ì ê¸€ ìˆ˜ ìˆëŠ”** `std::mutex`ì˜ ë³€í˜•ì´ë‹¤.
* **ì‹œê·¸ë‹ˆì²˜**:

  ```cpp
  class recursive_mutex {
  public:
      recursive_mutex();
      ~recursive_mutex();

      void lock();
      bool try_lock();
      void unlock();
  };
  ```
* **íŠ¹ì§•**:
  * ì ê¸ˆ íšŸìˆ˜ë¥¼ ë‚´ë¶€ ì¹´ìš´íŠ¸ë¡œ ê´€ë¦¬í•œë‹¤.
  * ë™ì¼ ìŠ¤ë ˆë“œê°€ ì—¬ëŸ¬ ë²ˆ `lock()`ì„ í˜¸ì¶œí•˜ë©´ ì ê¸ˆ ì¹´ìš´íŠ¸ê°€ ì¦ê°€í•˜ê³ , ê°™ì€ íšŸìˆ˜ë§Œí¼ `unlock()` í•´ì•¼ ì™„ì „íˆ í•´ì œëœë‹¤.

### ì‚¬ìš©í•´ì•¼ í•˜ëŠ” ê²½ìš°
* **ì¬ê·€ í•¨ìˆ˜ë‚˜ ë©¤ë²„ í•¨ìˆ˜ í˜¸ì¶œ ì²´ì¸ ë‚´ì—ì„œ ë™ì¼ ê°ì²´ë¥¼ ì—¬ëŸ¬ ë²ˆ ì ê¸€ ê°€ëŠ¥ì„±ì´ ìˆëŠ” ê²½ìš°**
  ì˜ˆ: `A::foo()`ì—ì„œ `lock()` í›„ ë‚´ë¶€ì ìœ¼ë¡œ `A::bar()`ë¥¼ í˜¸ì¶œí•˜ëŠ”ë°, `bar()`ë„ ê°™ì€ ë½ì„ ì‚¬ìš©í•œë‹¤ë©´ ì¼ë°˜ `std::mutex`ëŠ” ë°ë“œë½ì„ ì¼ìœ¼í‚¨ë‹¤. ì´ë•Œ `recursive_mutex`ê°€ í•„ìš”í•˜ë‹¤.

### ì¡°ì‹¬í•´ì•¼ í•˜ëŠ” ê²½ìš°
* **ë½ íšŸìˆ˜ë¥¼ ê´€ë¦¬í•˜ê¸° ì–´ë µë‹¤**
  `unlock()` íšŸìˆ˜ê°€ ì˜ëª»ë˜ë©´ ë…¼ë¦¬ì  ì˜¤ë¥˜ê°€ ë°œìƒí•œë‹¤.
* **ë¶ˆí•„ìš”í•˜ê²Œ ë‚¨ìš©í•˜ë©´ ì½”ë“œ êµ¬ì¡°ê°€ ë³µì¡í•´ì§€ê³ , ì„¤ê³„ê°€ ì˜ëª»ëìŒì„ ìˆ¨ê¸¸ ìˆ˜ ìˆë‹¤**
  ëŒ€ë¶€ë¶„ì˜ ê²½ìš°ëŠ” ì„¤ê³„ ê°œì„ ìœ¼ë¡œ ì¬ê·€ë½ì´ í•„ìš” ì—†ê²Œ ë§Œë“¤ ìˆ˜ ìˆë‹¤.
* **ì„±ëŠ¥ ì˜¤ë²„í—¤ë“œê°€ ìˆë‹¤**
  ë‚´ë¶€ì ìœ¼ë¡œ ì ê¸ˆ ì¹´ìš´íŠ¸ì™€ ìŠ¤ë ˆë“œ ID ì¶”ì ì´ í•„ìš”í•˜ë¯€ë¡œ `std::mutex`ë³´ë‹¤ ëŠë¦¬ë‹¤.

### ì˜ˆì œ ì½”ë“œ

```cpp
#include <iostream>
#include <mutex>

class Counter {
    std::recursive_mutex mtx;
    int value = 0;

    void add_internal(int x) {
        std::lock_guard<std::recursive_mutex> lock(mtx);
        value += x;
    }

public:
    void add(int x) {
        std::lock_guard<std::recursive_mutex> lock(mtx);
        add_internal(x); // ë‚´ë¶€ì—ì„œë„ ë™ì¼í•œ ë½ ì‚¬ìš©
    }

    int get() {
        std::lock_guard<std::recursive_mutex> lock(mtx);
        return value;
    }
};

int main() {
    Counter c;
    c.add(10);
    std::cout << c.get() << '\n';
}
```
  


## std::recursive_timed_mutex

### ê°œìš”
* **ì •ì˜**: `std::recursive_mutex` + `std::timed_mutex` ê¸°ëŠ¥ì„ í•©ì¹œ íƒ€ì…ì´ë‹¤.
  ì¦‰, ì¬ê·€ ì ê¸ˆì„ ì§€ì›í•˜ë©´ì„œë„ íƒ€ì„ì•„ì›ƒì´ ìˆëŠ” `try_lock_for`, `try_lock_until`ì„ ì œê³µí•œë‹¤.
* **ì‹œê·¸ë‹ˆì²˜**:

  ```cpp
  class recursive_timed_mutex {
  public:
      recursive_timed_mutex();
      ~recursive_timed_mutex();

      void lock();
      bool try_lock();
      bool try_lock_for(duration);
      bool try_lock_until(time_point);
      void unlock();
  };
  ```

### ì‚¬ìš©í•´ì•¼ í•˜ëŠ” ê²½ìš°
* **ì¬ê·€ì  í˜¸ì¶œ êµ¬ì¡°ê°€ ìˆê³ , ë™ì‹œì— ì ê¸ˆ ì‹œí•œì´ í•„ìš”í•œ ê²½ìš°**
  ì˜ˆ: ë³µì¡í•œ ìƒíƒœ ê´€ë¦¬ ê°ì²´ì—ì„œ ë©”ì„œë“œ ê°„ ìƒí˜¸ í˜¸ì¶œì´ ë°œìƒí•˜ê³ , ì ê¸ˆ ëŒ€ê¸° ì‹œê°„ ì œí•œì´ í•„ìš”í•  ë•Œ.

### ì¡°ì‹¬í•´ì•¼ í•˜ëŠ” ê²½ìš°
* **`recursive_mutex`ì™€ ê°™ì€ ë¬¸ì œì ** (ë½ íšŸìˆ˜ ê´€ë¦¬ ì–´ë ¤ì›€, ë‚¨ìš© ìœ„í—˜)
* **íƒ€ì„ì•„ì›ƒ ë¡œì§ ë³µì¡ë„ ì¦ê°€**
  ì¬ê·€ì ìœ¼ë¡œ ì—¬ëŸ¬ ë²ˆ ì ê¸ˆ í›„ ì¼ë¶€ë§Œ í•´ì œë˜ë©´ ì˜ˆê¸°ì¹˜ ì•Šì€ ìƒíƒœê°€ ë  ìˆ˜ ìˆë‹¤. ì„¤ê³„ ë‹¨ê³„ì—ì„œ ê°€ëŠ¥í•œ í”¼í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.

### ì˜ˆì œ ì½”ë“œ

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>

std::recursive_timed_mutex rtm;

void recursive_task(int depth) {
    if (rtm.try_lock_for(std::chrono::milliseconds(100))) {
        std::cout << "Lock acquired at depth " << depth << '\n';
        if (depth > 0) {
            recursive_task(depth - 1); // ê°™ì€ ìŠ¤ë ˆë“œì—ì„œ ì¬ê·€ì ìœ¼ë¡œ ì ê¸ˆ
        }
        rtm.unlock();
    } else {
        std::cout << "Timeout at depth " << depth << '\n';
    }
}

int main() {
    std::thread t(recursive_task, 3);
    t.join();
}
```
  