# 8ì£¼ì°¨ ì—°ìŠµ ë¬¸ì œ  
  

## ğŸš€ ë¬¸ì œ 1: ìŠ¤ë ˆë“œ ìƒì„±ê³¼ ë§¤ê°œë³€ìˆ˜ ì „ë‹¬ (ëŒë‹¤)

**ë¬¸ì œ:**
ë©”ì¸ ìŠ¤ë ˆë“œì—ì„œ `std::vector<int>`ë¥¼ í•˜ë‚˜ ìƒì„±í•©ë‹ˆë‹¤. ëŒë‹¤ í‘œí˜„ì‹ì„ ì‚¬ìš©í•˜ì—¬ ìƒˆ ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ê³ , ì´ ë²¡í„°ì˜ **ì°¸ì¡°**ë¥¼ ëŒë‹¤ì— ìº¡ì²˜í•˜ì—¬ ì „ë‹¬í•˜ì„¸ìš”. ìƒˆ ìŠ¤ë ˆë“œëŠ” 1ì´ˆ ëŒ€ê¸° í›„, ìº¡ì²˜í•œ ë²¡í„°ì— ì •ìˆ˜ 3ê°œë¥¼ (ì˜ˆ: 10, 20, 30) `push_back` í•´ì•¼ í•©ë‹ˆë‹¤. ë©”ì¸ ìŠ¤ë ˆë“œëŠ” ìŠ¤ë ˆë“œê°€ ì¢…ë£Œë  ë•Œê¹Œì§€ `join()` í•˜ê³ , ë²¡í„°ì˜ ìµœì¢… ë‚´ìš©ì„ ì¶œë ¥í•˜ì—¬ 3ê°œì˜ ì •ìˆ˜ê°€ ì˜¬ë°”ë¥´ê²Œ ì¶”ê°€ë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.

**íŒíŠ¸:**
ëŒë‹¤ í‘œí˜„ì‹ì€ ì§€ì—­ ë³€ìˆ˜ë¥¼ ê°’(`[=]`) ë˜ëŠ” ì°¸ì¡°(`[&]`)ë¡œ ìº¡ì²˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. `std::thread`ì— ëŒë‹¤ë¥¼ ì§ì ‘ ì „ë‹¬í•˜ì—¬ ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**ì˜ì‚¬ì½”ë“œ (Pseudocode):**

```
main():
  // 1. ë©”ì¸ ìŠ¤ë ˆë“œì—ì„œ ë²¡í„° ìƒì„±
  myVector = {1, 2, 3}
  print "ì´ˆê¸° ë²¡í„° í¬ê¸°:", myVector.size()

  // 2. ëŒë‹¤ë¥¼ ì‚¬ìš©í•´ ìŠ¤ë ˆë“œ ìƒì„± (ë²¡í„° ì°¸ì¡°[&] ìº¡ì²˜)
  t1 = create_thread(
      lambda (capture &myVector):
          print "ìŠ¤ë ˆë“œ: 1ì´ˆ ëŒ€ê¸°..."
          sleep(1 second)
          print "ìŠ¤ë ˆë“œ: ë°ì´í„° ì¶”ê°€ ì‹œì‘"
          myVector.push_back(10)
          myVector.push_back(20)
          myVector.push_back(30)
  )

  // 3. ë©”ì¸ ìŠ¤ë ˆë“œëŠ” ìŠ¤ë ˆë“œ ì¢…ë£Œ ëŒ€ê¸°
  t1.join()

  // 4. ìµœì¢… ê²°ê³¼ í™•ì¸
  print "ë©”ì¸: ìŠ¤ë ˆë“œ ì¢…ë£Œë¨. ìµœì¢… ë²¡í„° ë‚´ìš©:"
  print myVector
```

**ì •ë‹µ:**


-----

## ğŸš€ ë¬¸ì œ 2: `std::ref`ë¥¼ ì´ìš©í•œ ì°¸ì¡° ë§¤ê°œë³€ìˆ˜ ì „ë‹¬

**ë¬¸ì œ:**
`void modifyValue(int& value, int add)`ë¼ëŠ” í•¨ìˆ˜ë¥¼ ì‘ì„±í•˜ì„¸ìš”. ì´ í•¨ìˆ˜ëŠ” ì „ë‹¬ëœ ì°¸ì¡° `value`ì— `add`ë§Œí¼ì˜ ê°’ì„ ë”í•´ì•¼ í•©ë‹ˆë‹¤. `main` í•¨ìˆ˜ì—ì„œ `int myValue = 100;`ì„ ì„ ì–¸í•˜ê³ , `modifyValue` í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ëŠ” ìƒˆ ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ì„¸ìš”. ì´ ìŠ¤ë ˆë“œì— `myValue`ì˜ ì°¸ì¡°ì™€ 50ì„ ì¸ìë¡œ ì „ë‹¬í•˜ì„¸ìš”. ìŠ¤ë ˆë“œ ì¢…ë£Œ í›„ `myValue`ì˜ ê°’ì´ 150ì´ ë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.

**íŒíŠ¸:**
`std::thread` ìƒì„±ìëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ì¸ìë¥¼ *ë³µì‚¬*í•©ë‹ˆë‹¤. í•¨ìˆ˜ê°€ ì°¸ì¡°(`&`)ë¥¼ ì¸ìë¡œ ë°›ë”ë¼ë„, ìŠ¤ë ˆë“œì— ê·¸ëƒ¥ ì „ë‹¬í•˜ë©´ ê°’ì´ ë³µì‚¬ë˜ì–´ ì›ë³¸ì´ ìˆ˜ì •ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì›ë³¸ ë³€ìˆ˜ì˜ ì°¸ì¡°ë¥¼ ìŠ¤ë ˆë“œ í•¨ìˆ˜ì— ì „ë‹¬í•˜ë ¤ë©´ `std::ref()`ë¡œ ê°ì‹¸ì•¼ í•©ë‹ˆë‹¤.

**ì˜ì‚¬ì½”ë“œ (Pseudocode):**

```
// 1. ì°¸ì¡°ë¡œ ê°’ì„ ìˆ˜ì •í•˜ëŠ” í•¨ìˆ˜ ì •ì˜
function modifyValue(reference value, add):
  value = value + add
  print "ìŠ¤ë ˆë“œ: ê°’ì´ ", value, "(ìœ¼)ë¡œ ë³€ê²½ë¨"

main():
  // 2. ë©”ì¸ ìŠ¤ë ˆë“œì—ì„œ ë³€ìˆ˜ ì´ˆê¸°í™”
  myValue = 100
  print "ë©”ì¸: ì´ˆê¸°ê°’ = ", myValue

  // 3. std::refë¥¼ ì‚¬ìš©í•´ ì°¸ì¡° ì „ë‹¬
  t1 = create_thread(modifyValue, ref(myValue), 50)

  // 4. ìŠ¤ë ˆë“œ ì¢…ë£Œ ëŒ€ê¸°
  t1.join()

  // 5. ìµœì¢… ê°’ í™•ì¸
  print "ë©”ì¸: ìµœì¢…ê°’ = ", myValue
```

**ì •ë‹µ:**


-----

## ğŸš€ ë¬¸ì œ 3: ë ˆì´ìŠ¤ ì»¨ë””ì…˜ í•´ê²° (std::lock_guard)

**ë¬¸ì œ:**
ì „ì—­ ë³€ìˆ˜ `int g_counter = 0;`ê°€ ìˆìŠµë‹ˆë‹¤. 10ê°œì˜ ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ì—¬ ê° ìŠ¤ë ˆë“œê°€ 100,000ë²ˆì”© `g_counter`ë¥¼ ì¦ê°€ì‹œí‚¤ë„ë¡ í•˜ì„¸ìš”. `std::mutex`ì™€ `std::lock_guard`ë¥¼ ì‚¬ìš©í•˜ì—¬ `g_counter`ì— ëŒ€í•œ ì ‘ê·¼ì´ ìŠ¤ë ˆë“œë¡œë¶€í„° ì•ˆì „í•˜ë„ë¡(thread-safe) ë§Œë“œì„¸ìš”. ëª¨ë“  ìŠ¤ë ˆë“œ ì¢…ë£Œ í›„ `g_counter`ì˜ ìµœì¢… ê°’ì´ 1,000,000ì´ ë˜ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.

**íŒíŠ¸:**
ì „ì—­ `std::mutex`ë¥¼ í•˜ë‚˜ ì„ ì–¸í•˜ì„¸ìš”. ìŠ¤ë ˆë“œê°€ ì¹´ìš´í„°ë¥¼ ì¦ê°€ì‹œí‚¤ëŠ” ì„ê³„ ì˜ì—­(critical section)ì— ì ‘ê·¼í•˜ê¸° ì§ì „ì— `std::lock_guard<std::mutex> lock(my_mutex);`ë¥¼ ì„ ì–¸í•˜ì„¸ìš”. `lock_guard`ëŠ” ìƒì„± ì‹œ ìë™ìœ¼ë¡œ ë®¤í…ìŠ¤ë¥¼ ì ê·¸ê³ , ìŠ¤ì½”í”„ë¥¼ ë²—ì–´ë‚  ë•Œ (ì†Œë©¸ ì‹œ) ìë™ìœ¼ë¡œ ì ê¸ˆì„ í•´ì œí•˜ì—¬ ì˜ˆì™¸ê°€ ë°œìƒí•´ë„ ì•ˆì „í•©ë‹ˆë‹¤.

**ì˜ì‚¬ì½”ë“œ (Pseudocode):**

```
// 1. ì „ì—­ ë³€ìˆ˜ ë° ë®¤í…ìŠ¤ ì„ ì–¸
global g_counter = 0
global g_mutex

// 2. ìŠ¤ë ˆë“œê°€ ì‹¤í–‰í•  í•¨ìˆ˜
function increment():
  for i from 1 to 100000:
    // 3. lock_guardë¡œ ì„ê³„ ì˜ì—­ ë³´í˜¸
    lock_guard(g_mutex):
      g_counter = g_counter + 1
    // (ì—¬ê¸°ì„œ lock_guardê°€ ìë™ìœ¼ë¡œ unlock)
  
main():
  // 4. 10ê°œì˜ ìŠ¤ë ˆë“œ ìƒì„±
  threads_list
  for i from 1 to 10:
    threads_list.add(create_thread(increment))
  
  // 5. ëª¨ë“  ìŠ¤ë ˆë“œ ì¢…ë£Œ ëŒ€ê¸°
  for t in threads_list:
    t.join()
    
  // 6. ê²°ê³¼ ì¶œë ¥
  print "ì˜ˆìƒ ê²°ê³¼: 1000000"
  print "ì‹¤ì œ ê²°ê³¼:", g_counter
```

**ì •ë‹µ:**



-----

## ğŸš€ ë¬¸ì œ 4: `std::timed_mutex`ì™€ `try_lock_for`

**ë¬¸ì œ:**
`std::timed_mutex`ë¥¼ í•˜ë‚˜ ì„ ì–¸í•˜ì„¸ìš”. ì²« ë²ˆì§¸ ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ì—¬ ì´ ë®¤í…ìŠ¤ë¥¼ ì¦‰ì‹œ `lock()`í•˜ê³  2ì´ˆ ë™ì•ˆ `sleep`í•œ í›„ `unlock()`í•˜ê²Œ í•˜ì„¸ìš”. ì²« ë²ˆì§¸ ìŠ¤ë ˆë“œ ì‹œì‘ ì§í›„, ë‘ ë²ˆì§¸ ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ì„¸ìš”. ë‘ ë²ˆì§¸ ìŠ¤ë ˆë“œëŠ” 500ë°€ë¦¬ì´ˆ(`ms`) ë™ì•ˆë§Œ ë®¤í…ìŠ¤ ì ê¸ˆì„ ì‹œë„(`try_lock_for`)í•´ì•¼ í•©ë‹ˆë‹¤. ì ê¸ˆì— ì„±ê³µí•˜ë©´ "Lock Acquired"ë¥¼, ì‹œê°„ ë‚´ì— ì ê¸ˆì— ì‹¤íŒ¨í•˜ë©´(timeout) "Timed out"ì„ ì¶œë ¥í•˜ê²Œ í•˜ì„¸ìš”.

**íŒíŠ¸:**
`std::timed_mutex`ëŠ” `try_lock_for(duration)` ë©¤ë²„ í•¨ìˆ˜ë¥¼ ì œê³µí•©ë‹ˆë‹¤. ì´ í•¨ìˆ˜ëŠ” ì§€ì •ëœ ì‹œê°„ ë™ì•ˆ ì ê¸ˆì„ ì‹œë„í•˜ê³ , ì„±ê³µí•˜ë©´ `true`ë¥¼, ì‹¤íŒ¨í•˜ë©´ `false`ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

**ì˜ì‚¬ì½”ë“œ (Pseudocode):**

```
// 1. ì „ì—­ timed_mutex ì„ ì–¸
global g_timed_mutex (type timed_mutex)

// 2. ë½ì„ ì˜¤ë˜ ì¡ê³  ìˆëŠ” ìŠ¤ë ˆë“œ í•¨ìˆ˜
function long_task():
  g_timed_mutex.lock()
  print "Thread 1: ë½ íšë“, 2ì´ˆ ëŒ€ê¸°"
  sleep(2 seconds)
  g_timed_mutex.unlock()
  print "Thread 1: ë½ í•´ì œ"

// 3. ì‹œê°„ ì œí•œì„ ë‘ê³  ë½ì„ ì‹œë„í•˜ëŠ” ìŠ¤ë ˆë“œ í•¨ìˆ˜
function timed_task():
  print "Thread 2: 500ms ë½ ì‹œë„"
  // 4. try_lock_forë¡œ ì ê¸ˆ ì‹œë„
  if g_timed_mutex.try_lock_for(500ms):
    print "Thread 2: ì„±ê³µ"
    g_timed_mutex.unlock()
  else:
    print "Thread 2: ì‹œê°„ ì´ˆê³¼"
  
main():
  // 5. ìŠ¤ë ˆë“œ ì‹œì‘
  t1 = create_thread(long_task)
  sleep(100ms) // t1ì´ ë½ì„ ë¨¼ì € ì¡ë„ë¡ ë³´ì¥
  t2 = create_thread(timed_task)
  
  // 6. ì¢…ë£Œ ëŒ€ê¸°
  t1.join()
  t2.join()
```

**ì •ë‹µ:**



-----

## ğŸš€ ë¬¸ì œ 5: ì½ê¸°/ì“°ê¸° ë½ (std::shared\_mutex)

**ë¬¸ì œ:**
`std::shared_mutex`ë¥¼ ì‚¬ìš©í•˜ì—¬ ê°„ë‹¨í•œ `Configuration` í´ë˜ìŠ¤ë¥¼ êµ¬í˜„í•˜ì„¸ìš”. ì´ í´ë˜ìŠ¤ëŠ” `std::map<std::string, int>`ì„ ë‚´ë¶€ì— ê°€ì§‘ë‹ˆë‹¤.

1.  `int getSetting(const std::string& key)`: ì½ê¸° í•¨ìˆ˜. `std::shared_lock`ì„ ì‚¬ìš©í•˜ì—¬ ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ì„¤ì •ì„ ì½ì„ ìˆ˜ ìˆë„ë¡ í•˜ì„¸ìš”.
2.  `void setSetting(const std::string& key, int value)`: ì“°ê¸° í•¨ìˆ˜. `std::unique_lock<std::shared_mutex>`ì„ ì‚¬ìš©í•˜ì—¬ ì˜¤ì§ í•˜ë‚˜ì˜ ìŠ¤ë ˆë“œë§Œ ì„¤ì •ì„ ë³€ê²½í•  ìˆ˜ ìˆë„ë¡ í•˜ì„¸ìš” (ì´ë•Œ ëª¨ë“  ì½ê¸° ìŠ¤ë ˆë“œë„ ëŒ€ê¸°í•´ì•¼ í•¨).

**íŒíŠ¸:**
`std::shared_mutex`ëŠ” ì½ê¸°/ì“°ê¸° ë½ì…ë‹ˆë‹¤. `std::shared_lock`(ì½ê¸° ë½)ì€ ì—¬ëŸ¬ ê°œê°€ ë™ì‹œì— ì¡´ì¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. `std::unique_lock`(ì“°ê¸° ë½)ì€ ë°°íƒ€ì ì´ì–´ì„œ, ë‹¤ë¥¸ ëª¨ë“  `shared_lock`ê³¼ `unique_lock`ì„ ì°¨ë‹¨í•©ë‹ˆë‹¤.

**ì˜ì‚¬ì½”ë“œ (Pseudocode):**

```
class Configuration:
  mtx (type shared_mutex) // ì½ê¸°/ì“°ê¸° ë½
  settings (type map)
  
  // 1. ì½ê¸° í•¨ìˆ˜
  function getSetting(key):
    // 1-1. ê³µìœ  ë½ (ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ì ‘ê·¼ ê°€ëŠ¥)
    shared_lock(mtx): 
      print "READ ë½ íšë“"
      sleep(100ms)
      return settings.find(key)
  
  // 2. ì“°ê¸° í•¨ìˆ˜
  function setSetting(key, value):
    // 2-1. ë°°íƒ€ì  ë½ (ì˜¤ì§ í•œ ìŠ¤ë ˆë“œë§Œ ì ‘ê·¼ ê°€ëŠ¥)
    unique_lock(mtx): 
      print "WRITE ë½ íšë“"
      sleep(500ms)
      settings[key] = value

main():
  config = new Configuration()
  
  // 3. ì“°ê¸° ìŠ¤ë ˆë“œì™€ ì½ê¸° ìŠ¤ë ˆë“œë“¤ì„ ë™ì‹œì— ì‹œì‘
  t_writer = create_thread(config.setSetting, "Version", 1)
  t_reader1 = create_thread(config.getSetting, "Version")
  t_reader2 = create_thread(config.getSetting, "Version")
  
  // 4. ì¢…ë£Œ ëŒ€ê¸°
  t_writer.join()
  t_reader1.join()
  t_reader2.join()
```

**ì •ë‹µ:**



-----
  
## ğŸš€ ë¬¸ì œ 6: ìŠ¤ë ˆë“œ ìƒëª…ì£¼ê¸°ì™€ RAII (`ThreadGuard`)

**ë¬¸ì œ:**
ë¬¸ì„œì˜ `ThreadGuard` í´ë˜ìŠ¤ë¥¼ ì°¸ê³ í•˜ì—¬, ìŠ¤ë ˆë“œ ê°ì²´ì˜ `join()`ì„ ë³´ì¥í•˜ëŠ” RAII í´ë˜ìŠ¤ë¥¼ ì‘ì„±í•˜ì„¸ìš”. ì´ í´ë˜ìŠ¤ëŠ” ìƒì„±ìì—ì„œ `std::thread` ê°ì²´ì˜ ì°¸ì¡°ë¥¼ ë°›ê³ , ì†Œë©¸ìì—ì„œ í•´ë‹¹ ìŠ¤ë ˆë“œê°€ `joinable()`í•œì§€ í™•ì¸í•œ í›„ `join()`ì„ í˜¸ì¶œí•´ì•¼ í•©ë‹ˆë‹¤.
`main` í•¨ìˆ˜ ë‚´ì˜ `try` ë¸”ë¡ì—ì„œ ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ê³  `ThreadGuard`ë¡œ ê°ì‹¼ ë’¤, ê³ ì˜ë¡œ ì˜ˆì™¸ë¥¼ ë°œìƒì‹œí‚¤ì„¸ìš”. `catch` ë¸”ë¡ ì´í›„ì— "í”„ë¡œê·¸ë¨ ì¢…ë£Œ" ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•˜ê²Œ í•˜ì—¬, ì˜ˆì™¸ê°€ ë°œìƒí–ˆìŒì—ë„ ë¶ˆêµ¬í•˜ê³  `ThreadGuard`ì˜ ì†Œë©¸ìê°€ í˜¸ì¶œë˜ì–´ ìŠ¤ë ˆë“œê°€ ì•ˆì „í•˜ê²Œ `join`ë˜ì—ˆìŒì„ ì¦ëª…í•˜ì„¸ìš”.

**íŒíŠ¸:**
RAII(Resource Acquisition Is Initialization) íŒ¨í„´ì„ ì‚¬ìš©í•˜ë©´ ê°ì²´ì˜ ìƒëª…ì£¼ê¸°ë¥¼ í†µí•´ ìì›(ì—¬ê¸°ì„œëŠ” ìŠ¤ë ˆë“œ)ì„ ê´€ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆì™¸ê°€ ë°œìƒí•˜ì—¬ ìŠ¤íƒì´ í’€ë¦´ ë•Œ(stack unwinding) ê°ì²´ì˜ ì†Œë©¸ìê°€ í˜¸ì¶œë˜ëŠ” ê²ƒì„ ì´ìš©í•©ë‹ˆë‹¤.

**ì˜ì‚¬ì½”ë“œ (Pseudocode):**

```
// 1. RAII ê°€ë“œ í´ë˜ìŠ¤ ì •ì˜
class ThreadGuard:
  thread_ref t_ // ê´€ë¦¬í•  ìŠ¤ë ˆë“œ ì°¸ì¡°
  
  // 2. ìƒì„±ì: ìŠ¤ë ˆë“œ ì°¸ì¡°ë¥¼ ë°›ìŒ
  constructor(reference t):
    t_ = t
  
  // 3. ì†Œë©¸ì: ìŠ¤ë ˆë“œ ìë™ join
  destructor():
    print "ThreadGuard: ì†Œë©¸ì í˜¸ì¶œë¨."
    if t_.is_joinable():
      print "ThreadGuard: ìŠ¤ë ˆë“œ join() ì‹œë„..."
      t_.join()
      print "ThreadGuard: ìŠ¤ë ˆë“œ join() ì™„ë£Œ."

// 4. ìŠ¤ë ˆë“œ ì‘ì—… í•¨ìˆ˜
function background_task():
  print "Task: ì‹œì‘ë¨, 2ì´ˆê°„ ì‘ì—…..."
  sleep(2 seconds)
  print "Task: ì¢…ë£Œë¨."

main():
  // 5. try ë¸”ë¡ì—ì„œ ìŠ¤ë ˆë“œì™€ ê°€ë“œ ìƒì„±
  try:
    print "Main: ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œ ìƒì„±."
    t = create_thread(background_task)
    
    // të¥¼ ê´€ë¦¬í•˜ëŠ” guard ê°ì²´ ìƒì„±
    guard = new ThreadGuard(t)
    
    print "Main: 1ì´ˆ ëŒ€ê¸° í›„ ì˜ˆì™¸ ë°œìƒ!"
    sleep(1 second)
    throw_exception("ê³ ì˜ ì˜ˆì™¸") // ì˜ˆì™¸ ë°œìƒ
    
  // 6. catch ë¸”ë¡
  catch (exception e):
    print "Main: ì˜ˆì™¸ ì²˜ë¦¬: ", e
  
  // 7. (try-catchê°€ ëë‚˜ë©´ 'guard'ê°€ ì—¬ê¸°ì„œ ì†Œë©¸ë¨)
  print "Main: í”„ë¡œê·¸ë¨ ì¢…ë£Œ."
```

**ì •ë‹µ:**



-----

## ğŸš€ ë¬¸ì œ 7: `std::unique_lock`ì˜ ìœ ì—°í•œ ì‚¬ìš© (ìˆ˜ë™ lock/unlock)

**ë¬¸ì œ:**
`std::unique_lock`ì„ ì‚¬ìš©í•˜ì—¬ ë®¤í…ìŠ¤ë¥¼ ê´€ë¦¬í•˜ëŠ” í•¨ìˆ˜ë¥¼ ì‘ì„±í•˜ì„¸ìš”. ì´ í•¨ìˆ˜ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ë™ì‘í•´ì•¼ í•©ë‹ˆë‹¤.

1.  `std::unique_lock`ì„ ìƒì„±í•˜ë˜, ì²˜ìŒì—ëŠ” ë½ì„ ì ê·¸ì§€ ì•ŠìŠµë‹ˆë‹¤ (`std::defer_lock`).
2.  "ë½ ì—†ì´ ì‘ì—… ìˆ˜í–‰" ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤.
3.  ìˆ˜ë™ìœ¼ë¡œ `lock()`ì„ í˜¸ì¶œí•˜ì—¬ ë½ì„ íšë“í•©ë‹ˆë‹¤.
4.  "ì„ê³„ ì˜ì—­ ì§„ì…" ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤.
5.  ìˆ˜ë™ìœ¼ë¡œ `unlock()`ì„ í˜¸ì¶œí•˜ì—¬ ë½ì„ í•´ì œí•©ë‹ˆë‹¤.
6.  "ë½ ì™¸ë¶€ì—ì„œ ë‹¤ì‹œ ì‘ì—… ìˆ˜í–‰" ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤.

**íŒíŠ¸:**
`std::unique_lock`ì€ `std::lock_guard`ë³´ë‹¤ ìœ ì—°í•©ë‹ˆë‹¤. `std::unique_lock<std::mutex> lock(mtx, std::defer_lock);`ì²˜ëŸ¼ ìƒì„±í•˜ë©´ ë½ì„ ë°”ë¡œ ì ê·¸ì§€ ì•ŠìŠµë‹ˆë‹¤. ì´í›„ `lock.lock()`ê³¼ `lock.unlock()`ì„ ìˆ˜ë™ìœ¼ë¡œ í˜¸ì¶œí•˜ì—¬ ë½ì˜ ì†Œìœ ê¶Œì„ ì œì–´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**ì˜ì‚¬ì½”ë“œ (Pseudocode):**

```
global g_mutex

function flexible_lock_task():
  // 1. ë½ì„ ë‚˜ì¤‘ì— ì ê·¸ë„ë¡(deferred) unique_lock ìƒì„±
  lock = new unique_lock(g_mutex, defer_lock) 
  
  // 2. ë½ ì—†ì´ ì‘ì—…
  print "Thread", id, ": ë½ ì—†ì´ ì‘ì—… ìˆ˜í–‰"
  sleep(100ms)

  // 3. ìˆ˜ë™ ì ê¸ˆ
  lock.lock()
  
  // 4. ì„ê³„ ì˜ì—­
  print "Thread", id, ": ì„ê³„ ì˜ì—­ ì§„ì…"
  sleep(200ms)

  // 5. ìˆ˜ë™ í•´ì œ
  lock.unlock()
  
  // 6. ë½ ì™¸ë¶€ì—ì„œ ë‹¤ì‹œ ì‘ì—…
  print "Thread", id, ": ë½ ì™¸ë¶€ì—ì„œ ë‹¤ì‹œ ì‘ì—… ìˆ˜í–‰"
  
  // (í•¨ìˆ˜ê°€ ëë‚˜ë©´ lock ê°ì²´ëŠ” ì†Œë©¸í•˜ì§€ë§Œ, ì´ë¯¸ unlockëœ ìƒíƒœ)

main():
  t1 = create_thread(flexible_lock_task)
  t2 = create_thread(flexible_lock_task)
  t1.join()
  t2.join()
```

**ì •ë‹µ:**



-----

## ğŸš€ ë¬¸ì œ 8: "Check-then-Act" ë¬¸ì œ í•´ê²° (std::upgrade_lock)

**ë¬¸ì œ:**
`std::shared_mutex`ë¡œ ë³´í˜¸ë˜ëŠ” `int g_value = 0;`ê°€ ìˆìŠµë‹ˆë‹¤. ìŠ¤ë ˆë“œê°€ `g_value`ê°€ 0ì¼ ë•Œë§Œ("Check") ê°’ì„ 1ë¡œ ë³€ê²½("Act")í•˜ëŠ” ì‘ì—…ì„ ìˆ˜í–‰í•´ì•¼ í•©ë‹ˆë‹¤. í•˜ì§€ë§Œ "Check"ë¥¼ ìœ„í•´ `shared_lock`ì„ ì‚¬ìš©í•˜ê³  "Act"ë¥¼ ìœ„í•´ `unique_lock`ì„ ì‚¬ìš©í•˜ë©´, "Check"ì™€ "Act" ì‚¬ì´ì— ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ë¼ì–´ë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤ ("Check-then-Act" ì˜¤ë¥˜).
`std::upgrade_lock`ì„ ì‚¬ìš©í•˜ì—¬ ì´ ë¬¸ì œë¥¼ í•´ê²°í•˜ì„¸ìš”. ìŠ¤ë ˆë“œëŠ” `std::upgrade_lock`ì„ ì‚¬ìš©í•˜ì—¬ `g_value`ë¥¼ í™•ì¸í•˜ê³ , ì¡°ê±´ì´ ë§ìœ¼ë©´ ë½ì„ `std::upgrade_to_unique_lock`ìœ¼ë¡œ "ìŠ¹ê²©"ì‹œì¼œ ê°’ì„ ì•ˆì „í•˜ê²Œ ë³€ê²½í•´ì•¼ í•©ë‹ˆë‹¤.

**íŒíŠ¸:**
`std::upgrade_lock`ì€ ë‹¤ë¥¸ `shared_lock`ì€ í—ˆìš©í•˜ì§€ë§Œ, ë‹¤ë¥¸ `unique_lock`ì´ë‚˜ `upgrade_lock`ì€ ì°¨ë‹¨í•©ë‹ˆë‹¤. ë½ì„ í•´ì œí•˜ì§€ ì•Šê³  `std::upgrade_to_unique_lock`ìœ¼ë¡œ "ìŠ¹ê²©"ì‹œì¼œ `unique_lock`ìœ¼ë¡œ ë³€í™˜í•  ìˆ˜ ìˆìœ¼ë©°, ì´ ê³¼ì •ì€ "í‹ˆ"ì´ ì—†ì´(atomically) ì•ˆì „í•˜ê²Œ ìˆ˜í–‰ë©ë‹ˆë‹¤.

**ì˜ì‚¬ì½”ë“œ (Pseudocode):**

```
global g_shared_mtx (type shared_mutex)
global g_value = 0

function check_and_act(id):
  // 1. "ìŠ¹ê¸‰ìš© ë½" íšë“ (ì½ê¸° ë½ê³¼ ìœ ì‚¬í•˜ì§€ë§Œ, ìŠ¹ê¸‰ ê°€ëŠ¥ì„±ì„ ì˜ˆì•½)
  upgrade_lock(g_shared_mtx) as u_lock:
    print "Thread", id, ": (Upgrade Lock) ê°’ í™•ì¸..."
    
    // 2. "Check" (í™•ì¸)
    if g_value == 0:
      print "Thread", id, ": (Upgrade Lock) ê°’ì´ 0ì„. ì“°ê¸° ë½ìœ¼ë¡œ ìŠ¹ê²© ì‹œë„..."
      
      // 3. "Promote" (ìŠ¹ê²©) - ë½ì„ í’€ì§€ ì•Šê³  ì“°ê¸° ë½ìœ¼ë¡œ ë³€í™˜
      // (ì´ ìˆœê°„ ë‹¤ë¥¸ ëª¨ë“  ì½ê¸° ìŠ¤ë ˆë“œë„ ëŒ€ê¸° ì‹œì‘)
      unique_lock(move(u_lock)) as w_lock:
        
        // 4. "Act" (ì‹¤í–‰) - í‹ˆ ì—†ì´ ì•ˆì „í•˜ê²Œ ê°’ ë³€ê²½
        print "Thread", id, ": (Unique Lock) ìŠ¹ê²© ì„±ê³µ! ê°’ ë³€ê²½!"
        g_value = 1
        
    else:
      print "Thread", id, ": (Upgrade Lock) ê°’ì´ 0ì´ ì•„ë‹˜. ì¢…ë£Œ."
  // (u_lock ë˜ëŠ” w_lockì´ ì—¬ê¸°ì„œ ìë™ í•´ì œ)

main():
  // 5. ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ì‹œë„
  threads_list
  for i from 1 to 5:
    threads_list.add(create_thread(check_and_act, i))
  
  for t in threads_list:
    t.join()
  
  print "ìµœì¢… ê²°ê³¼:", g_value // (ê²°ê³¼ëŠ” í•­ìƒ 1ì´ì–´ì•¼ í•¨)
```

**ì •ë‹µ:**


  
---  
  
ë„¤, C++ ìŠ¤ë ˆë“œ APIë¥¼ í™œìš©í•œ ê²Œì„ ê°œë°œ ì‹œë‚˜ë¦¬ì˜¤ ê´€ë ¨ ë¬¸ì œ 2ê°œë¥¼ ì˜ì‚¬ì½”ë“œì™€ í•¨ê»˜ ë§Œë“¤ì–´ ë³´ì•˜ìŠµë‹ˆë‹¤.

(ì°¸ê³ : `std::atomic`ì„ ì‚¬ìš©í•˜ì§€ ë§ë¼ëŠ” ì´ì „ ìš”ì²­ì— ë”°ë¼, ì´ ë¬¸ì œë“¤ë„ `std::mutex`ì™€ `std::condition_variable`, `std::shared_mutex`ë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ êµ¬ì„±í–ˆìŠµë‹ˆë‹¤.)

-----

## ğŸš€ ë¬¸ì œ 9: ë°±ê·¸ë¼ìš´ë“œ ë¦¬ì†ŒìŠ¤ ë¡œë”© (Condition Variable)

**ë¬¸ì œ:**
ê²Œì„ í”Œë ˆì´ ì¤‘ ë©”ì¸ ìŠ¤ë ˆë“œ(ê²Œì„ ë£¨í”„)ê°€ ë©ˆì¶”ì§€ ì•Šë„ë¡, ìš©ëŸ‰ì´ í° í…ìŠ¤ì²˜ë‚˜ ë§µ ë°ì´í„° ê°™ì€ ë¦¬ì†ŒìŠ¤ë¥¼ **ë³„ë„ì˜ ìŠ¤ë ˆë“œ**ì—ì„œ ë¡œë”©í•´ì•¼ í•©ë‹ˆë‹¤.

`ResourceManager` í´ë˜ìŠ¤ë¥¼ ì‘ì„±í•˜ì„¸ìš”.

1.  `std::string m_resourceData` ë©¤ë²„ì™€ ë¡œë”© ì™„ë£Œ ì—¬ë¶€ë¥¼ ì•Œë¦´ `bool m_isLoaded` í”Œë˜ê·¸, ê·¸ë¦¬ê³  ì´ë¥¼ ë³´í˜¸í•  `std::mutex`ì™€ `std::condition_variable`ì„ ê°€ì§‘ë‹ˆë‹¤.
2.  `void startLoading()`: "Loading..." ë¬¸ìì—´ì„ `m_resourceData`ì— í• ë‹¹í•˜ëŠ” ì‘ì—…(ì‹¤ì œë¡œëŠ” ì‹œê°„ì´ ì˜¤ë˜ ê±¸ë¦¬ëŠ” íŒŒì¼ I/O)ì„ ì‹œë®¬ë ˆì´ì…˜í•˜ëŠ” ìƒˆ ìŠ¤ë ˆë“œë¥¼ ì‹œì‘í•©ë‹ˆë‹¤. ì´ ìŠ¤ë ˆë“œëŠ” ì‘ì—…ì„ ì™„ë£Œí•˜ë©´ `m_isLoaded`ë¥¼ `true`ë¡œ ì„¤ì •í•˜ê³ , ëŒ€ê¸° ì¤‘ì¸ ìŠ¤ë ˆë“œì— `notify_one()`ì„ ë³´ëƒ…ë‹ˆë‹¤. (ì‘ì—… ì‹œë®¬ë ˆì´ì…˜ì€ `std::this_thread::sleep_for(std::chrono::seconds(2))`ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.)
3.  `std::string getResource()`: ë©”ì¸ ìŠ¤ë ˆë“œê°€ í˜¸ì¶œí•  í•¨ìˆ˜ì…ë‹ˆë‹¤. `m_isLoaded`ê°€ `true`ê°€ ë  ë•Œê¹Œì§€ `std::condition_variable`ì˜ `wait()`ë¥¼ ì‚¬ìš©í•˜ì—¬ ëŒ€ê¸°í•´ì•¼ í•©ë‹ˆë‹¤. ë¦¬ì†ŒìŠ¤ê°€ ì¤€ë¹„ë˜ë©´ `m_resourceData`ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

`main` í•¨ìˆ˜ì—ì„œ `startLoading()`ì„ í˜¸ì¶œí•œ ì§í›„, `getResource()`ë¥¼ í˜¸ì¶œí•˜ì—¬ ë©”ì¸ ìŠ¤ë ˆë“œê°€ ë¦¬ì†ŒìŠ¤ ë¡œë”©ì´ ì™„ë£Œë  ë•Œê¹Œì§€ ì˜¬ë°”ë¥´ê²Œ ëŒ€ê¸°í•˜ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.

**íŒíŠ¸:**
`std::condition_variable::wait()`ëŠ” `std::unique_lock`ê³¼ í•¨ê»˜ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤. `wait`ëŠ” ëŒë‹¤ ì¡°ê±´ì‹ì´ `true`ë¥¼ ë°˜í™˜í•  ë•Œê¹Œì§€ (ë˜ëŠ” `notify`ë¥¼ ë°›ì„ ë•Œê¹Œì§€) ë®¤í…ìŠ¤ë¥¼ í•´ì œí•˜ê³  ëŒ€ê¸° ìƒíƒœì— ë“¤ì–´ê°‘ë‹ˆë‹¤.

**ì˜ì‚¬ì½”ë“œ (Pseudocode):**

```
class ResourceManager:
  mutex m_mtx
  condition_variable m_cv
  bool m_isLoaded = false
  string m_resourceData

  // [ì›Œì»¤ ìŠ¤ë ˆë“œ]
  function loadWork():
    sleep(2 seconds) // ì˜¤ë˜ ê±¸ë¦¬ëŠ” ë¡œë”© ì‹œë®¬ë ˆì´ì…˜
    
    // 1. ë½ì„ ì¡ê³  ë°ì´í„°ë¥¼ ì¤€ë¹„
    lock_guard(m_mtx):
      m_resourceData = "Heavy Resource Data"
      m_isLoaded = true
      print "[Loader Thread] ë¡œë”© ì™„ë£Œ!"
    
    // 2. ëŒ€ê¸° ì¤‘ì¸ ë©”ì¸ ìŠ¤ë ˆë“œë¥¼ ê¹¨ì›€
    m_cv.notify_one()

  // [ë©”ì¸ ìŠ¤ë ˆë“œ]
  function startLoading():
    // 3. ì›Œì»¤ ìŠ¤ë ˆë“œ ì‹œì‘
    create_thread(loadWork)
    print "[Main Thread] ë¡œë”© ì‹œì‘ ìš”ì²­..."

  // [ë©”ì¸ ìŠ¤ë ˆë“œ]
  function getResource():
    // 4. waitë¥¼ ìœ„í•œ unique_lock ì¤€ë¹„
    unique_lock(m_mtx) as lock
    
    print "[Main Thread] ë¦¬ì†ŒìŠ¤ ëŒ€ê¸° ì¤‘..."
    
    // 5. m_isLoadedê°€ trueê°€ ë  ë•Œê¹Œì§€ ëŒ€ê¸°
    // (ëŒ€ê¸°í•˜ëŠ” ë™ì•ˆ lockì€ ìë™ìœ¼ë¡œ í•´ì œë˜ê³ , ê¹¨ì–´ë‚˜ë©´ ë‹¤ì‹œ ì ê¹€)
    m_cv.wait(lock, lambda: return this.m_isLoaded)
    
    print "[Main Thread] ë¦¬ì†ŒìŠ¤ ìˆ˜ì‹ !"
    return m_resourceData

main():
  manager = new ResourceManager()
  manager.startLoading()
  
  // startLoading í›„ ë°”ë¡œ í˜¸ì¶œí•´ë„, getResourceëŠ” ë¡œë”©ì´ ëë‚  ë•Œê¹Œì§€ ëŒ€ê¸°í•¨
  data = manager.getResource()
  print "ìµœì¢… ë°ì´í„°:", data
```

**ì •ë‹µ:**



-----

## ğŸš€ ë¬¸ì œ 10: ìŠ¤ë ˆë“œ ì•ˆì „í•œ ê²Œì„ ì—”í‹°í‹° (Read-Write Lock)

**ë¬¸ì œ:**
ê²Œì„ ì›”ë“œì— `Player` ê°ì²´ê°€ í•˜ë‚˜ ìˆìŠµë‹ˆë‹¤. ì´ `Player` ê°ì²´ì˜ ë°ì´í„°(ìœ„ì¹˜, ì²´ë ¥)ëŠ” ì—¬ëŸ¬ ìŠ¤ë ˆë“œì—ì„œ ë™ì‹œì— ì ‘ê·¼ë©ë‹ˆë‹¤.

  * **ë¬¼ë¦¬ ìŠ¤ë ˆë“œ (Writer):** 0.1ì´ˆë§ˆë‹¤ í”Œë ˆì´ì–´ì˜ `position`ì„ ê°±ì‹ í•©ë‹ˆë‹¤.
  * **AI ìŠ¤ë ˆë“œ (Writer):** 0.5ì´ˆë§ˆë‹¤ í”Œë ˆì´ì–´ì˜ `health`ë¥¼ ê°±ì‹ í•©ë‹ˆë‹¤ (ì˜ˆ: ëª¬ìŠ¤í„°ì—ê²Œ í”¼ê²©).
  * **ë Œë”ë§ ìŠ¤ë ˆë“œ (Reader):** 0.016ì´ˆë§ˆë‹¤(ì•½ 60FPS) í”Œë ˆì´ì–´ì˜ `position`ê³¼ `health`ë¥¼ *ì½ì–´ì„œ* í™”ë©´ì— ì¶œë ¥í•©ë‹ˆë‹¤.

**ìš”êµ¬ì‚¬í•­:**
`std::shared_mutex`ë¥¼ ì‚¬ìš©í•˜ì—¬ `Player` í´ë˜ìŠ¤ë¥¼ ìŠ¤ë ˆë“œë¡œë¶€í„° ì•ˆì „í•˜ê²Œ ë§Œë“œì„¸ìš”.

1.  `updatePosition` (ë¬¼ë¦¬)ê³¼ `takeDamage` (AI) í•¨ìˆ˜ëŠ” **ì“°ê¸° ë½ (`std::unique_lock`)** ì„ ì‚¬ìš©í•˜ì—¬ ë°ì´í„°ë¥¼ ë°°íƒ€ì ìœ¼ë¡œ ìˆ˜ì •í•´ì•¼ í•©ë‹ˆë‹¤.
2.  `render` (ë Œë”ë§) í•¨ìˆ˜ëŠ” **ì½ê¸° ë½ (`std::shared_lock`)** ì„ ì‚¬ìš©í•˜ì—¬ ì—¬ëŸ¬ ë Œë”ë§ ìŠ¤ë ˆë“œ(ê°€ ìˆë‹¤ê³  ê°€ì •)ê°€ ë™ì‹œì—, ê·¸ë¦¬ê³  ì“°ê¸° ì‘ì—…ì´ ì—†ì„ ë•Œ, ë°ì´í„°ë¥¼ ë¹ ë¥´ê²Œ ì½ì–´ê°ˆ ìˆ˜ ìˆë„ë¡ í•´ì•¼ í•©ë‹ˆë‹¤.

**íŒíŠ¸:**
ì½ê¸° ì‘ì—…(Render)ì€ ìì£¼ ë°œìƒí•˜ê³ , ì“°ê¸° ì‘ì—…(Physics, AI)ì€ ë“œë¬¼ê²Œ ë°œìƒí•©ë‹ˆë‹¤. ì´ëŸ´ ë•Œ `std::shared_mutex`ê°€ ê°€ì¥ íš¨ìœ¨ì ì…ë‹ˆë‹¤. `std::shared_lock`ì€ ì—¬ëŸ¬ ë¦¬ë”ê°€ ë™ì‹œì— ì ‘ê·¼í•˜ëŠ” ê²ƒì„ í—ˆìš©í•˜ê³ , `std::unique_lock`ì€ ëª¨ë“  ë¦¬ë”ì™€ ë¼ì´í„°ë¥¼ ì°¨ë‹¨í•©ë‹ˆë‹¤. `const` ë©¤ë²„ í•¨ìˆ˜ì¸ `render`ì—ì„œ ë®¤í…ìŠ¤ë¥¼ ì ê·¸ë ¤ë©´ ë®¤í…ìŠ¤ë¥¼ `mutable`ë¡œ ì„ ì–¸í•´ì•¼ í•©ë‹ˆë‹¤.

**ì˜ì‚¬ì½”ë“œ (Pseudocode):**

```
class Player:
  mutable shared_mutex m_sharedMtx // ì½ê¸°/ì“°ê¸° ë½
  Vector3 position
  int health = 100

  // [ì“°ê¸° í•¨ìˆ˜ 1 - ë¬¼ë¦¬ ìŠ¤ë ˆë“œ]
  function updatePosition(newPos):
    // 1. ë°°íƒ€ì  ë½ (ì“°ê¸° ë½)
    unique_lock(m_sharedMtx):
      position = newPos
      print "[Physics] ìœ„ì¹˜ ê°±ì‹ "

  // [ì“°ê¸° í•¨ìˆ˜ 2 - AI ìŠ¤ë ˆë“œ]
  function takeDamage(damage):
    // 2. ë°°íƒ€ì  ë½ (ì“°ê¸° ë½)
    unique_lock(m_sharedMtx):
      health -= damage
      print "[AI] ë°ë¯¸ì§€ ì ìš©, ì²´ë ¥:", health

  // [ì½ê¸° í•¨ìˆ˜ - ë Œë”ë§ ìŠ¤ë ˆë“œ]
  function render() const:
    // 3. ê³µìœ  ë½ (ì½ê¸° ë½) - ì—¬ëŸ¬ ìŠ¤ë ˆë“œ ë™ì‹œ ì ‘ê·¼ ê°€ëŠ¥
    shared_lock(m_sharedMtx):
      print "[Render] ë Œë”ë§:", position, ", ì²´ë ¥:", health
      sleep(16ms) // ë Œë”ë§ ì‹œê°„ ì‹œë®¬ë ˆì´ì…˜

main():
  player = new Player()
  
  // 4. ìŠ¤ë ˆë“œë“¤ ì‹œì‘
  t_physics = create_thread_loop(player.updatePosition, 100ms)
  t_ai = create_thread_loop(player.takeDamage, 500ms)
  t_render = create_thread_loop(player.render, 16ms)
  
  sleep(2 seconds)
  // (ìŠ¤ë ˆë“œë“¤ ì¢…ë£Œ)
```

**ì •ë‹µ:**

 

