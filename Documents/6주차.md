# 6주차: Win32 스레드 프로그래밍 4 - 고급 동기화 기법 2

## 대기 없는 크리티컬 섹션 진입 TryEnterCriticalSection

```c
BOOL TryEnterCriticalSection(
  LPCRITICAL_SECTION lpCriticalSection
);
```

* **기능**
  지정된 크리티컬 섹션에 진입을 시도한다.
  이미 다른 스레드가 소유하고 있으면 **즉시 FALSE를 반환**하고, 소유할 수 있으면 TRUE를 반환한다.
* **특징**
  * 블로킹(blocking)하지 않는다.
  * 락을 얻지 못해도 스레드가 커널 오브젝트 대기 상태로 내려가지 않는다.
  * 폴링(polling) 방식이나 조건부 진입이 필요할 때 적합하다.

### 사용해야 할 때
* **스레드가 절대 블로킹되면 안 되는 상황**
  (예: 게임 서버의 로직 루프, 실시간 처리, 렌더링 루프)
* 락을 얻지 못하면 다른 작업을 하고 나중에 다시 시도하는 것이 더 효율적인 경우

### 예제 코드

```c
#include <windows.h>
#include <stdio.h>

CRITICAL_SECTION cs;

DWORD WINAPI WorkerThread(LPVOID param) {
    for (int i = 0; i < 5; i++) {
        if (TryEnterCriticalSection(&cs)) {
            // 임계 구역 진입 성공
            printf("Thread %d: Entered critical section\n", GetCurrentThreadId());
            Sleep(100); // 공유 리소스 작업
            LeaveCriticalSection(&cs);
            printf("Thread %d: Left critical section\n", GetCurrentThreadId());
        } else {
            // 락을 얻지 못했을 때 처리
            printf("Thread %d: Could not enter, doing something else...\n", GetCurrentThreadId());
            Sleep(50); // 다른 작업 수행
        }
    }
    return 0;
}

int main() {
    InitializeCriticalSection(&cs);

    HANDLE hThreads[2];
    for (int i = 0; i < 2; i++) {
        hThreads[i] = CreateThread(NULL, 0, WorkerThread, NULL, 0, NULL);
    }
    WaitForMultipleObjects(2, hThreads, TRUE, INFINITE);

    DeleteCriticalSection(&cs);
    return 0;
}
```


## 무작정 스레드를 재우지 마라! InitializeCriticalSectionAndSpinCount 활용법

```c
BOOL InitializeCriticalSectionAndSpinCount(
  LPCRITICAL_SECTION lpCriticalSection,
  DWORD dwSpinCount
);
```  
  
* **기능**  
  크리티컬 섹션을 초기화하면서 **스핀 카운트(Spin Count)** 를 지정한다.
* **특징**
  * 락이 이미 점유되어 있으면, 커널 오브젝트 대기로 내려가기 전에 지정된 횟수만큼 **짧게 바쁜 루프(spin)** 를 돈다.  
  * 락 점유 시간이 짧은 경우, 커널 모드 전환 비용을 줄여 성능 향상에 효과적이다.
  * 멀티코어 CPU에서 특히 효과적이다.

  
`InitializeCriticalSectionAndSpinCount` 에서 설정하는 **`dwSpinCount` 값은 "시간 단위"가 아니다**.  
즉, 밀리초(ms)나 나노초(ns) 같은 **시간 단위와 직접적인 매핑이 없다**.
  
* `dwSpinCount`는 **락을 얻기 위해 시도하는 "루프 횟수"**를 의미한다.
* CPU는 크리티컬 섹션이 해제되었는지를 확인하기 위해 지정된 횟수만큼 **짧은 루프(spin loop)** 를 수행한다.  
* 이 루프 안에서 CPU는 실제로는 **몇 번의 어셈블리 명령어(pause 등)** 를 실행하며, 해당 횟수가 곧 `dwSpinCount` 값이다.  
  
즉:
  
* `dwSpinCount = 4000` 이라면 → 약 4000번 루프 돌면서 락 해제 여부를 확인한다.
* 루프가 끝날 때까지 락을 못 얻으면 → 커널 오브젝트 대기로 전환한다.

  
>> Microsoft 공식 가이드  
>> * Spin count 값은 **CPU에 따라 경험적으로 조정**해야 한다.
>> * 보통 **수천 단위 (예: 4000 ~ 10000)** 로 설정하는 것이 권장된다.
>> * 너무 크면 CPU 낭비가 발생하고, 너무 작으면 성능 최적화 효과가 없다.  
  
    
### 사용해야 할 때
* **락 경쟁이 자주 발생하지만 점유 시간이 짧을 때**
  (예: 짧은 연산을 자주 동기화하는 경우)
* 커널 전환 비용이 크고 유저 모드에서 기다리는 것이 더 효율적인 경우
 
  
### 예제 코드

```c
#include <windows.h>
#include <stdio.h>

CRITICAL_SECTION cs;

DWORD WINAPI WorkerThread(LPVOID param) {
    for (int i = 0; i < 3; i++) {
        EnterCriticalSection(&cs);
        printf("Thread %d: In critical section\n", GetCurrentThreadId());
        Sleep(100); // 공유 자원 접근
        LeaveCriticalSection(&cs);
    }
    return 0;
}

int main() {
    // Spin count = 4000 (권장: 0x00000400 ~ 0x00000FA0 정도 실험적으로 설정)
    if (!InitializeCriticalSectionAndSpinCount(&cs, 4000)) {
        printf("Failed to initialize critical section with spin count\n");
        return 1;
    }

    HANDLE hThreads[2];
    for (int i = 0; i < 2; i++) {
        hThreads[i] = CreateThread(NULL, 0, WorkerThread, NULL, 0, NULL);
    }
    WaitForMultipleObjects(2, hThreads, TRUE, INFINITE);

    DeleteCriticalSection(&cs);
    return 0;
}
```
  
  
  
## "읽기"와 "쓰기"를 분리하는 동기화 전략: Reader-Writer Lock
Reader-Writer Lock(RWLock)은 읽기 작업과 쓰기 작업을 구분하여, 여러 스레드가 동시에 읽기를 수행할 수 있도록 하는 동기화 메커니즘이다. Windows에서는 **Slim Reader/Writer (SRW) Lock**을 제공한다.  

```
     [Reader-Writer Lock 동작 방식]
     
     Reader 1 ----[읽기]----┐
     Reader 2 ----[읽기]----├── 동시 접근 가능
     Reader 3 ----[읽기]----┘
     
     Writer   ----[쓰기]-------- 독점 접근
     
     상태 전이:
     [Idle] -> [Reading(n)] -> [Idle]
        ↓                         ↑
     [Writing] <-----------------┘
```
  

Windows의 **SRWLOCK(Slim Reader/Writer Lock)** 은 경량화된 Reader/Writer 락으로, 여러 스레드가 동시에 읽을 수 있도록 허용하면서도 쓰기 작업은 배타적으로 수행되도록 보장하는 동기화 객체다. SRWLOCK은 매우 빠르며 커널 오브젝트를 생성하지 않기 때문에 성능이 중요한 곳에서 자주 사용된다.
  

### SRWLOCK(Slim Reader/Writer Lock) 사용 방법과 주요 API

#### SRWLOCK 기본 개념
* SRWLOCK은 **커널 오브젝트 핸들**을 필요로 하지 않는다.
* 초기화가 간단하며, `InitializeSRWLock` 또는 정적 초기화로 사용할 수 있다.
* 한 번에 여러 Reader가 접근 가능하지만, Writer는 단독 접근만 가능하다.
* 스레드가 락을 획득하지 못하면 커널로 진입해 대기할 수 있다.

#### 초기화

```c
SRWLOCK lock;
InitializeSRWLock(&lock);
```

#### Reader 모드 API
여러 스레드가 동시에 읽기를 할 수 있다.

```c
AcquireSRWLockShared(&lock);
// 읽기 작업 수행
ReleaseSRWLockShared(&lock);
```

#### Writer 모드 API
Writer는 배타적으로 락을 잡는다.

```c
AcquireSRWLockExclusive(&lock);
// 쓰기 작업 수행
ReleaseSRWLockExclusive(&lock);
```

#### Try API (비차단 시도)
락을 즉시 획득할 수 없는 경우 `FALSE`를 반환한다.

```c
if (TryAcquireSRWLockShared(&lock)) {
    // 읽기 가능
    ReleaseSRWLockShared(&lock);
}

if (TryAcquireSRWLockExclusive(&lock)) {
    // 쓰기 가능
    ReleaseSRWLockExclusive(&lock);
}
```

#### 주의사항
* SRWLOCK은 **재귀적으로 사용 불가**하다. 같은 스레드가 동일 락을 두 번 획득하면 교착 상태가 발생한다.
* SRWLOCK은 구조체 복사나 이동이 불가능하다. 반드시 초기화된 객체 자체를 사용해야 한다.
* Condition Variable과 함께 사용할 수 있다 (`SleepConditionVariableSRW`).

#### 예제 코드

```c
#include <windows.h>
#include <stdio.h>

SRWLOCK lock;

DWORD WINAPI ReaderThread(LPVOID param) {
    AcquireSRWLockShared(&lock);
    printf("Reader acquired lock\n");
    Sleep(1000);
    ReleaseSRWLockShared(&lock);
    return 0;
}

DWORD WINAPI WriterThread(LPVOID param) {
    AcquireSRWLockExclusive(&lock);
    printf("Writer acquired lock\n");
    Sleep(1000);
    ReleaseSRWLockExclusive(&lock);
    return 0;
}

int main() {
    InitializeSRWLock(&lock);

    HANDLE h1 = CreateThread(NULL, 0, ReaderThread, NULL, 0, NULL);
    HANDLE h2 = CreateThread(NULL, 0, WriterThread, NULL, 0, NULL);

    WaitForSingleObject(h1, INFINITE);
    WaitForSingleObject(h2, INFINITE);

    return 0;
}
```

정리하면, SRWLOCK은 **고성능 Reader/Writer 동기화 도구**이며 `AcquireSRWLockShared/Exclusive`, `ReleaseSRWLockShared/Exclusive`, `TryAcquireSRWLockShared/Exclusive` API를 통해 사용하면 된다.


### SRW Lock 구현 예제: Cache 데이터 동기화 하기  
아래 코드는 Windows의 SRWLOCK을 사용하여 스레드 안전한 캐시를 구현한다.
- InitializeSRWLock: SRWLOCK 변수를 초기화한다.
- AcquireSRWLockShared / ReleaseSRWLockShared: 읽기 락을 획득하고 해제한다. 이 락은 여러 스레드가 동시에 획득할 수 있다.
- AcquireSRWLockExclusive / ReleaseSRWLockExclusive: 쓰기 락을 획득하고 해제한다. 이 락은 독점적이다.

SRWLOCK은 커널 모드로 전환되지 않는 매우 가볍고 빠른 동기화 객체로, 경쟁이 적은 상황에서 최고의 성능을 보인다.   
    
```
#include <windows.h>
#include <process.h> 
#include <iostream>
#include <vector>
#include <random>

// Windows의 Slim Reader/Writer(SRW) Lock을 사용하는 스레드 안전 캐시 클래스
class ThreadSafeCache {
private:
    SRWLOCK srwLock;
    std::vector<int> data;
    int version;

public:
    ThreadSafeCache() : version(0) {
        InitializeSRWLock(&srwLock);
        data.reserve(100);
    }

    // 읽기 작업 - 여러 스레드가 동시에 접근 가능 (Shared Lock)
    int Read(size_t index) {
        AcquireSRWLockShared(&srwLock);

        int result = -1;
        if (index < data.size()) {
            result = data[index];
            // GetCurrentThreadId()는 Windows API 함수이지만, _beginthreadex가 반환하는 스레드 ID와 다릅니다.
            // 여기서는 단순히 시스템 스레드 ID를 출력합니다.
            std::cout << "[Reader " << GetCurrentThreadId()
                << "] Read value " << result
                << " at index " << index
                << " (version: " << version << ")" << std::endl;
        }

        // 읽기 작업 시뮬레이션을 위한 지연
        Sleep(100);

        ReleaseSRWLockShared(&srwLock);
        return result;
    }

    // 쓰기 작업 - 하나의 스레드만 독점적으로 접근 (Exclusive Lock)
    void Write(int value) {
        AcquireSRWLockExclusive(&srwLock);

        data.push_back(value);
        version++;
        std::cout << "[Writer " << GetCurrentThreadId()
            << "] Wrote value " << value
            << " (new version: " << version << ")" << std::endl;

        // 쓰기 작업 시뮬레이션을 위한 지연
        Sleep(200);

        ReleaseSRWLockExclusive(&srwLock);
    }

    // 캐시의 현재 크기를 스레드 안전하게 반환
    size_t Size() {
        AcquireSRWLockShared(&srwLock);
        size_t size = data.size();
        ReleaseSRWLockShared(&srwLock);
        return size;
    }
};

// Writer 스레드가 실행할 함수
// _beginthreadex는 unsigned (__stdcall *start_address)(void *) 형태의 함수 포인터를 요구합니다.
unsigned int __stdcall WriterThreadFunc(void* pContext) {
    ThreadSafeCache* cache = static_cast<ThreadSafeCache*>(pContext);
    int threadId = GetCurrentThreadId(); // 예시를 위한 ID

    for (int j = 0; j < 3; j++) {
        cache->Write(threadId * 10 + j);
        Sleep(300);
    }
    _endthreadex(0);
    return 0;
}

// Reader 스레드가 실행할 함수
unsigned int __stdcall ReaderThreadFunc(void* pContext) {
    ThreadSafeCache* cache = static_cast<ThreadSafeCache*>(pContext);
    std::random_device rd;
    std::mt19937 gen(rd());

    for (int j = 0; j < 5; j++) {
        size_t size = cache->Size();
        if (size > 0) {
            std::uniform_int_distribution<> dis(0, size - 1);
            cache->Read(dis(gen));
        }
        Sleep(150);
    }
    _endthreadex(0);
    return 0;
}

int main() {
    std::cout << "=== Reader-Writer Lock Test with SRWLOCK and _beginthreadex ===\n" << std::endl;

    ThreadSafeCache cache;
    std::vector<HANDLE> hThreads;

    // Writer 스레드 생성
    for (int i = 0; i < 2; i++) {
        HANDLE hThread = (HANDLE)_beginthreadex(NULL, 0, &WriterThreadFunc, &cache, 0, NULL);
        if (hThread) {
            hThreads.push_back(hThread);
        }
    }

    // Reader 스레드 생성
    for (int i = 0; i < 4; i++) {
        HANDLE hThread = (HANDLE)_beginthreadex(NULL, 0, &ReaderThreadFunc, &cache, 0, NULL);
        if (hThread) {
            hThreads.push_back(hThread);
        }
    }

    // 모든 스레드가 종료될 때까지 대기
    WaitForMultipleObjects(hThreads.size(), hThreads.data(), TRUE, INFINITE);

    // 스레드 핸들 정리
    for (HANDLE hThread : hThreads) {
        CloseHandle(hThread);
    }

    std::cout << "\nAll threads finished." << std::endl;

    return 0;
}
```  
  

### SRW Lock을 사용하면 좋은 경우
SRW(Slim Reader/Writer) Lock은 Windows에서 제공하는 가벼운 Reader-Writer 락으로, 다음과 같은 상황에서 특히 유용하다.
 
1. **읽기 작업이 많은 경우**
   여러 스레드가 동시에 데이터를 읽는 빈도가 높고, 쓰기 작업은 상대적으로 드문 상황에서 SRW Lock은 큰 장점을 가진다.
   예를 들어 캐시 조회, 설정 값 읽기, 통계 데이터 확인처럼 읽기 연산이 지배적인 경우에 적합하다.  

   게임 서버에서는 **플레이어 상태 조회**가 대표적인 예다.  
   * 예를 들어 MMORPG 서버에서 수천 명의 유저가 동시에 "내 현재 체력/마나/위치" 같은 상태를 확인한다고 하자.
   * 이 경우 대부분은 단순 조회(읽기)만 발생한다.
   * 반대로 쓰기(예: 체력 감소, 아이템 추가)는 특정 이벤트 때만 발생한다.

   이때 SRW Lock을 사용하면 여러 클라이언트가 동시에 **플레이어 상태를 읽는 작업**을 병렬로 처리할 수 있어 성능이 크게 향상된다. 
    

2. **짧고 빈번한 락 구간**
   SRW Lock은 커널 오브젝트 기반의 무거운 동기화 방식(Mutex, Event 등)에 비해 비용이 낮다. 따라서 락을 매우 자주 획득하고 해제하는 경우에도 성능 저하를 최소화할 수 있다.

   게임에서 **몬스터 AI 갱신**을 생각해보자.  
   * 수많은 몬스터가 프레임마다 행동 로직을 계산하면서 전역 데이터를 잠깐 확인해야 한다고 하자.
   * 예: 전역 난이도 설정, 현재 던전 보너스 값, 날씨 시스템에서 가져오는 버프 정보 등.

   이 데이터는 매우 짧게 접근(읽기 or 쓰기)되지만, 횟수가 엄청 많다.
   * Mutex처럼 무거운 락을 걸면 매번 커널 오브젝트 호출로 성능이 급격히 떨어진다.
   * SRW Lock은 훨씬 가볍기 때문에 이런 **짧고 빈번한 접근**에 적합하다.
    

3. **단순한 공유 자원 보호**
   복잡한 우선순위 정책이나 다단계 조건이 필요 없는 경우 SRW Lock은 단순히 “읽기 병렬, 쓰기 단독” 규칙을 보장하기 때문에 구현이 쉽고 명확하다.

   게임 내 **랭킹 보드(Leaderboard)** 를 관리하는 경우를 예로 들 수 있다.  
   * 대부분의 플레이어는 랭킹을 **조회(읽기)** 만 한다.
   * 가끔 한정된 이벤트에서 점수가 갱신되면서 특정 플레이어의 데이터만 수정(쓰기)된다.

   여기서는 복잡한 정책(예: 특정 유저 우선 처리, 여러 조건부 업데이트)이 필요하지 않고, 단순히 "읽기는 다 같이 가능, 쓰기는 단독만 가능"이면 충분하다.
   * 따라서 SRW Lock으로 깔끔하게 구현할 수 있다.
     
    
4. **Condition Variable과의 연계**
   SRW Lock은 Windows의 Condition Variable과 함께 사용할 수 있다. 이를 통해 생산자-소비자 패턴 같은 동기화 시나리오를 간결하게 구현할 수 있다.

   게임 서버에서 **퀘스트 보상 큐(Reward Queue)** 를 예로 들자.  
   * Writer 스레드: 플레이어가 퀘스트를 완료하면 보상을 큐에 추가한다.
   * Reader 스레드: 클라이언트에 보상을 지급하는 스레드가 큐에서 데이터를 꺼낸다.

   여기서 보상 큐가 비어 있으면 Reader 스레드는 기다려야 한다.  
   * 이때 Condition Variable을 사용하면 Reader는 효율적으로 대기할 수 있고, Writer가 새로운 보상을 추가할 때 Reader를 깨울 수 있다.
   * SRW Lock과 Condition Variable을 함께 쓰면 이런 **생산자-소비자 패턴**을 간단하게 처리할 수 있다.
  
    
### SRW Lock의 성능과 주의할 점

#### 성능
* **가벼움**: SRW Lock은 내부적으로 커널 오브젝트를 생성하지 않고 사용자 모드에서 대부분의 처리를 수행한다. 그 결과 Mutex보다 훨씬 빠르고, Reader-Writer Lock 자체를 직접 구현하는 것보다 안정적이다.
* **자동 최적화**: Windows 커널 수준에서 효율적인 큐잉과 스케줄링이 이루어지므로, 개발자가 직접 대기열 관리나 이벤트 신호 처리를 구현할 필요가 없다.
* **낮은 리소스 사용량**: 별도의 핸들 관리가 필요 없으며, 메모리 사용량도 적다.

#### 주의할 점
1. **재귀적 사용 불가**
   SRW Lock은 같은 스레드가 동일 락을 중첩해서 획득하는 것을 허용하지 않는다. 같은 스레드에서 두 번 `AcquireSRWLockExclusive`를 호출하면 교착 상태가 발생한다.

2. **락 해제 책임**
   락을 획득한 스레드가 반드시 짝을 맞춰 해제해야 한다. 특히 예외 상황이나 조기 반환 코드 경로에서 해제를 빠뜨리면 다른 스레드가 영원히 대기할 수 있다.

3. **락 모드 혼동 주의**
   Reader 모드(`Shared`)와 Writer 모드(`Exclusive`)가 구분되어 있으며, 대응되는 해제 함수(`ReleaseSRWLockShared`, `ReleaseSRWLockExclusive`)를 정확히 사용해야 한다. 잘못된 짝을 사용하면 프로그램 동작이 보장되지 않는다.

4. **공정성(Fairness) 보장 제한**
   SRW Lock은 설계상 Writer 우선 정책을 적용할 수 있지만, 특정 시나리오에서는 Reader가 계속 들어와 Writer가 기아(starvation) 상태에 빠질 수 있다. 긴급하게 Writer 우선 처리를 보장해야 한다면 별도의 정책 제어가 필요하다.
  
  
정리하면, SRW Lock은 **읽기 위주 + 짧은 임계 구간**에 이상적이며, Mutex 대비 큰 성능 이점을 제공한다. 다만, **재귀 불가**, **짝 맞는 API 사용 필수**, **공정성 관리 한계**와 같은 특성을 반드시 염두에 두고 적용해야 한다.
  
  
  
## 조건 변수(Condition Variables) 
  
### 개념과 목적
조건 변수는 “공유 상태가 **특정 조건**을 만족할 때까지 스레드를 잠시 재움(sleep)”으로써 **바쁜 대기(spin)** 없이 효율적으로 동기화하는 원시 동기화 객체다. 조건 변수 자체는 락이 아니며, **반드시 락(임계 구역 `CRITICAL_SECTION` 또는 `SRWLOCK`)과 함께** 사용한다. 전형적인 패턴은 다음과 같다:

1. 락을 잡는다.
2. 조건을 검사한다.
3. 조건이 거짓이면 조건 변수에서 잠든다(이때 **락을 원자적으로 풀고** 기다린다).
4. 깨어나면 락을 **다시 잡은 상태로** 깨어난다.
5. 조건이 참이 되면 작업을 진행한다.

이 방식으로 **잃어버린 신호(lost wakeup)** 와 경쟁 조건을 방지한다.
  

### 지원 환경과 특징
* Windows Vista / Windows Server 2008 이상에서 지원한다.
* 커널 오브젝트 핸들이 필요 없으며, 구조체 한 덩어리로 관리되므로 **생성/파괴 비용이 매우 낮다**.
* **파괴 함수가 없다**. 사용 종료 시 별도 정리가 필요 없다.
* **공정성(fairness) 보장 없음** → 깨어난 스레드의 순서는 비결정적이다. 따라서 항상 조건을 `while` 루프로 재검사해야 한다.
* `WaitForMultipleObjects` 등과 결합해 **여러 객체 동시 대기**는 할 수 없다. 조건 변수 전용 대기 API만 사용한다.
    
#### 커널 오브젝트 핸들이 필요 없고 구조체 한 덩어리라 생성/파괴 비용이 매우 낮다
* `CONDITION_VARIABLE`은 사용자 모드 메모리 상의 작은 구조체일 뿐이며 커널 핸들을 소유하지 않는다
* 초기화는 **비용이 사실상 0에 가까운 상수 시간**이며 동적 할당이 없다
* 정적/전역 초기화도 가능하다 (`CONDITION_VARIABLE cv = CONDITION_VARIABLE_INIT;`)
* 보호 락은 `CRITICAL_SECTION`(경량 뮤텍스) 또는 `SRWLOCK`(Slim Reader/Writer) 중 하나를 쓴다

최소 초기화 예제:  

```c
#include <windows.h>

CRITICAL_SECTION g_cs;
CONDITION_VARIABLE g_cv;

void init_sync(void) {
    InitializeCriticalSection(&g_cs);
    InitializeConditionVariable(&g_cv); // 또는: CONDITION_VARIABLE g_cv = CONDITION_VARIABLE_INIT;
}
```  
```
#include <windows.h>
#include <iostream>
#include <queue> // std::queue를 공유 자원으로 사용

// --- 전역 변수 ---
std::queue<int> g_queue; // 스레드가 공유할 큐
CRITICAL_SECTION g_lock; // 큐를 보호할 잠금(Lock)

// 1. CONDITION_VARIABLE을 정적 매크로로 초기화합니다.
CONDITION_VARIABLE g_cv = CONDITION_VARIABLE_INIT;
```  
  
주의점:  
* 구조체 자체는 가볍지만 **대기·깨우기 시점에는 내부적으로 커널 대기가 발생할 수 있다**는 점을 이해해야 한다
* **이동/복사 금지**가 사실상 규칙이다. 대기 중인 스레드가 있는 동안 주소가 바뀌면 안 된다

#### 파괴 함수가 없다 → 사용 종료 시 별도 정리가 필요 없다
* `DeleteConditionVariable` 같은 API는 존재하지 않는다
* 이유는 핸들이 없고 내부 리소스도 소유하지 않기 때문이다
* 다만 **수명 관리 규칙**은 반드시 지켜야 한다
  * 조건 변수가 놓인 메모리를 해제하거나 객체를 파괴하기 전에 **대기 중인 스레드가 없도록** 만들어야 한다
  * 보통 “종료 플래그 설정 → `WakeAllConditionVariable`로 모두 깨우기 → 스레드 `Join` → 락 정리” 순서를 따른다
  
안전한 종료 패턴 예제:  

```c
#include <windows.h>
#include <stdbool.h>

CRITICAL_SECTION g_cs;
CONDITION_VARIABLE g_cv;
bool g_stop = false;

DWORD WINAPI worker(LPVOID) {
    EnterCriticalSection(&g_cs);
    while (!g_stop) {
        // 작업이 생길 때까지 기다린다고 가정
        SleepConditionVariableCS(&g_cv, &g_cs, INFINITE);
        if (g_stop) break;
        // 공유 상태 소비 작업 ...
    }
    LeaveCriticalSection(&g_cs);
    return 0;
}

void shutdown_all(HANDLE *threads, int n) {
    EnterCriticalSection(&g_cs);
    g_stop = true;
    WakeAllConditionVariable(&g_cv); // 남아있는 모든 대기를 깨운다
    LeaveCriticalSection(&g_cs);

    WaitForMultipleObjects(n, threads, TRUE, INFINITE);

    DeleteCriticalSection(&g_cs); // 조건 변수는 별도 파괴 불필요
}
```
  
#### 공정성(fairness) 보장 없음 → 깨어난 스레드 순서는 비결정적이므로 항상 `while` 재검사를 해야 한다
* `WakeConditionVariable`은 최소 1개 스레드를, `WakeAllConditionVariable`은 모든 대기 스레드를 깨우지만 **깨어나는 순서와 선택은 비결정적**이다
* **spurious wakeup**(조건 미충족인데 깨어나는 현상) 또는 타임아웃도 발생할 수 있으므로, **항상 조건을 `while` 루프로 재검사**해야 한다
* 조건 변수는 “이벤트 그 자체”가 아니라 “**상태 변화 알림**”일 뿐이므로 **공유 상태(predicate)** 를 반드시 함께 사용해야 한다

올바른 대기/신호 패턴:  

```c
#include <windows.h>
#include <stdbool.h>

CRITICAL_SECTION g_cs;
CONDITION_VARIABLE g_cv;
int g_items = 0; // 공유 상태(예: 큐의 항목 수)

void produce_one(void) {
    EnterCriticalSection(&g_cs);
    ++g_items;                    // 상태 변경
    WakeConditionVariable(&g_cv); // 하나만 깨움(필요에 따라 WakeAll)
    LeaveCriticalSection(&g_cs);
}

void consume_loop(void) {
    EnterCriticalSection(&g_cs);
    while (true) {
        while (g_items == 0) { // 반드시 while로 재검사한다
            if (!SleepConditionVariableCS(&g_cv, &g_cs, INFINITE)) {
                // FALSE면 보통 ERROR_TIMEOUT이지만, 여기서는 INFINITE이므로 도달하지 않는다고 가정한다
            }
        }
        // 여기 도달했으면 g_items > 0이 보장된다
        --g_items;              // 항목 소비
        LeaveCriticalSection(&g_cs);

        // 임계구역 밖에서 실제 처리 작업 수행 ...
        // 처리 후 다시 잠금
        EnterCriticalSection(&g_cs);
    }
    // 통상 종료 경로에서는 외부에서 stop 플래그와 WakeAll로 탈출하게 설계한다
}
```
  
핵심 규칙 요약:  
* **상태를 잠금 하에서 변경**하고, 필요 시 그 자리에서 `Wake…`를 호출한다
* 깨어난 뒤 **반드시 while로 상태를 재확인**한다
* 공정성이 필요하면 별도의 **대기열 큐**나 **세마포어/채널** 같은 상위 레벨 정책을 도입해야 한다
  
#### `WaitForMultipleObjects` 등과 결합한 여러 객체 동시 대기는 불가하며, 조건 변수 전용 대기 API만 사용한다
* 조건 변수 대기 API는 `SleepConditionVariableCS`와 `SleepConditionVariableSRW` 두 가지뿐이다
* 이들은 `WaitForMultipleObjects`/`MsgWaitForMultipleObjects`/alertable wait 등과 **조합할 수 없다**

#### 부가 팁
* 조건 변수는 **`CRITICAL_SECTION`과 `SRWLOCK` 둘 다** 지원한다. 읽기 다중 허용이 필요한 경우 `SRWLOCK` + `SleepConditionVariableSRW`를 고려하면 좋다
* `SleepConditionVariable…`의 반환값이 FALSE일 수 있는 **유일한 정상 상황은 타임아웃**이다. 이때 `GetLastError()==ERROR_TIMEOUT`을 확인하면 된다
* `WakeAllConditionVariable`은 “떼깨우기”라서 다음 락 획득 경쟁이 크게 발생할 수 있다. 많은 스레드가 깨어나야 하는 상황이 아니라면 `WakeConditionVariable`을 우선 고려한다
* “준공정성”이 필요하면 **세마포어(슬롯 수만큼 ReleaseSemaphore)** 나 **작업 큐 + 단일 소비자** 같은 상위 설계를 사용하면 된다
  
   
### 사용 가능한 API 요약

```c
// 초기화
VOID InitializeConditionVariable(PCONDITION_VARIABLE cv);
// 선택적 정적 초기화(지원되는 SDK에서)
CONDITION_VARIABLE cv = CONDITION_VARIABLE_INIT;

// 대기
BOOL SleepConditionVariableCS(PCONDITION_VARIABLE cv, PCRITICAL_SECTION cs, DWORD dwMilliseconds);
BOOL SleepConditionVariableSRW(PCONDITION_VARIABLE cv, PSRWLOCK srw, DWORD dwMilliseconds, ULONG Flags);
// Flags: 0 또는 CONDITION_VARIABLE_LOCKMODE_SHARED (SRW 공유 모드 대기 시)

// 신호
VOID WakeConditionVariable(PCONDITION_VARIABLE cv);    // 1개 스레드 깨움
VOID WakeAllConditionVariable(PCONDITION_VARIABLE cv); // 모든 대기 스레드 깨움
```

* `SleepConditionVariable*`은 **현재 잡고 있는 락을 원자적으로 해제한 뒤 대기**하고, 깨어날 때 **해당 락을 다시 잡은 상태**로 리턴한다.
* 타임아웃은 밀리초 단위다. `INFINITE`로 무한 대기할 수 있다. 타임아웃이면 `FALSE`를 반환하고 `GetLastError()==ERROR_TIMEOUT`이다.
* `SleepConditionVariableSRW`에서 **공유(읽기) 락**으로 기다릴 때는 `Flags`에 `CONDITION_VARIABLE_LOCKMODE_SHARED`를 준다.
  
  
### 반드시 지켜야 할 패턴
항상 다음과 같이 **조건을 while 루프로** 검사한다. 조건 변수는 **허위(wakeup without reason)** 또는 타임아웃으로 깨어날 수 있기 때문이다.

```c
EnterCriticalSection(&cs);
while (!predicate) { // 조건이 충족될 때까지
    SleepConditionVariableCS(&cv, &cs, INFINITE);
}
// ... 조건이 참이므로 안전하게 진행 ...
LeaveCriticalSection(&cs);
```
  

### 신호 보내기 규칙
* 일반적으로 **상태를 변경한 직후, 아직 락을 잡은 상태에서** `WakeConditionVariable` 또는 `WakeAllConditionVariable`을 호출하는 것이 안전하다. 이렇게 하면 상태 변경과 신호 사이의 레이스를 줄일 수 있다.
* 한 번에 한 스레드만 진행하면 되는 경우 `WakeConditionVariable`을, 여러 스레드가 동시에 진행 가능하면 `WakeAllConditionVariable`을 사용한다.  
  

### `CRITICAL_SECTION`과 함께 쓰는 예제 (생산자-소비자)
고정 크기 버퍼를 사용하는 간단한 예제다.

```c
#include <windows.h>

#define N 64

CRITICAL_SECTION cs;
CONDITION_VARIABLE notEmpty;
CONDITION_VARIABLE notFull;

int buf[N], head = 0, tail = 0, count = 0;

void enqueue(int v) {
    EnterCriticalSection(&cs);
    while (count == N) {
        SleepConditionVariableCS(&notFull, &cs, INFINITE);
    }
    buf[tail] = v;
    tail = (tail + 1) % N;
    count++;
    // 상태 변경 후 신호
    WakeConditionVariable(&notEmpty);
    LeaveCriticalSection(&cs);
}

int dequeue(void) {
    EnterCriticalSection(&cs);
    while (count == 0) {
        SleepConditionVariableCS(&notEmpty, &cs, INFINITE);
    }
    int v = buf[head];
    head = (head + 1) % N;
    count--;
    WakeConditionVariable(&notFull);
    LeaveCriticalSection(&cs);
    return v;
}

int main(void) {
    InitializeCriticalSection(&cs);
    InitializeConditionVariable(&notEmpty);
    InitializeConditionVariable(&notFull);
    // 스레드 생성/조인 등 ...
    DeleteCriticalSection(&cs);
    return 0;
}
```

요점은 **버퍼 상태를 나타내는 프레디킷(count==0, count==N)을 while 루프로 재확인**한다는 점이다.
  

### `SRWLOCK`과 함께 쓰는 예제
`SRWLOCK`은 읽기/쓰기(공유/배타) 모드를 지원하는 가벼운 락이다. 공유 모드로 기다릴 때는 `CONDITION_VARIABLE_LOCKMODE_SHARED` 플래그를 사용한다.

```c
SRWLOCK lock = SRWLOCK_INIT;
CONDITION_VARIABLE cv = CONDITION_VARIABLE_INIT;

volatile LONG readyCount = 0;
const LONG target = 10;

void wait_until_ready_shared(void) {
    AcquireSRWLockShared(&lock);
    while (readyCount < target) {
        SleepConditionVariableSRW(&cv, &lock, INFINITE, CONDITION_VARIABLE_LOCKMODE_SHARED);
    }
    // 조건 만족, 공유 락 상태로 안전한 읽기 가능
    ReleaseSRWLockShared(&lock);
}

void make_progress(void) {
    AcquireSRWLockExclusive(&lock);
    readyCount++;                // 상태 변경
    WakeAllConditionVariable(&cv); // 여러 대기자가 진행 가능하므로 브로드캐스트
    ReleaseSRWLockExclusive(&lock);
}
```

주의할 점은 **대기할 때 보유 중인 락 모드와 `Flags`가 일치**해야 한다는 것이다.
  

### 조건 변수 vs. 이벤트/세마포어/뮤텍스
* **이벤트(Event)**: 상태를 자체적으로 기억한다(수동/자동 리셋). `WaitForMultipleObjects`로 여러 핸들을 동시에 기다릴 수 있다. 반면 조건 변수는 **상태를 기억하지 않으며**, **반드시 별도의 프레디킷과 락**이 필요하다.
* **세마포어(Semaphore)**: 남은 리소스 수를 카운팅하는 커널 객체다. 생산자-소비자에 자주 사용되지만, 조건 변수는 **공유 상태(임의 조건)**를 표현하는 데 더 유연하다.
* **뮤텍스(Mutex)**: 프로세스 간 공유 가능하나, 조건 변수는 **프로세스 내부**에서만 사용하고 커널 핸들이 없다. 크로스 프로세스 동기화가 필요하면 이벤트/뮤텍스를 고려한다.
* **성능**: 조건 변수 + 경량 락(`CRITICAL_SECTION`/`SRWLOCK`) 조합은 일반적으로 커널 객체 기반 패턴보다 **적은 오버헤드**를 보인다.
  

### 메모리 가시성과 순서 보장
* Windows의 `CRITICAL_SECTION`과 `SRWLOCK`은 **획득 시 acquire, 해제 시 release** 메모리 장벽을 제공한다.
* 따라서 **“상태 변경은 락 안에서 → 신호 → 대기 스레드는 락을 다시 잡고 상태를 읽음”** 순서로 수행하면 가시성이 보장된다.
  

### 타임아웃과 에러 처리
* `SleepConditionVariable*`이 `FALSE`를 반환하면 `GetLastError()`를 확인한다. 가장 흔한 값은 `ERROR_TIMEOUT`이다.
* 타임아웃이어도 **함수는 락을 다시 잡은 후** 리턴하므로, 리턴 후에는 정상적으로 임계 구역을 빠져나가면 된다.  
  

### 실무에서 자주 겪는 함정과 팁
* **while 대신 if 사용**: 스푸리어스 웨이크업, 브로드캐스트 경합 등으로 즉시 실패한다. **반드시 while**로 재검사한다.
* **신호를 락 밖에서 호출**: 가능하긴 하지만 상태 변경과 신호 사이에 레이스가 생길 수 있다. 기본은 **락 안에서 신호**다.
* **프레디킷 부재**: 조건 변수는 “언제 깨어나야 하는가”를 스스로 모른다. **항상 명시적인 프레디킷(공유 상태)** 을 두고 그 값을 기준으로 while-대기-진행을 구성한다.
* **WakeAll의 남용**: 대기자가 많을 때 `WakeAll`은 **N명 모두를 깨워 락 경합을 유발**한다. 진짜로 여러 스레드가 동시에 진행 가능할 때만 쓴다.
* **객체 수명/이동**: 대기 중인 스레드가 있는 객체 메모리를 이동/해제하면 UB다. 스레드가 모두 빠져나온 뒤 정리한다.
* **다중 조건**: 하나의 락에 여러 조건이 있을 수 있다(예: `notEmpty`, `notFull`). 조건마다 별도의 `CONDITION_VARIABLE`을 두면 **불필요한 깨움**을 줄일 수 있다.

### 요약
* 조건 변수는 **프레디킷 + 락** 조합으로 쓰는 가벼운 동기화 도구다.
* `SleepConditionVariableCS/SRW`로 **원자적으로 락 해제 + 대기 + 재획득**을 제공한다.
* **항상 while 루프**로 조건을 재검사한다.
* 상태 변경은 락 안에서 하고, 상황에 맞게 `Wake`와 `WakeAll`을 선택한다.
* 커널 핸들이 없고 파괴도 필요 없어 비용이 낮으며, 일반적인 스레드 협업 패턴에서 **가독성·성능·안전성**을 동시에 확보할 수 있다.
  
  

### 오류: 신호를 락 밖에서 호출    
문제의 핵심은 **"상태 변경"** 과 **"신호"** 사이에, 그리고 **"대기"** 와 **"락 해제"** 사이에 원자성(Atomicity)이 깨지기 때문이다.

`SleepConditionVariableCS` 함수의 핵심 동작은 다음 두 가지를 **원자적으로** 수행하는 것이다.

1.  넘겨받은 락(`CRITICAL_SECTION`)을 해제한다.
2.  해당 조건 변수(`CONDITION_VARIABLE`)의 대기 큐에 스레드를 등록하고 잠들게 한다.

올바른 방식(락 내부에서 신호)은 이 원자성을 보장하지만, 락 밖에서 신호하면 이 원자성이 깨지는 특정 시나리오가 발생할 수 있다.

#### 문제 발생 가능 코드 예시
아래 코드는 위에서 설명한 "Lost Wakeup" 문제를 재현할 *가능성*이 있는 C++ 코드이다. (경쟁 조건이므로 실행할 때마다 발생하지 않고, 시스템 부하 등에 따라 간헐적으로 발생하거나 발생하지 않을 수 있다.)

`ProducerThread` 함수에서 락 밖에서 `WakeConditionVariable`를 호출하는 부분을 주목하자.

```cpp
#include <windows.h>
#include <process.h> // for _beginthreadex
#include <stdio.h>

// 전역 변수 (공유 자원)
CRITICAL_SECTION    g_lock;
CONDITION_VARIABLE  g_cv;
bool                g_data_ready = false;

// 소비자 스레드 (Waiter)
unsigned int __stdcall ConsumerThread(void* param) {
    printf("Consumer: 스레드 시작, 락 대기...\n");
    EnterCriticalSection(&g_lock);
    printf("Consumer: 락 획득. 데이터 확인...\n");

    while (!g_data_ready) {
        printf("Consumer: 데이터 없음. SleepConditionVariableCS 진입 (대기 시작)...\n");
        // 1. 락을 원자적으로 해제하고 잠들기 시작
        SleepConditionVariableCS(&g_cv, &g_lock, INFINITE);
        // 2. 깨어나면 락을 다시 획득한 상태로 리턴됨
        printf("Consumer: 깨어남 (Woke up)! 락 다시 획득.\n");
    }

    // 데이터 처리
    printf("Consumer: ***** 데이터 처리 중 *****\n");
    g_data_ready = false; // 데이터 처리 완료

    LeaveCriticalSection(&g_lock);
    printf("Consumer: 락 해제. 스레드 종료.\n");
    return 0;
}

// 생산자 스레드 (Signaler) - 문제가 있는 방식
unsigned int __stdcall ProducerThread_Problem(void* param) {
    printf("Producer: 스레드 시작, 락 대기...\n");
    EnterCriticalSection(&g_lock);
    
    // 1. 상태 변경
    g_data_ready = true;
    printf("Producer: 데이터 준비 완료 (g_data_ready = true)\n");

    // 2. 락 해제
    LeaveCriticalSection(&g_lock);
    printf("Producer: 락 해제.\n");

    // 3. 신호 (*** 문제의 지점: 락 바깥 ***)
    // Consumer가 락을 놓고 대기 큐에 등록되기 전에
    // 이 Wake가 호출되면 신호가 유실됨!
    printf("Producer: 락 밖에서 신호 보냄 (WakeConditionVariable)...\n");
    WakeConditionVariable(&g_cv);

    printf("Producer: 스레드 종료.\n");
    return 0;
}

int main() {
    InitializeCriticalSection(&g_lock);
    InitializeConditionVariable(&g_cv);

    HANDLE hConsumer, hProducer;

    // 1. Consumer 스레드를 먼저 시작시킵니다.
    hConsumer = (HANDLE)_beginthreadex(NULL, 0, ConsumerThread, NULL, 0, NULL);
    
    // Consumer가 먼저 실행되어 대기 상태에 들어갈 시간을 줍니다.
    Sleep(100); 

    // 2. Producer 스레드를 시작합니다. (문제가 있는 버전)
    hProducer = (HANDLE)_beginthreadex(NULL, 0, ProducerThread_Problem, NULL, 0, NULL);

    // 스레드 종료 대기
    WaitForSingleObject(hConsumer, INFINITE);
    WaitForSingleObject(hProducer, INFINITE);

    CloseHandle(hConsumer);
    CloseHandle(hProducer);
    DeleteCriticalSection(&g_lock);

    printf("Main: 모든 스레드 종료. 프로그램 종료.\n");
    return 0;
}
```

**실행 시 문제 상황 (데드락):**
위 코드를 실행하면, 때때로 Consumer가 `Consumer: 데이터 없음. SleepConditionVariableCS 진입 (대기 시작)...` 메시지를 출력한 후, Producer가 신호를 보냈음에도 불구하고 Consumer가 깨어나지 못하고 **프로그램이 멈추는(데드락) 현상**을 관찰할 수 있다.

#### 올바른 해결 방법
해결책은 간단하다. **상태 변경** 과 **신호(Wake)**를 모두 락 안에서 수행하여, 이 두 작업이 다른 스레드의 락 획득/해제와 섞이지 않도록 보장하는 것이다.

`ProducerThread` 함수를 다음과 같이 수정해야 한다.

```cpp
// 생산자 스레드 (Signaler) - 올바른 방식
unsigned int __stdcall ProducerThread_Correct(void* param) {
    printf("Producer: 스레드 시작, 락 대기...\n");
    EnterCriticalSection(&g_lock);
    
    // 1. 상태 변경
    g_data_ready = true;
    printf("Producer: 데이터 준비 완료 (g_data_ready = true)\n");

    // 2. 신호 (*** 올바른 위치: 락 내부 ***)
    printf("Producer: 락 안에서 신호 보냄 (WakeConditionVariable)...\n");
    WakeConditionVariable(&g_cv);

    // 3. 락 해제
    LeaveCriticalSection(&g_lock);
    printf("Producer: 락 해제.\n");
    
    printf("Producer: 스레드 종료.\n");
    return 0;
}
```

#### 🛡️ 올바른 방식이 동작하는 이유
1.  **Thread B (Signaler):** 락을 획득하고 상태를 변경(`g_data_ready = true`)한다.
2.  **Thread B (Signaler):** **락을 보유한 상태로** `WakeConditionVariable`을 호출한다.
3.  **이때 Thread A (Waiter)의 상태는 둘 중 하나이다.**
      * **Case 1: 아직 `SleepConditionVariableCS`를 호출하기 전 (락을 기다리는 중):**
          * Thread A는 Thread B가 락을 해제할 때까지 기다린다. B가 락을 해제하면, A는 락을 획득하고 `while (!g_data_ready)` 조건을 검사한다. 이미 `true`이므로 `SleepConditionVariableCS`를 호출하지 않고 바로 데이터 처리를 시작한다.
      * **Case 2: 이미 `SleepConditionVariableCS`에 진입하여 잠들어 있는(대기 큐에 등록된) 상태:**
          * Thread B의 `WakeConditionVariable` 호출이 Thread A를 깨운다.
          * 깨어난 Thread A는 `SleepConditionVariableCS` 함수 내부에서 (B가 락을 해제한 뒤) 락을 다시 획득하려고 시도한다.
          * Thread B가 `LeaveCriticalSection`으로 락을 해제하면, Thread A가 락을 획득하고 `SleepConditionVariableCS`에서 리턴되어 `while` 조건을 다시 검사하고 데이터 처리를 시작한다.

두 경우 모두 **"Lost Wakeup" 없이** 안전하게 동작한다.   

위 설명이 이해가 안 가는 경우를 위해서 비유를 통해 설명하겠다.  

### 😵 문제를 "사무실과 휴게실" 비유로 설명
* **사무실 열쇠 (The Lock 🔑):** `CRITICAL_SECTION`
* **사무실 (Shared Data):** `is_data_ready` 변수
* **휴게실 (CV Wait Queue 😴):** `CONDITION_VARIABLE` (잠자는 곳)
* **인터콤 (The Signal 📣):** `WakeConditionVariable` (방송)


#### 💀 문제 발생 비유: 열쇠 반납 후 인터콤 방송 (Deadlock)
**전제:** B(Signaler)가 A(Waiter)를 깨우려 한다. A는 일이 없어서 휴게실 가서 자려고 한다.

**1. A (Waiter), 일 확인 (T1-T2)**
* A가 **사무실 열쇠(락) 🔑**를 가지고 사무실에 들어간니다.
* "일거리(`is_data_ready`)가 없네... 휴게실 가서 자야겠다."

**2. A (Waiter), 휴게실로 이동 시작 (T3-T4)**
* A가 휴게실에서 자기로 결정하고, `SleepConditionVariableCS`를 호출한다.
* A는 **사무실 열쇠(락) 🔑를 먼저 반납한다.** (`Sleep...` 함수는 락부터 푼다.)

**3. 🚨 치명적인 틈 (T5)**
* **바로 이 순간이다!**
* A는 열쇠 🔑를 반납했지만, **아직 휴게실 😴에 도착해서 잠든 상태(대기 큐 등록)가 아니다.**
* (비유: A는 사무실에서 휴게실로 *걸어가는 복도*에 있다.)

**4. B (Signaler), 사무실 입장 (T5-T6)**
* B가 마침 사무실에 가려는데, **열쇠 🔑가 반납되어 있다!** (A가 방금 반납했죠.)
* B가 열쇠(락)를 획득하고 사무실에 들어가 일거리(`is_data_ready = true`)를 준비한다.

**5. B (Signaler), 열쇠 반납 (T7)**
* B가 일을 다 끝내고 사무실에서 나온다.
* B가 **사무실 열쇠(락) 🔑를 반납한다.** (`LeaveCriticalSection`)

**6. B (Signaler), 락 밖에서 인터콤 방송 (T8-T9)**
* B가 **사무실 밖 복도에서 (락을 푼 상태로)** 휴게실을 향해 **인터콤 📣** 버튼을 누른다.
* "A씨, 일 준비됐으니 일어나세요!"

**7. 😱 신호 유실 (T10)**
* 인터콤 시스템(OS)은 **휴게실(대기 큐) 😴**만 확인한다.
* "휴게실에 아무도 없는데요?"
* (당연하죠. A는 아직 휴게실로 *걸어가는 중*(T3)이었다.)
* 시스템은 **인터콤 방송(신호)을 그냥 꺼버린다.** (신호 유실!)

**8. B (Signaler), 퇴근 (T11)**
* B는 "할 일 다 했다. 방송도 했으니 A가 듣고 나오겠지"라고 생각하고 퇴근한다.

**9. A (Waiter), 뒤늦은 취침 (T12-T14)**
* 복도를 터벅터벅 걸어오던 A가 **드디어 휴게실 😴에 도착한다.**
* A는 휴게실 대기 명단에 자기 이름을 적고(대기 큐 등록) **잠이 든다.**
* A는 B가 이미 하고 가버린 인터콤 방송(신호)을 영원히 기다린다...

#### 🥶 결과: 데드락
* **A:** 일거리가 준비되었음에도 불구하고, 이미 놓쳐버린 인터콤 방송을 기다리며 휴게실에서 영원히 잠들어 있다.
* **B:** 자기는 할 일을 다 했다고 생각하고 가버렸다.

이 비유에서 **"사무실 열쇠를 반납하는 순간(T4)"**과 **"휴게실에 도착해 잠드는 순간(T13)"** 사이의 **"복도(T5~T12)"**가 바로 **경쟁 조건(Race Window)**이며, "신호 유실"이 발생하는 치명적인 틈이다.
  
  
### 😀 해결을 "사무실과 휴게실" 비유로 설명
* **사무실 열쇠 (The Lock 🔑):** `CRITICAL_SECTION`
* **사무실 (Shared Data):** `is_data_ready` 변수
* **휴게실 (CV Wait Queue 😴):** `CONDITION_VARIABLE` (잠자는 곳)
* **인터콤 (The Signal 📣):** `WakeConditionVariable` (방송)

#### ✅ 올바른 비유: 열쇠 반납 전, 사무실 안에서 인터콤 방송
이 방식이 안전한 이유는, **사무실 열쇠(락) 🔑**가 A(Waiter)를 "복도(틈새)"에 어중간하게 서 있지 못하게 만들기 때문이다.

B(Signaler)가 **열쇠 🔑를 쥔 채** 사무실 안에서 인터콤을 누를 때, A의 상태는 다음 **둘 중 하나로 강제된다.**

1.  A가 이미 **휴게실 😴**에서 자고 있다.
2.  A가 **사무실 문 밖 🔒**에서 열쇠를 기다리고 있다.

어느 쪽이든 문제가 생기지 않는다.


### 🎯 핵심 요약
**"락 밖에서 방송(신호)"** 방식은, A가 "사무실 열쇠 🔑를 반납"하고 "휴게실 😴에 눕는" 사이의 **"복도"**라는 틈새에 B의 방송이 끼어들면 문제가 생긴다.

**"락 안에서 방송(신호)"** 방식은, B가 **열쇠 🔑를 쥐고** 방송하기 때문에, A는 절대로 "복도"에 있을 수 없다. A는 **"이미 휴게실에서 자고 있거나"** (시나리오 1) 또는 **"사무실 문 밖에서 줄 서 있거나"** (시나리오 2) 둘 중 하나이다.

두 시나리오 모두 A가 영원히 잠드는 데드락을 완벽하게 방지한다.  
  


### 예제: 단일 슬롯 메일박스: 생산자/소비자
**언제 쓰면 좋은가**: 짧은 임계 구역에서 **데이터가 “생길 때까지 기다렸다가(consumers wait)”** 이어서 처리하는 패턴에 적합하다. 큐가 비었으면 소비자가 잠들고, 생산자가 넣으면 깨워서 처리한다.

```c
#define _WIN32_WINNT 0x0600
#include <windows.h>
#include <stdio.h>

CRITICAL_SECTION g_cs;
CONDITION_VARIABLE g_not_empty, g_not_full;
int  g_mailbox = 0;
BOOL g_has_item = FALSE;

DWORD WINAPI Producer(LPVOID) {
    for (int v = 1; v <= 5; ++v) {
        EnterCriticalSection(&g_cs);
            while (g_has_item) { // 꽉 차 있으면 '비어짐'을 기다림
                SleepConditionVariableCS(&g_not_full, &g_cs, INFINITE);
            }
            g_mailbox = v;
            g_has_item = TRUE;
            printf("Produce %d\n", v);
            WakeConditionVariable(&g_not_empty); // 소비자 하나 깨움
        LeaveCriticalSection(&g_cs);
        Sleep(100); // 작업 흉내
    }
    return 0;
}

DWORD WINAPI Consumer(LPVOID) {
    for (int i = 0; i < 5; ++i) {
        EnterCriticalSection(&g_cs);
            while (!g_has_item) { // 비어 있으면 '채워짐'을 기다림
                SleepConditionVariableCS(&g_not_empty, &g_cs, INFINITE);
            }
            int v = g_mailbox;
            g_has_item = FALSE;
            printf("Consume %d\n", v);
            WakeConditionVariable(&g_not_full); // 생산자 하나 깨움
        LeaveCriticalSection(&g_cs);
        Sleep(80);
    }
    return 0;
}

int main() {
    InitializeCriticalSection(&g_cs);
    InitializeConditionVariable(&g_not_empty);
    InitializeConditionVariable(&g_not_full);

    HANDLE th[2];
    th[0] = CreateThread(NULL, 0, Producer, NULL, 0, NULL);
    th[1] = CreateThread(NULL, 0, Consumer, NULL, 0, NULL);

    WaitForMultipleObjects(2, th, TRUE, INFINITE);
    DeleteCriticalSection(&g_cs);
    CloseHandle(th[0]); CloseHandle(th[1]);
    return 0;
}
```

포인트: **항상 `while`로 조건을 재검사**해야 한다. `WakeConditionVariable`은 공정성을 보장하지 않으므로 스레드가 깨어나도 조건이 여전히 거짓일 수 있다.
  
  
### 예제: 시작 배리어(Start Gate) + 브로드캐스트
**언제 쓰면 좋은가**: 여러 작업자 스레드를 띄운 뒤, **모두 준비될 때까지 메인 스레드가 기다렸다가 한꺼번에 시작 신호를 보내는** 상황에 적합하다. `WakeAllConditionVariable`로 브로드캐스트한다.

```c
#define _WIN32_WINNT 0x0600
#include <windows.h>
#include <stdio.h>

CRITICAL_SECTION g_cs;
CONDITION_VARIABLE g_all_ready_cv, g_go_cv;
int  g_ready_count = 0;
BOOL g_go = FALSE;
const int kWorkerCount = 3;

DWORD WINAPI Worker(LPVOID param) {
    int id = (int)(SIZE_T)param;

    // 준비 완료를 알림
    EnterCriticalSection(&g_cs);
        ++g_ready_count;
        WakeConditionVariable(&g_all_ready_cv); // 메인에게 "한 명 준비됨" 알림

        // 시작 신호를 기다림
        while (!g_go) {
            SleepConditionVariableCS(&g_go_cv, &g_cs, INFINITE);
        }
    LeaveCriticalSection(&g_cs);

    // 실제 작업
    printf("Worker %d start\n", id);
    Sleep(100 + id * 50);
    printf("Worker %d done\n", id);
    return 0;
}

int main() {
    InitializeCriticalSection(&g_cs);
    InitializeConditionVariable(&g_all_ready_cv);
    InitializeConditionVariable(&g_go_cv);

    HANDLE th[kWorkerCount];
    for (int i = 0; i < kWorkerCount; ++i) {
        th[i] = CreateThread(NULL, 0, Worker, (LPVOID)(SIZE_T)i, 0, NULL);
    }

    // 모든 작업자가 준비될 때까지 대기
    EnterCriticalSection(&g_cs);
        while (g_ready_count < kWorkerCount) {
            SleepConditionVariableCS(&g_all_ready_cv, &g_cs, INFINITE);
        }
        // 일괄 시작
        g_go = TRUE;
        WakeAllConditionVariable(&g_go_cv);
    LeaveCriticalSection(&g_cs);

    WaitForMultipleObjects(kWorkerCount, th, TRUE, INFINITE);
    for (int i = 0; i < kWorkerCount; ++i) CloseHandle(th[i]);
    DeleteCriticalSection(&g_cs);
    return 0;
}
```

포인트: **브로드캐스트(`WakeAll`)**로 한 번에 깨우되, 각 스레드는 `while (!g_go)`로 재확인한다.

    

### 예제: SRW 락과 함께 쓰는 “데이터 준비 알림”
**언제 쓰면 좋은가**: 여러 리더(읽기)가 **데이터 준비 완료**를 기다렸다가 동시에 읽도록 하고, 라이터(쓰기)는 데이터를 준비해 **한 번에 알리는** 상황에 적합하다. `SRWLOCK`과 `SleepConditionVariableSRW`를 사용한다.  

```c
#define _WIN32_WINNT 0x0600
#include <windows.h>
#include <stdio.h>

SRWLOCK            g_lock      = SRWLOCK_INIT;
CONDITION_VARIABLE g_cv        = CONDITION_VARIABLE_INIT;
BOOL               g_ready     = FALSE;
int                g_shared    = 0;

DWORD WINAPI Reader(LPVOID param) {
    int id = (int)(SIZE_T)param;

    AcquireSRWLockShared(&g_lock);
        while (!g_ready) {
            // 공유(읽기) 모드로 기다리므로 SHARED 플래그를 준다
            SleepConditionVariableSRW(&g_cv, &g_lock, INFINITE, CONDITION_VARIABLE_LOCKMODE_SHARED);
        }
        // g_ready == TRUE인 상태로 공유 데이터 읽기
        printf("Reader %d sees %d\n", id, g_shared);
    ReleaseSRWLockShared(&g_lock);
    return 0;
}

DWORD WINAPI Writer(LPVOID) {
    Sleep(200); // 준비 시간 흉내
    AcquireSRWLockExclusive(&g_lock);
        g_shared = 42;   // 데이터 작성
        g_ready  = TRUE; // 상태 갱신
        WakeAllConditionVariable(&g_cv); // 모든 리더 깨움
    ReleaseSRWLockExclusive(&g_lock);
    return 0;
}

int main() {
    HANDLE r1 = CreateThread(NULL, 0, Reader, (LPVOID)1, 0, NULL);
    HANDLE r2 = CreateThread(NULL, 0, Reader, (LPVOID)2, 0, NULL);
    HANDLE w  = CreateThread(NULL, 0, Writer, NULL, 0, NULL);

    HANDLE th[3] = { r1, r2, w };
    WaitForMultipleObjects(3, th, TRUE, INFINITE);
    for (int i = 0; i < 3; ++i) CloseHandle(th[i]);
    return 0;
}
```
  
포인트: **읽기 대기는 `CONDITION_VARIABLE_LOCKMODE_SHARED`**를 주고, **쓰기 대기는 플래그 0**을 준다. 조건 변수는 **상태 변화 알림**이므로 `g_ready` 같은 **프레디킷(공유 상태)**을 반드시 `while`로 재검사한다.
 
   
  
## Windows 스레드 풀 API

### 스레드 풀의 개념과 장점
스레드 풀은 미리 생성된 스레드들의 집합으로, 작업이 들어오면 유휴 스레드를 할당하여 처리하는 메커니즘이다.

```
    [Thread Pool Architecture]
    
    작업 큐 (Work Queue)
    ┌─────┬─────┬─────┬─────┐
    │Task1│Task2│Task3│Task4│ ...
    └─────┴─────┴─────┴─────┘
           ↓     ↓     ↓
    ┌──────────────────────┐
    │    Thread Pool       │
    │  ┌──┐ ┌──┐ ┌──┐ ┌──┐ │
    │  │T1│ │T2│ │T3│ │T4│ │  Worker Threads
    │  └──┘ └──┘ └──┘ └──┘ │
    └──────────────────────┘
    
    장점:
    1. 스레드 생성/소멸 오버헤드 감소
    2. 리소스 사용량 제한
    3. 작업 큐잉 및 스케줄링 자동화
    4. 시스템 과부하 방지
```
  

### QueueUserWorkItem 함수란?
`QueueUserWorkItem`은 **"이 함수 좀 대신 실행해줘"** 라고 **Windows 시스템의 스레드 풀(Thread Pool)에 작업을 요청**하는 함수이다.  
  
개발자가 직접 스레드를 만들고 관리하는 복잡함 없이, 간단하게 비동기 작업을 처리할 수 있게 해주는 매우 유용한 API이다. 스레드 풀은 시스템이 알아서 관리하는 작업자(Worker) 스레드들의 모음이며, `QueueUserWorkItem`으로 작업을 던져주면 알아서 쉬고 있는 스레드를 배정해 함수를 실행시켜 준다.

#### 함수 시그니처 (Function Signature)

```cpp
BOOL QueueUserWorkItem(
  LPWORK_START_ROUTINE Function,
  PVOID                Context,
  ULONG                Flags
);
```

이 함수는 3개의 인자를 받고, 성공 여부를 `BOOL` 타입으로 반환한다.

##### 1. Function (LPWORK_START_ROUTINE)
  - **설명**: 스레드 풀의 작업자 스레드가 **실행할 함수의 포인터**이다. 즉, "어떤 함수를 실행할지"를 지정한다.
  - **타입**: `LPWORK_START_ROUTINE`은 `DWORD WINAPI FunctionName(LPVOID lpThreadParameter)` 형태의 함수 포인터를 의미한다.  
      - `DWORD WINAPI`: 함수의 반환 타입과 호출 규약이다. 약속된 형식이므로 그대로 따라야 한다.  
      - `LPVOID lpThreadParameter`: 함수가 받을 인자이다. `void` 포인터 형태이므로 어떤 종류의 데이터든 전달할 수 있다.  
  
##### 2, Context (PVOID)
  - **설명**: 위에서 지정한 `Function`에 **전달할 데이터(인자)** 이다. 보통 스레드가 작업을 수행하는 데 필요한 정보들을 담은 구조체나 클래스의 포인터를 전달한다.
  - **타입**: `PVOID`는 `void*`와 같다. 즉, **어떤 타입의 포인터든** 전달할 수 있다. 스레드 함수 내부에서 이 `Context`를 실제 데이터 타입으로 형변환(`casting`)하여 사용하게 된다. 만약 전달할 데이터가 없다면 `NULL`을 넘겨주면 된다.
 
##### 3. Flags (ULONG)
  - **설명**: 작업의 실행 방식을 제어하는 **옵션** 이다.
  - **주요 값**:
      - `WT_EXECUTEDEFAULT`: **기본값** 이다. 스레드 풀의 일반적인 작업 큐에 작업을 넣는다. 대부분의 경우 이 옵션을 사용한다.
      - `WT_EXECUTEINPERSISTENTTHREAD`: **지속적인(persistent) 스레드**에서 작업을 실행한다. 이 스레드는 한 번 생성되면 종료되지 않고 계속해서 작업을 기다리므로, 자주 발생하는 작은 작업을 처리할 때 유리할 수 있다. 잘못 사용하면 스레드가 계속 살아있어 리소스를 낭비할 수 있다.
      - `WT_EXECUTELONGFUNCTION`: **오래 걸리는 작업**임을 시스템에 알립니다. 스레드 풀은 이 힌트를 보고 스레드가 오랫동안 점유될 것을 예상하여, 필요하다면 새 스레드를 생성하여 다른 작업들이 지연되는 것을 막을 수 있다. 파일 I/O나 네트워크 통신처럼 작업 완료를 오래 기다려야 하는 경우 사용하면 좋다.
  
##### 반환 값 (Return Value)
  - **`TRUE` (0이 아닌 값)**: 함수 호출에 성공하여 작업이 스레드 풀 큐에 성공적으로 등록되었음을 의미한다.
  - **`FALSE` (0)**: 작업 등록에 실패했음을 의미한다. 실패 원인은 `GetLastError()` 함수를 호출하여 확인할 수 있다. (예: 스레드 풀이 너무 바쁘거나 리소스 부족)
  

##### 간단한 사용 예시

```cpp
#include <windows.h>
#include <iostream>

// 1. 스레드가 실행할 함수 정의
DWORD WINAPI MyWorkFunction(LPVOID lpParameter) {
    // 2. Context를 원래 데이터 타입으로 형변환
    int* data = static_cast<int*>(lpParameter);

    std::cout << "작업자 스레드(ID: " << GetCurrentThreadId() << ")가 실행되었습니다." << std::endl;
    std::cout << "전달받은 데이터: " << *data << std::endl;

    // 전달받은 데이터 메모리 해제
    delete data;
    return 0;
}

int main() {
    // 3. 스레드에 전달할 데이터 준비
    int* myData = new int(123);

    std::cout << "메인 스레드: 스레드 풀에 작업을 요청합니다." << std::endl;

    // 4. QueueUserWorkItem 호출
    if (QueueUserWorkItem(MyWorkFunction, myData, WT_EXECUTEDEFAULT)) {
        std::cout << "메인 스레드: 작업 요청 성공!" << std::endl;
    } else {
        std::cerr << "메인 스레드: 작업 요청 실패. 에러 코드: " << GetLastError() << std::endl;
    }

    // 작업이 끝나는 것을 기다리기 위해 잠시 대기 (실제로는 Event 등 동기화 객체 사용)
    Sleep(1000); 

    std::cout << "메인 스레드: 프로그램 종료." << std::endl;
    return 0;
}
```
    
  
## 스레드 풀 2.0
`QueueUserWorkItem` API는 사용하기는 간단했지만 기능이 너무 제한적이었다. 여러 종류의 비동기 작업(타이머, I/O 완료, 커널 객체 대기)을 처리하려면 각기 다른 API를 섞어서 써야 했고, 스레드 개수를 세밀하게 조절하기도 어려웠다.

Windows Vista부터 도입된 새로운 스레드 풀 API(TP API)는 이런 문제를 해결하기 위해 만들어졌다. 서버 애플리케이션과 복잡한 프로그램을 안정적으로 만들 수 있도록.

### 새로운 API의 핵심 장점 4가지
**1. 통합된 비동기 처리**
모든 비동기 작업(단순 작업, 타이머, 커널 객체 대기, I/O 완료)을 일관된 방식으로 처리할 수 있다. 더 이상 여러 API를 섞어서 쓸 필요가 없다.

**2. 똑똑한 성능 관리**
시스템 부하에 따라 스레드 수를 자동으로 조절하며, 특히 짧은 작업이 많을 때 최적화한다.

**3. 세밀한 제어**
각 스레드 풀마다 최소/최대 스레드 수를 직접 설정할 수 있어서 리소스를 효율적으로 관리할 수 있다.

**4. 안전한 정리(정리 그룹 개념)**
여러 작업이 모두 끝날 때까지 안전하게 기다렸다가 관련 리소스를 한 번에 정리하는 과정이 간단명료하다. 이는 복잡한 애플리케이션에서 발생하는 미묘한 버그를 크게 줄여준다.
  

### 기초 개념: 스레드 풀은 '작업자 팀'이다
스레드 풀을 이해하는 가장 쉬운 방법은 "일하는 작업자들의 팀"이라고 생각하는 것이다.

- `CreateThreadpool(NULL)` = 작업자 팀을 고용한다
- `TP_CALLBACK_ENVIRON` = 작업자들이 따를 규칙서를 만든다
- 작업을 제출합니다 = "이 일을 팀에게 맡긴다"
- 작업이 끝날 때까지 기다린다 = "일이 다 끝났나요?"
- `CloseThreadpool()` = 작업자 팀을 해산한다


### 주요 API 상세 설명

#### CreateThreadpool - 작업자 팀 고용하기

```cpp
PTP_POOL pool = CreateThreadpool(NULL);
```

이 함수는 Windows가 백그라운드에서 여러 스레드를 미리 생성하고 관리하는 공간을 만든다. 반환되는 `PTP_POOL`은 이 팀을 가리키는 '관리자 핸들'이다. `NULL`이 반환되면 생성 실패이다.

#### TP_CALLBACK_ENVIRON - 규칙서 만들기
스레드 풀을 사용할 때는 세 단계를 거쳐 규칙서를 만든다:

```cpp
TP_CALLBACK_ENVIRON cbe;              // 1. 빈 규칙서 구조체
InitializeThreadpoolEnvironment(&cbe); // 2. 규칙서 초기화
SetThreadpoolCallbackPool(&cbe, pool); // 3. 어떤 팀을 쓸지 지정
```

이 과정을 거친 규칙서 `cbe`를 사용하는 모든 작업은 `pool`이라는 팀에 할당된다.

### WaitForThreadpoolWorkCallbacks - 작업이 끝날 때까지 기다리기

```cpp
WaitForThreadpoolWorkCallbacks(work, FALSE);
```

메인 스레드가 이 함수를 만나면, 지정된 작업을 처리하는 스레드가 일을 마칠 때까지 그 자리에서 멈춘다. 이는 작업 완료를 확인하고 다음 단계를 진행하는 동기화 기능이다.

두 번째 인자가 `FALSE`면 현재 실행 중인 작업이 끝날 때까지만 기다리고, `TRUE`면 대기 중인 작업들을 취소한다. 보통 `FALSE`를 사용한다.

#### CloseThreadpoolWork, CloseThreadpool - 정리하기

```cpp
CloseThreadpoolWork(work);  // 작업 객체 삭제
CloseThreadpool(pool);      // 전체 팀 해산
```

작업이 끝났으면 작업 객체를, 모든 일이 끝났으면 스레드 풀 자체를 정리한다.


### 4가지 작업 유형

#### 1️⃣ 기본 작업 (Work Item) - 가장 간단한 비동기 작업
일반적인 함수를 스레드 풀에서 실행하고 싶을 때 사용한다.

**사용 흐름:**
```cpp
PTP_WORK work = CreateThreadpoolWork(콜백함수, 데이터, 규칙서);
SubmitThreadpoolWork(work);  // 작업 제출
WaitForThreadpoolWorkCallbacks(work, FALSE);  // 완료 대기
CloseThreadpoolWork(work);  // 정리
```

**간단한 예:**
```cpp
VOID CALLBACK MyWorkCallback(PTP_CALLBACK_INSTANCE Instance, PVOID Context, PTP_WORK Work) {
    int* data = (int*)Context;
    printf("스레드 %d에서 실행, 데이터: %d\n", GetCurrentThreadId(), *data);
}

int main() {
    PTP_POOL pool = CreateThreadpool(NULL);
    TP_CALLBACK_ENVIRON cbe;
    InitializeThreadpoolEnvironment(&cbe);
    SetThreadpoolCallbackPool(&cbe, pool);

    int myData = 100;
    PTP_WORK work = CreateThreadpoolWork(MyWorkCallback, &myData, &cbe);
    
    SubmitThreadpoolWork(work);
    WaitForThreadpoolWorkCallbacks(work, FALSE);
    
    CloseThreadpoolWork(work);
    CloseThreadpool(pool);
    return 0;
}
```

#### 2️⃣ 타이머 작업 (Timer) - 일정 시간 후 또는 반복 실행
특정 시간이 지난 후, 또는 주기적으로 함수를 실행한다.

**사용 흐름:**
```cpp
PTP_TIMER timer = CreateThreadpoolTimer(타이머콜백, 데이터, 규칙서);
SetThreadpoolTimer(timer, 시작시간, 반복주기, 허용오차);  // 타이머 설정
Sleep(원하는시간);  // 타이머 실행 대기
SetThreadpoolTimer(timer, NULL, 0, 0);  // 타이머 중지
WaitForThreadpoolTimerCallbacks(timer, TRUE);
CloseThreadpoolTimer(timer);
```

**간단한 예:**
```cpp
int count = 0;

VOID CALLBACK MyTimerCallback(PTP_CALLBACK_INSTANCE Instance, PVOID Context, PTP_TIMER Timer) {
    int* counter = (int*)Context;
    (*counter)++;
    printf("타이머 실행 %d번, 스레드 %d\n", *counter, GetCurrentThreadId());
}

int main() {
    PTP_POOL pool = CreateThreadpool(NULL);
    TP_CALLBACK_ENVIRON cbe;
    InitializeThreadpoolEnvironment(&cbe);
    SetThreadpoolCallbackPool(&cbe, pool);

    PTP_TIMER timer = CreateThreadpoolTimer(MyTimerCallback, &count, &cbe);
    
    // 1초 후 시작, 500ms마다 반복
    ULARGE_INTEGER dueTime;
    dueTime.QuadPart = -10000000LL;  // 1초 (음수 = 상대시간)
    FILETIME ft = {dueTime.LowPart, dueTime.HighPart};
    
    SetThreadpoolTimer(timer, &ft, 500, 0);
    Sleep(2100);  // 2.1초 동안 실행
    
    SetThreadpoolTimer(timer, NULL, 0, 0);  // 중지
    WaitForThreadpoolTimerCallbacks(timer, TRUE);
    CloseThreadpoolTimer(timer);
    CloseThreadpool(pool);
    return 0;
}
```

#### 3️⃣ 대기 작업 (Wait) - 커널 객체가 신호될 때 실행
Event나 Mutex 같은 커널 객체가 신호 상태가 되면 콜백을 실행한다.

**사용 흐름:**
```cpp
PTP_WAIT wait = CreateThreadpoolWait(대기콜백, 데이터, 규칙서);
SetThreadpoolWait(wait, 대기할핸들, 타임아웃);  // 어떤 객체를 대기할지 지정
Sleep(원하는시간);
WaitForThreadpoolWaitCallbacks(wait, TRUE);
CloseThreadpoolWait(wait);
```

**간단한 예:**
```cpp
VOID CALLBACK MyWaitCallback(PTP_CALLBACK_INSTANCE Instance, PVOID Context, PTP_WAIT Wait, TP_WAIT_RESULT WaitResult) {
    printf("Event 신호됨! 스레드 %d에서 콜백 실행\n", GetCurrentThreadId());
}

int main() {
    PTP_POOL pool = CreateThreadpool(NULL);
    TP_CALLBACK_ENVIRON cbe;
    InitializeThreadpoolEnvironment(&cbe);
    SetThreadpoolCallbackPool(&cbe, pool);

    HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    PTP_WAIT wait = CreateThreadpoolWait(MyWaitCallback, NULL, &cbe);
    
    SetThreadpoolWait(wait, hEvent, NULL);  // hEvent를 대기
    
    Sleep(1000);
    printf("메인: Event를 신호 상태로 만들기\n");
    SetEvent(hEvent);  // Event 신호 - 콜백 실행됨
    
    Sleep(500);
    WaitForThreadpoolWaitCallbacks(wait, TRUE);
    CloseThreadpoolWait(wait);
    CloseHandle(hEvent);
    CloseThreadpool(pool);
    return 0;
}
```

#### 4️⃣ 비동기 I/O 작업 (Async I/O) - 파일 읽기/쓰기 완료 시 실행
파일을 비동기 모드로 열고, I/O 작업이 완료되면 콜백을 실행한다.

**핵심 개념:**
- 파일을 `FILE_FLAG_OVERLAPPED` 플래그로 열어야 한다
- I/O 작업을 시작하기 전 `StartThreadpoolIo()`를 호출한다
- `ReadFile` 같은 비동기 함수를 호출하면 즉시 반환된다
- I/O가 완료되면 스레드 풀이 콜백을 자동으로 실행한다
  
**사용 흐름:**
```cpp
// 1. 비동기 모드로 파일 열기
HANDLE file = CreateFile(경로, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);

// 2. I/O 객체 생성
PTP_IO ioObject = CreateThreadpoolIo(file, I/O콜백, 데이터, 규칙서);

// 3. I/O 모니터링 시작
StartThreadpoolIo(ioObject);

// 4. 비동기 I/O 작업 시작 (OVERLAPPED 구조체와 함께)
ReadFile(file, 버퍼, 크기, NULL, &overlapped);

Sleep(적당한시간);  // I/O 완료 대기

// 5. 정리
CloseThreadpoolIo(ioObject);
CloseHandle(file);
```

**비동기 I/O의 중요한 특징:**  
비동기 I/O 호출은 "잠깐만, 지금 작업 중이야"라는 `ERROR_IO_PENDING` 에러를 반환한다. 이것은 실제 에러가 아니라 정상 상태이다. 진짜 에러는 다른 에러 코드가 반환될 때이다.

**완전한 예제:**  
파일에 "Hello, Async I/O!"라고 쓴 다음, 비동기로 읽어서 화면에 출력하는 예제이다:

```cpp
#include <windows.h>
#include <iostream>
#include <cstring>

// I/O에 필요한 정보를 담는 구조체
struct FileIoContext {
    OVERLAPPED Overlapped;  // 비동기 작업 상태 (필수!)
    HANDLE FileHandle;
    char Buffer[256];
};

// I/O 완료 시 스레드 풀이 호출하는 콜백
VOID CALLBACK FileIoCallback(
    PTP_CALLBACK_INSTANCE Instance,
    PVOID Context,
    PVOID Overlapped,
    ULONG IoResult,
    ULONG_PTR NumberOfBytesTransferred,
    PTP_IO Io
) {
    if (IoResult == ERROR_SUCCESS) {
        FileIoContext* pContext = (FileIoContext*)Context;
        std::cout << "✓ 읽기 성공! " << NumberOfBytesTransferred << " 바이트" << std::endl;
        std::cout << "내용: " << pContext->Buffer << std::endl;
    } else {
        std::cerr << "✗ 읽기 실패, 에러: " << IoResult << std::endl;
    }
    delete (FileIoContext*)Context;
}

int main() {
    const wchar_t* fileName = L"test.txt";
    
    // 테스트 파일 만들기
    HANDLE hWriteFile = CreateFileW(fileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    const char* content = "Hello, Async I/O!";
    DWORD bytesWritten;
    WriteFile(hWriteFile, content, strlen(content), &bytesWritten, NULL);
    CloseHandle(hWriteFile);

    // 비동기 읽기 시작
    HANDLE fileHandle = CreateFileW(fileName, GENERIC_READ, FILE_SHARE_READ, NULL, 
                                     OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);
    if (fileHandle == INVALID_HANDLE_VALUE) {
        std::cerr << "파일 열기 실패\n";
        return 1;
    }

    // 스레드 풀 설정
    PTP_POOL pool = CreateThreadpool(NULL);
    TP_CALLBACK_ENVIRON cbe;
    InitializeThreadpoolEnvironment(&cbe);
    SetThreadpoolCallbackPool(&cbe, pool);

    // I/O 컨텍스트 준비
    FileIoContext* context = new FileIoContext();
    ZeroMemory(context, sizeof(FileIoContext));
    context->FileHandle = fileHandle;

    // I/O 객체 생성
    PTP_IO ioObject = CreateThreadpoolIo(fileHandle, FileIoCallback, context, &cbe);

    // I/O 모니터링 시작
    StartThreadpoolIo(ioObject);

    // 비동기 읽기 시작
    BOOL result = ReadFile(fileHandle, context->Buffer, sizeof(context->Buffer) - 1, 
                           NULL, &context->Overlapped);
    
    // 비동기 호출은 FALSE를 반환하고 ERROR_IO_PENDING이 정상입니다
    if (!result && GetLastError() != ERROR_IO_PENDING) {
        std::cerr << "ReadFile 실패\n";
        CancelThreadpoolIo(ioObject);
        CloseThreadpoolIo(ioObject);
        CloseHandle(fileHandle);
        CloseThreadpool(pool);
        delete context;
        return 1;
    }

    std::cout << "메인: 비동기 읽기 요청함. 1초 대기...\n";
    Sleep(1000);  // I/O 완료 대기

    // 정리
    CloseHandle(fileHandle);
    CloseThreadpoolIo(ioObject);
    CloseThreadpool(pool);
    
    std::cout << "프로그램 종료\n";
    return 0;
}
```


### 정리: 스레드 풀 사용의 일반적인 패턴
모든 스레드 풀 작업은 다음 패턴을 따른다:

**1단계: 준비**
- 스레드 풀 생성 (`CreateThreadpool`)
- 규칙서 초기화 (`InitializeThreadpoolEnvironment`, `SetThreadpoolCallbackPool`)

**2단계: 작업 생성**
- 작업/타이머/대기/I/O 객체 생성 (각 `Create*` 함수)
- 콜백 함수 정의 (작업 완료 시 실행될 함수)

**3단계: 작업 실행**
- 작업 제출 또는 설정 (`Submit*`, `Set*` 함수)

**4단계: 대기 및 정리**
- 필요시 완료 대기 (`WaitForThreadpool*Callbacks`)
- 객체 및 풀 정리 (`Close*` 함수)

    
  
## 스레드를 '깨울 수 있는' 대기: WaitForSingleObjectEx
`WaitForSingleObjectEx`는 **커널 오브젝트**(이벤트, 뮤텍스, 세마포어, 타이머, 프로세스/스레드 핸들 등)가 **신호 상태(signaled)** 가 될 때까지 현재 스레드를 **차단(block)** 하는 함수다.

`WaitForSingleObject`와 비슷해 보이지만, 중요한 차이가 있다. `WaitForSingleObjectEx`는 **alertable wait**를 지원해서, 스레드가 대기 중에도 **APC**(Asynchronous Procedure Call)나 **완료 루틴 기반 비동기 I/O 콜백**을 실행할 수 있다는 점이다.

 
### Alertable Wait란 무엇인가
**alertable wait**란 스레드가 대기 상태에 있으면서도 **APC나 완료 루틴 콜백을 즉시 실행**할 수 있는 대기 방식을 말한다. 

일반적인 대기는 "신호가 올 때까지 완전히 잠자기만 한다"는 의미다. 하지만 alertable 대기는 "신호를 기다리는 동안에도 콜백 요청이 들어오면 즉시 처리할 준비가 되어 있다"는 뜻이다.

#### 동작 원리
Windows 커널은 각 스레드별로 **APC 큐**를 관리한다. 다음과 같은 흐름으로 작동한다:

**1단계: 콜백 요청 등록**
`QueueUserAPC`, `ReadFileEx/WriteFileEx`, `SetWaitableTimer(콜백 모드)` 등의 함수가 콜백 실행 요청을 스레드의 APC 큐에 넣는다.

**2단계: Alertable 대기 진입**
스레드가 `WaitForSingleObjectEx`, `WaitForMultipleObjectsEx`, `SleepEx` 등을 alertable 모드(`TRUE`)로 호출한다.

**3단계: 커널의 검사와 실행**
커널이 APC 큐를 검사해서 대기 중인 콜백이 있으면, 그 스레드 컨텍스트에서 바로 콜백을 실행한다.

**4단계: 재대기**
콜백이 하나 이상 실행되면 대기 함수는 `WAIT_IO_COMPLETION`을 반환한다. 보통은 목적 오브젝트가 신호 상태가 될 때까지 **다시 대기하는 루프**를 돈다.

#### 일반 대기 vs Alertable 대기
| 구분 | 일반 대기(`WaitForSingleObject`) | Alertable 대기(`WaitForSingleObjectEx(..., TRUE)`) |
|------|--------------------------------|--------------------------------------------------|
| **콜백/APC 처리** | 불가능하다 | 대기 중에도 즉시 처리된다 |
| **반환 코드** | `WAIT_OBJECT_0`, `WAIT_TIMEOUT` 등 | 위와 동일 + **`WAIT_IO_COMPLETION`** |
| **적합한 상황** | 단순한 동기 대기 | 완료 루틴 I/O, APC 신호, 타이머 콜백 |

#### 왜 필요한가
Alertable wait는 세 가지 상황에서 필수적이다:

**1. 완료 루틴 기반 비동기 I/O 처리**
`ReadFileEx`, `WriteFileEx` 같은 함수의 콜백이 실행되려면 호출 스레드가 반드시 alertable wait 상태여야 한다.

**2. APC로 스레드 신호 전달**
`QueueUserAPC`로 다른 스레드에 가벼운 신호를 보낼 때, 받는 쪽 스레드가 alertable 대기 중이어야 즉시 처리할 수 있다.

**3. 타이머 콜백(APC 타이머) 처리**
`SetWaitableTimer`에 콜백을 지정하면, 타이머 만료 시점에 APC 형태로 콜백이 실행되는데, 역시 alertable 대기가 필요하다.

#### 중요한 주의사항
**반드시 루프 재대기를 고려해야 한다**  
`WAIT_IO_COMPLETION`은 "대상 오브젝트가 신호 상태가 됨"이 아니라 "콜백을 하나 처리함"을 의미한다. 따라서 목적 오브젝트가 신호 상태가 될 때까지 계속 대기해야 한다.

**재진입과 교착 주의**  
대기 중 콜백이 "아무 때나" 실행될 수 있으므로, 콜백이 잡는 락과 대기 전에 잡고 있던 락이 교착을 일으키지 않도록 설계해야 한다.

**GUI 스레드는 다르게 처리하자**  
메시지 펌프가 필요한 GUI 스레드는 보통 `MsgWaitForMultipleObjectsEx(MWMO_ALERTABLE)`를 사용한다. 콘솔이나 워커 스레드는 `WaitForSingleObjectEx`가 충분하다.
  
**IOCP 모델과의 혼용은 피하자**  
IOCP(완료 포트)를 사용한다면 완료 루틴 기반 I/O와 섞지 않는 편이 훨씬 단순하다.


### 함수 시그니처와 매개변수

```c
DWORD WaitForSingleObjectEx(
  HANDLE hHandle,
  DWORD  dwMilliseconds,
  BOOL   bAlertable
);
```

#### 매개변수 설명
**`hHandle`**
대기할 대기 가능 커널 오브젝트의 핸들이다. 이벤트, 뮤텍스, 세마포어, 타이머, 프로세스/스레드 핸들 등이 가능하다.

**`dwMilliseconds`**
타임아웃을 밀리초 단위로 지정한다. `INFINITE`를 전달하면 무기한 대기한다. 0을 주면 현재 상태만 즉시 확인하고 반환한다.

**`bAlertable`**
`TRUE`이면 alertable wait 모드가 된다. 이때 스레드는 APC나 완료 루틴을 실행할 수 있다. `FALSE`이면 일반 대기 모드(APC 무시)다.

#### 반환값 해석
**`WAIT_OBJECT_0` (0x00000000)**
대상 오브젝트가 신호 상태가 되어 대기가 성공적으로 끝났다는 뜻이다. 이제 그 오브젝트를 안전하게 사용할 수 있다.

**`WAIT_TIMEOUT` (0x00000102)**
지정한 타임아웃 시간이 경과했는데도 오브젝트가 신호 상태가 되지 않았다는 뜻이다. 작업을 포기하거나 재시도 로직을 실행할 수 있다.

**`WAIT_ABANDONED` (0x00000080)**
뮤텍스 대기 중 소유 스레드가 정상적으로 종료되지 않고 사라져서 "버려진 뮤텍스"를 획득했다는 뜻이다. 이 경우 공유 상태가 불일치할 수 있으므로 점검 후 `ReleaseMutex`로 정리해야 한다.

**`WAIT_IO_COMPLETION` (0x000000C0)**
Alertable 대기 중 APC나 완료 루틴이 실행되어 깨어났다는 뜻이다. 대기 대상이 아직 신호 상태가 아닐 수 있으므로 보통 **루프를 돌며 재대기**한다.

**`WAIT_FAILED` (0xFFFFFFFF)**
함수 실행이 실패했다는 뜻이다. `GetLastError()`로 구체적인 원인을 확인할 수 있다.

  

### 사용 패턴

#### 패턴 1: APC 처리 루프
워커가 특정 이벤트가 신호 상태가 될 때까지 기다리되, 그 사이에 APC도 처리하는 전형적인 루프다.

```c
DWORD WaitUntilEventWithAPCs(HANDLE hEvent) {
    for (;;) {
        DWORD dw = WaitForSingleObjectEx(hEvent, INFINITE, TRUE);  // alertable
        if (dw == WAIT_OBJECT_0)        return ERROR_SUCCESS;      // 목표 달성
        if (dw == WAIT_IO_COMPLETION)   continue;                  // APC 처리됨, 재대기
        if (dw == WAIT_FAILED)          return GetLastError();     // 오류
        if (dw == WAIT_TIMEOUT)         return WAIT_TIMEOUT;       // 타임아웃
    }
}
```

이 패턴의 핵심은 `WAIT_IO_COMPLETION`이 돌아오면 "콜백을 처리했으니 다시 대기하라"는 의미라는 점이다.

#### 패턴 2: 완료 루틴 I/O와 SleepEx
완료 루틴 방식의 OVERLAPPED I/O는 콜백을 받으려면 스레드가 alertable 상태여야 한다. 가장 간단한 방법은 `SleepEx(INFINITE, TRUE)` 루프를 사용하는 것이다.

```c
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <stdio.h>

typedef struct {
    volatile LONG done;
} CTX;

VOID CALLBACK ReadDone(DWORD dwErrorCode, DWORD dwNumberOfBytesTransferred, LPOVERLAPPED lpOverlapped) {
    CTX* ctx = (CTX*)lpOverlapped->hEvent;
    printf("[ReadDone] 에러=%lu, 읽은바이트=%lu\n", dwErrorCode, dwNumberOfBytesTransferred);
    InterlockedExchange(&ctx->done, 1);
}

int main(void) {
    HANDLE hFile = CreateFileA("data.bin",
        GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
        FILE_FLAG_OVERLAPPED, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        printf("파일 열기 실패: %lu\n", GetLastError());
        return 1;
    }

    OVERLAPPED ov = {0};
    CTX ctx = {0};
    ov.hEvent = (HANDLE)&ctx;

    if (!ReadFileEx(hFile, malloc(4096), 4096, &ov, ReadDone)) {
        DWORD e = GetLastError();
        if (e != ERROR_IO_PENDING) {
            printf("ReadFileEx 실패: %lu\n", e);
            CloseHandle(hFile);
            return 1;
        }
    }

    // alertable 상태에서 콜백을 기다린다
    while (InterlockedCompareExchange(&ctx.done, 0, 0) == 0) {
        DWORD dw = SleepEx(INFINITE, TRUE);
        if (dw != 0) {
            printf("[메인] SleepEx가 콜백으로 깨어남\n");
        }
    }

    CloseHandle(hFile);
    return 0;
}
```

**실행 흐름 설명**  
`ReadFileEx` 함수를 호출하면 비동기로 파일 읽기가 시작된다. 읽기가 완료되면 `ReadDone` 콜백이 해당 스레드에서 실행되는데, 이를 위해 스레드가 `SleepEx(..., TRUE)` 같은 alertable 상태여야 한다.

콜백이 실행되어 `ctx->done`이 1로 설정되면 루프가 종료된다.
  

#### 패턴 3: 타이머 APC
타이머 만료 시점을 APC 콜백으로 받고 싶을 때도 alertable 대기가 필요하다.

```c
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <stdio.h>

VOID CALLBACK TimerAPCProc(LPVOID lpArg, DWORD dwLow, DWORD dwHigh) {
    printf("[타이머] 발동! arg=%p\n", lpArg);
}

int main(void) {
    HANDLE hTimer = CreateWaitableTimer(NULL, TRUE, NULL);

    LARGE_INTEGER due;
    due.QuadPart = -1 * 10 * 1000 * 1000;  // 1초 후(100ns 단위, 음수=상대시간)
    if (!SetWaitableTimer(hTimer, &due, 0, TimerAPCProc, (LPVOID)0xDEAD, FALSE)) {
        printf("SetWaitableTimer 실패: %lu\n", GetLastError());
        return 1;
    }

    // 타이머 콜백(APC)을 받으려면 alertable 대기가 필수다
    DWORD dw = SleepEx(INFINITE, TRUE);
    printf("[메인] SleepEx가 반환됨: %lu\n", dw);

    CloseHandle(hTimer);
    return 0;
}
```

이 코드에서는 1초 후 타이머가 만료되면서 `TimerAPCProc` 콜백이 메인 스레드에서 실행되고, `SleepEx`가 `WAIT_IO_COMPLETION`을 반환하며 깨어난다.



### 함수 선택: WaitForSingleObject vs WaitForSingleObjectEx

#### WaitForSingleObject
가장 기본적인 함수다. alertable 기능이 없으므로 APC나 완료 루틴 콜백을 무시한다.

**장점:** 간단하고 예측 가능하다.
**단점:** 완료 루틴 I/O나 APC 신호를 받을 수 없다.

#### WaitForSingleObjectEx
alertable 옵션을 선택할 수 있다. `bAlertable=TRUE`로 설정하면 콜백을 처리한다.

**장점:** 완료 루틴 I/O, APC 신호, 타이머 콜백을 모두 지원한다.
**단점:** alertable 모드 사용 시 루프 재대기를 신경 써야 한다.


### 실전 사용 사례

#### 기본 예제: 이벤트 대기
워커 스레드가 작업을 완료한 후 이벤트를 신호로 바꾸고, 메인 스레드가 대기하는 가장 단순한 예제다.

```c
// WaitEventBasic.c
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <stdio.h>

DWORD WINAPI WorkerThread(LPVOID param) {
    HANDLE hEvent = (HANDLE)param;
    // 어떤 작업을 시뮬레이션한다
    Sleep(1000);  // 1초 후 작업 완료
    SetEvent(hEvent);  // 완료 알림
    return 0;
}

int main(void) {
    // 수동 리셋, 초기 비신호 상태 이벤트 생성
    HANDLE hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!hEvent) {
        printf("CreateEvent 실패: %lu\n", GetLastError());
        return 1;
    }

    HANDLE hThread = CreateThread(NULL, 0, WorkerThread, hEvent, 0, NULL);
    if (!hThread) {
        printf("CreateThread 실패: %lu\n", GetLastError());
        CloseHandle(hEvent);
        return 1;
    }

    DWORD dw = WaitForSingleObjectEx(hEvent, 3000, FALSE);
    switch (dw) {
    case WAIT_OBJECT_0:
        printf("이벤트 신호 수신: 작업 완료!\n");
        break;
    case WAIT_TIMEOUT:
        printf("타임아웃: 이벤트를 받지 못했습니다\n");
        break;
    case WAIT_FAILED:
        printf("대기 실패: %lu\n", GetLastError());
        break;
    default:
        printf("예상치 못한 반환값: 0x%08lX\n", dw);
        break;
    }

    // 정리
    CloseHandle(hThread);
    CloseHandle(hEvent);
    return 0;
}
```

**동작 흐름**   
1. 메인이 이벤트를 생성하고 워커 스레드를 시작한다.
2. 메인은 `WaitForSingleObjectEx`로 이벤트를 기다린다.
3. 워커가 1초 후 작업을 완료하고 `SetEvent`로 이벤트를 신호한다.
4. 메인의 대기가 `WAIT_OBJECT_0`으로 깨어나고 이후 처리를 진행한다.

#### Alertable 대기 + APC 예제
메인 스레드가 워커 스레드를 만들고, 워커가 `WaitForSingleObjectEx(..., TRUE)`로 alertable 대기한다. 메인은 `QueueUserAPC`로 워커에 APC를 넣어 콜백을 실행시키고, 이후 이벤트를 신호로 바꿔 대기를 끝낸다.

```c
// AlertableWaitAPC.c
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <stdio.h>

VOID WINAPI MyApcProc(ULONG_PTR dwParam) {
    printf("[APC] 콜백 실행! 파라미터=%llu\n", (unsigned long long)dwParam);
}

typedef struct {
    HANDLE hEvent;
} THREAD_CTX;

DWORD WINAPI AlertableWorker(LPVOID lpParam) {
    THREAD_CTX* ctx = (THREAD_CTX*)lpParam;
    HANDLE hEvent = ctx->hEvent;

    for (;;) {
        DWORD dw = WaitForSingleObjectEx(hEvent, INFINITE, TRUE);  // alertable
        if (dw == WAIT_OBJECT_0) {
            printf("[워커] 이벤트 신호됨 -> 루프 종료\n");
            break;
        } else if (dw == WAIT_IO_COMPLETION) {
            printf("[워커] WAIT_IO_COMPLETION -> APC 처리됨, 다시 대기\n");
            continue;
        } else if (dw == WAIT_FAILED) {
            printf("[워커] 대기 실패: %lu\n", GetLastError());
            break;
        } else {
            printf("[워커] 예상치 못한 값: 0x%08lX\n", dw);
            break;
        }
    }
    return 0;
}

int main(void) {
    HANDLE hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    THREAD_CTX ctx = { hEvent };

    HANDLE hWorker = CreateThread(NULL, 0, AlertableWorker, &ctx, 0, NULL);
    if (!hWorker) {
        printf("CreateThread 실패: %lu\n", GetLastError());
        CloseHandle(hEvent);
        return 1;
    }

    // 잠시 대기 후 APC 주입
    Sleep(500);
    printf("[메인] 워커에 APC 주입\n");
    if (QueueUserAPC(MyApcProc, hWorker, 12345ULL) == 0) {
        printf("QueueUserAPC 실패: %lu\n", GetLastError());
    }

    // 또 잠시 후 이벤트 신호
    Sleep(500);
    printf("[메인] 이벤트 신호\n");
    SetEvent(hEvent);

    WaitForSingleObject(hWorker, INFINITE);
    CloseHandle(hWorker);
    CloseHandle(hEvent);
    printf("[메인] 프로그램 종료\n");
    return 0;
}
```

**동작 흐름**

1. 워커 스레드가 `WaitForSingleObjectEx(hEvent, INFINITE, TRUE)`로 alertable 대기를 시작한다.
2. 메인이 `QueueUserAPC`로 APC를 워커에 넣는다.
3. 워커는 즉시 `MyApcProc` 콜백을 실행한다.
4. 콜백 완료 후 `WaitForSingleObjectEx`는 `WAIT_IO_COMPLETION`을 반환한다.
5. 워커는 루프를 돌며 다시 대기한다.
6. 메인이 `SetEvent`로 이벤트를 신호하면 워커는 `WAIT_OBJECT_0`을 받고 루프를 종료한다.


### SleepEx 상세 설명
`SleepEx`는 스레드를 지정한 시간 동안 잠재운다. `bAlertable=TRUE`로 설정하면 그 시간 동안 alertable 대기 상태가 되어 APC나 완료 루틴을 처리할 수 있다.

#### 함수 시그니처

```c
DWORD SleepEx(
  DWORD dwMilliseconds,
  BOOL  bAlertable
);
```

#### 반환값

**`0`**
타임아웃이 발생했거나, 아무 콜백도 처리되지 않았을 때 반환된다.

**`WAIT_IO_COMPLETION` (0x000000C0)**
Alertable 모드에서 콜백이 처리되었을 때 반환된다.

#### 사용 예제

```c
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <stdio.h>

VOID CALLBACK MyApcProc(ULONG_PTR dwParam) {
    printf("[APC] 실행됨! 파라미터=%llu\n", (unsigned long long)dwParam);
}

DWORD WINAPI WorkerThread(LPVOID lpParam) {
    printf("[워커] SleepEx(INFINITE, TRUE) 진입 - alertable 대기 중\n");
    DWORD dw = SleepEx(INFINITE, TRUE);
    printf("[워커] SleepEx 반환: %lu\n", dw);
    return 0;
}

int main(void) {
    HANDLE hWorker = CreateThread(NULL, 0, WorkerThread, NULL, 0, NULL);

    Sleep(500);
    printf("[메인] 워커에 APC 큐\n");
    QueueUserAPC(MyApcProc, hWorker, 42);

    WaitForSingleObject(hWorker, INFINITE);
    CloseHandle(hWorker);
    printf("[메인] 프로그램 종료\n");
    return 0;
}
```

**실행 결과**

```
[워커] SleepEx(INFINITE, TRUE) 진입 - alertable 대기 중
[메인] 워커에 APC 큐
[APC] 실행됨! 파라미터=42
[워커] SleepEx 반환: 0xC0
[메인] 프로그램 종료
```

워커가 alertable 상태에서 대기 중일 때 APC가 도착하면 즉시 콜백이 실행되고, `SleepEx`는 `WAIT_IO_COMPLETION`을 반환한다.
  


## SignalObjectAndWait 두 가지 동작을 한번에
`SignalObjectAndWait` 함수는 이름 그대로 **두 가지 동작을 하나의 원자적(Atomic) 작업으로** 묶어주는 매우 유용한 함수이다.

1.  첫 번째 객체에 **신호(Signal)** 를 보낸다. (예: 이벤트를 Set, 뮤텍스를 Release)
2.  두 번째 객체를 **대기(Wait)** 한다. (예: 이벤트가 Set 되기를, 스레드가 종료되기를)


### 1. `SignalObjectAndWait`를 사용하는 이유
이 함수가 왜 필요할까? 그냥 아래처럼 2줄로 쓰면 안 될까?

```c
// [나쁜 예제] - 이렇게 사용하면 안 됩니다!
SetEvent(hEventToSignal);           // 1. 신호 보냄
WaitForSingleObject(hEventToWait, INFINITE); // 2. 대기
```

**"경합 상태(Race Condition)"** 때문이다. 1번과 2번 사이에 아주 잠깐이라도 틈이 생기면, 다른 스레드가 그 틈을 비집고 들어올 수 있다.  
  
**[최악의 시나리오]**

1.  **스레드 A**가 `SetEvent(hEventToSignal)`를 호출한다.
2.  운영체제가 즉시 **스레드 B**로 CPU 제어권을 넘긴다.
3.  **스레드 B**는 `hEventToSignal` 신호를 받고, 자신의 작업을 수행한 뒤, `SetEvent(hEventToWait)`를 호출한다.
4.  다시 **스레드 A**로 CPU 제어권이 돌아온다.
5.  **스레드 A**는 이제서야 2번 라인인 `WaitForSingleObject(hEventToWait, ...)`를 실행한다.
6.  **문제 발생:** 스레드 A가 기다려야 할 `hEventToWait` 신호는 **이미 발생하고 지나가 버렸습니다.** 스레드 A는 영원히 기다리게 된다. (데드락)

`SignalObjectAndWait`는 **1번(신호)과 2번(대기) 동작을 그 누구도 방해할 수 없는 하나의 단위(원자적)로 묶어** 이 문제를 완벽하게 해결한다.


### 2. 간단한 예제 코드: "작업 지시 및 완료 보고"
두 스레드가 "핑퐁(Ping-Pong)"처럼 신호를 주고받는 예제이다.

  * **시나리오:** 메인 스레드가 워커 스레드에게 "작업 시작" 신호를 보내고, 워커 스레드가 "작업 완료" 신호를 보낼 때까지 기다린다.


```c
#include <windows.h>
#include <stdio.h>

// 스레드에 2개의 이벤트 핸들을 전달하기 위한 구조체
typedef struct {
    HANDLE hEvent_StartWork;  // [메인->워커] 작업 시작 신호
    HANDLE hEvent_WorkDone;   // [워커->메인] 작업 완료 신호
} ThreadParams;


// 워커 스레드가 실행할 함수
DWORD WINAPI WorkerThreadFunction(LPVOID lpParam)
{
    ThreadParams* pParams = (ThreadParams*)lpParam;

    // 1. 메인 스레드가 "작업 시작" 신호를 줄 때까지 대기
    printf("[워커] '작업 시작' 신호를 기다립니다...\n");
    WaitForSingleObject(pParams->hEvent_StartWork, INFINITE);

    // 2. 신호를 받으면 작업을 수행
    printf("[워커] 신호 수신! 2초간 작업을 수행합니다.\n");
    Sleep(2000); // 가상의 작업 수행

    // 3. 작업이 끝났다고 "작업 완료" 신호를 보냄
    printf("[워커] 작업 완료! 메인 스레드에 '작업 완료' 신호를 보냅니다.\n");
    SetEvent(pParams->hEvent_WorkDone);

    return 0;
}


int main()
{
    ThreadParams params;
    HANDLE hThread;

    // 1. 이벤트 2개 생성 (둘 다 자동 리셋, 비신호 상태로 시작)
    //    (Auto-reset: TRUE, Initial-state: FALSE)
    params.hEvent_StartWork = CreateEvent(NULL, FALSE, FALSE, NULL);
    params.hEvent_WorkDone  = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (params.hEvent_StartWork == NULL || params.hEvent_WorkDone == NULL) {
        printf("이벤트 생성 실패\n");
        return 1;
    }

    // 2. 워커 스레드 생성
    hThread = CreateThread(NULL, 0, WorkerThreadFunction, &params, 0, NULL);
    if (hThread == NULL) {
        printf("스레드 생성 실패\n");
        return 1;
    }

    // 메인 스레드도 1초간 다른 작업을 한다고 가정
    printf("[메인] 1초간 다른 작업을 수행합니다...\n");
    Sleep(1000);

    printf("[메인] SignalObjectAndWait 호출: 워커에게 '시작'을 알리고, 워커의 '완료'를 기다립니다.\n");

    // 3. SignalObjectAndWait (핵심)
    //    원자적으로 다음 2가지 일을 수행:
    //    (1) hEvent_StartWork에 신호를 보내고 (워커 스레드가 깨어남)
    //    (2) hEvent_WorkDone 신호를 기다린다 (메인 스레드가 멈춤)
    DWORD dwResult = SignalObjectAndWait(
        params.hEvent_StartWork, // [Signal] 신호를 보낼 객체
        params.hEvent_WorkDone,  // [Wait]   기다릴 객체
        INFINITE,                // 무한정 대기
        FALSE                    // (Alertable 대기 아님)
    );

    if (dwResult == WAIT_OBJECT_0) {
        printf("[메인] 워커의 '작업 완료' 신호를 수신했습니다.\n");
    }

    // 4. 리소스 정리
    WaitForSingleObject(hThread, INFINITE); // 워커 스레드 종료 확인
    printf("[메인] 프로그램 종료.\n");

    CloseHandle(hThread);
    CloseHandle(params.hEvent_StartWork);
    CloseHandle(params.hEvent_WorkDone);

    return 0;
}
```


### 3. 코드의 실행 흐름 (타임라인)
1.  `[메인]`이 `hEvent_StartWork`와 `hEvent_WorkDone` 이벤트를 (비신호 상태로) 생성한다.
2.  `[메인]`이 `[워커]` 스레드를 생성한다.
3.  `[워커]`가 먼저 실행되어 `WaitForSingleObject(hEvent_StartWork, ...)`를 만나고, 신호가 없으므로 **멈춘다.**
4.  `[메인]`은 `Sleep(1000)`으로 1초간 대기한다.
5.  `[메인]`이 `SignalObjectAndWait(hEvent_StartWork, hEvent_WorkDone, ...)`를 호출한다.
6.  **(원자적 동작 발생)**
      * `hEvent_StartWork`가 **신호(Signaled)** 상태가 된다.
      * `[메인]` 스레드는 `hEvent_WorkDone`을 기다리며 **멈춘다.**
7.  `[워커]`는 `hEvent_StartWork` 신호를 감지하고 **깨어난다.**
8.  `[워커]`가 `Sleep(2000)`으로 2초간 작업을 수행한다.
9.  `[워커]`가 작업을 마치고 `SetEvent(hEvent_WorkDone)`를 호출한다.
10. `[메인]`은 `hEvent_WorkDone` 신호를 감지하고 **깨어난다.**
11. `[메인]`과 `[워커]`가 순차적으로 정리되고 프로그램이 종료된다.  