# 4ì£¼ì°¨ ê³¼ì œ    
  
## ğŸ›¡ï¸ ë¬¸ì œ 1: ê³µìœ  ìì› 'ì²´ë ¥ ë¬¼ì•½' ì‚¬ìš©í•˜ê¸°

**ë¬¸ì œ ëª©ì **
  - ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ê³µìœ  ìì›(ì²´ë ¥ ë¬¼ì•½)ì— ë™ì‹œì— ì ‘ê·¼í•  ë•Œ ë°œìƒí•˜ëŠ” ë¬¸ì œì (Race Condition)ì„ ì´í•´í•˜ê³ , `CRITICAL_SECTION`ì„ ì´ìš©í•´ ì´ë¥¼ í•´ê²°í•˜ëŠ” ë°©ë²•ì„ ë°°ìš´ë‹¤.  

**ë¬¸ì œ ì¡°ê±´**
1.  `potion_count`ëŠ” ëª¨ë“  í”Œë ˆì´ì–´ ìŠ¤ë ˆë“œê°€ ê³µìœ í•˜ëŠ” ì „ì—­ ë³€ìˆ˜ì´ë‹¤.
2.  `usePotion` í•¨ìˆ˜ëŠ” ê° í”Œë ˆì´ì–´ê°€ ë¬¼ì•½ì„ ì‚¬ìš©í•˜ëŠ” í–‰ë™ì„ ë¬˜ì‚¬í•œë‹¤. ë¬¼ì•½ì´ ë‚¨ì•„ìˆìœ¼ë©´ 1ê°œ ì‚¬ìš©í•˜ê³ , "Player Xê°€ ë¬¼ì•½ì„ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤." ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•œë‹¤.
3.  `CRITICAL_SECTION`ì„ ì‚¬ìš©í•˜ì—¬ `potion_count`ë¥¼ í™•ì¸í•˜ê³  ê°ì†Œì‹œí‚¤ëŠ” ì½”ë“œë¥¼ ë³´í˜¸í•´ì•¼ í•œë‹¤. ì´ë¥¼ í†µí•´ ì •í™•íˆ 10ê°œì˜ ë¬¼ì•½ë§Œ ì†Œëª¨ë˜ë„ë¡ ë³´ì¥í•´ì•¼ í•œë‹¤.
  
**ë¯¸ì™„ì„± ì½”ë“œ**  

```cpp
#include <iostream>
#include <windows.h>
#include <process.h>
#include <vector>

int potion_count = 10; // ê³µìœ  ìì›: ë¬¼ì•½ 10ê°œ
CRITICAL_SECTION cs;     // í¬ë¦¬í‹°ì»¬ ì„¹ì…˜

unsigned int __stdcall usePotion(void* arg) {
    int playerId = *(int*)arg;

    // TODO: í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ ì‹œì‘
    // ...

    if (potion_count > 0) {
        Sleep(10); // ë¬¼ì•½ì„ ë§ˆì‹œëŠ” ë° ì‹œê°„ì´ ê±¸ë¦¬ëŠ” ê²ƒì„ ì‹œë®¬ë ˆì´ì…˜
        potion_count--;
        printf("Player %dê°€ ë¬¼ì•½ì„ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤. ë‚¨ì€ ë¬¼ì•½: %d\n", playerId, potion_count);
    }

    // TODO: í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ ë
    // ...

    return 0;
}

int main() 
{
    const int NUM_PLAYERS = 20;
    std::vector<HANDLE> threads;
    std::vector<int> playerIds;

    // TODO: í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ ì´ˆê¸°í™”
    // ...

    for (int i = 0; i < NUM_PLAYERS; ++i) {
        playerIds.push_back(i + 1);
        HANDLE hThread = (HANDLE)_beginthreadex(NULL, 0, usePotion, &playerIds[i], 0, NULL);
        if (hThread) {
            threads.push_back(hThread);
        }
    }

    WaitForMultipleObjects(threads.size(), threads.data(), TRUE, INFINITE);

    for (HANDLE hThread : threads) {
        CloseHandle(hThread);
    }

    // TODO: í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ ì‚­ì œ
    // ...

    printf("ìµœì¢… ë‚¨ì€ ë¬¼ì•½ ê°œìˆ˜: %d\n", potion_count);

    return 0;
}
```

  
## ğŸ‰ ë¬¸ì œ 2: ë³´ìŠ¤ ëª¬ìŠ¤í„° ë“±ì¥ ë™ê¸°í™”

**ë¬¸ì œ ëª©ì **
  - íŠ¹ì • ì‘ì—…(ë³´ìŠ¤ ëª¬ìŠ¤í„° ë¡œë”©)ì´ ì™„ë£Œë  ë•Œê¹Œì§€ ë‹¤ë¥¸ ìŠ¤ë ˆë“œ(í”Œë ˆì´ì–´ë“¤)ê°€ ê¸°ë‹¤ë¦¬ë„ë¡ ë§Œë“¤ì–´ì•¼ í•  ë•Œ, `Event` ê°ì²´ë¥¼ ì‚¬ìš©í•œ ìŠ¤ë ˆë“œ ê°„ì˜ ì‹ í˜¸ ë™ê¸°í™” ë°©ë²•ì„ í•™ìŠµí•œë‹¤.  
  
**ë¬¸ì œ ì¡°ê±´**
1.  `loadBoss` ìŠ¤ë ˆë“œëŠ” ë³´ìŠ¤ ëª¬ìŠ¤í„°ë¥¼ ë¡œë”©í•˜ëŠ” ì—­í• ì´ë©°, 3ì´ˆì˜ ì‹œê°„ì´ ê±¸ë¦°ë‹¤.
2.  `enterBattle` ìŠ¤ë ˆë“œë“¤ì€ í”Œë ˆì´ì–´ê°€ ì „íˆ¬ì— ëŒì…í•˜ëŠ” ì—­í• ì´ë‹¤.
3.  í”Œë ˆì´ì–´ë“¤ì€ ë³´ìŠ¤ ë¡œë”©ì´ ì™„ë£Œë˜ê¸° ì „ê¹Œì§€ëŠ” "ë³´ìŠ¤ ë¡œë”©ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘..." ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•˜ë©° ëŒ€ê¸°í•´ì•¼ í•œë‹¤.
4.  `loadBoss` ìŠ¤ë ˆë“œëŠ” ë¡œë”©ì´ ì™„ë£Œë˜ë©´ `Event`ë¥¼ `Set` ìƒíƒœë¡œ ë§Œë“¤ì–´ í”Œë ˆì´ì–´ ìŠ¤ë ˆë“œë“¤ì—ê²Œ ì „íˆ¬ ì‹œì‘ì„ ì•Œë ¤ì•¼ í•œë‹¤.
5.  í”Œë ˆì´ì–´ ìŠ¤ë ˆë“œë“¤ì€ `Event`ê°€ `Set` ìƒíƒœê°€ ë˜ë©´ ëŒ€ê¸°ë¥¼ ë©ˆì¶”ê³  "ì „íˆ¬ ì‹œì‘!" ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•œë‹¤.

**ë¯¸ì™„ì„± ì½”ë“œ**

```cpp
#include <iostream>
#include <windows.h>
#include <process.h>

HANDLE g_hBossReadyEvent; // ë³´ìŠ¤ ì¤€ë¹„ ì™„ë£Œ ì´ë²¤íŠ¸

// ë³´ìŠ¤ ëª¬ìŠ¤í„°ë¥¼ ë¡œë”©í•˜ëŠ” ìŠ¤ë ˆë“œ í•¨ìˆ˜
unsigned int __stdcall loadBoss(void* arg) {
    printf("ë³´ìŠ¤ ëª¬ìŠ¤í„°ë¥¼ ë¡œë”© ì¤‘ì…ë‹ˆë‹¤...\n");
    Sleep(3000); // 3ì´ˆ ë™ì•ˆ ë¡œë”©
    printf("ë³´ìŠ¤ ë¡œë”© ì™„ë£Œ!\n");

    // TODO: ë³´ìŠ¤ ì¤€ë¹„ ì™„ë£Œ ì´ë²¤íŠ¸ë¥¼ Set ìƒíƒœë¡œ ë§Œë“œì„¸ìš”.
    // ...

    return 0;
}

// í”Œë ˆì´ì–´ê°€ ì „íˆ¬ì— ì°¸ì—¬í•˜ëŠ” ìŠ¤ë ˆë“œ í•¨ìˆ˜
unsigned int __stdcall enterBattle(void* arg) {
    int playerId = *(int*)arg;
    printf("Player %d, ë³´ìŠ¤ ë¡œë”©ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...\n", playerId);

    // TODO: ë³´ìŠ¤ ì¤€ë¹„ ì™„ë£Œ ì´ë²¤íŠ¸ê°€ Set ìƒíƒœê°€ ë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ì„¸ìš”.
    // ...

    printf("Player %d, ì „íˆ¬ ì‹œì‘!\n", playerId);
    return 0;
}

int main() 
{
    // TODO: Manual-reset, non-signaled ìƒíƒœì˜ ì´ë²¤íŠ¸ë¥¼ ìƒì„±í•˜ì„¸ìš”.
    // g_hBossReadyEvent = CreateEvent(...);

    if (g_hBossReadyEvent == NULL) {
        printf("ì´ë²¤íŠ¸ ìƒì„± ì‹¤íŒ¨\n");
        return 1;
    }

    HANDLE hBossThread = (HANDLE)_beginthreadex(NULL, 0, loadBoss, NULL, 0, NULL);

    const int NUM_PLAYERS = 5;
    HANDLE hPlayerThreads[NUM_PLAYERS];
    int playerIds[NUM_PLAYERS];
    for (int i = 0; i < NUM_PLAYERS; ++i) {
        playerIds[i] = i + 1;
        hPlayerThreads[i] = (HANDLE)_beginthreadex(NULL, 0, enterBattle, &playerIds[i], 0, NULL);
    }

    WaitForSingleObject(hBossThread, INFINITE);
    WaitForMultipleObjects(NUM_PLAYERS, hPlayerThreads, TRUE, INFINITE);

    CloseHandle(hBossThread);
    for (int i = 0; i < NUM_PLAYERS; ++i) {
        CloseHandle(hPlayerThreads[i]);
    }
    // TODO: ìƒì„±í•œ ì´ë²¤íŠ¸ë¥¼ ë‹«ìœ¼ì„¸ìš”.
    // ...

    return 0;
}
```    
    
    
    
## ğŸš€ ë¬¸ì œ 3: ê³¨ë“œ ê´‘ì‚° ë™ì‹œ ì±„êµ´

**ë¬¸ì œ ëª©ì **
  - ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— í•˜ë‚˜ì˜ ê³µìœ  ë³€ìˆ˜(ì´ ê³¨ë“œëŸ‰)ë¥¼ ìˆ˜ì •í•  ë•Œ ë°œìƒí•˜ëŠ” **ê²½ìŸ ìƒíƒœ(Race Condition)**ë¥¼ ì§ì ‘ í™•ì¸í•˜ê³ , `CRITICAL_SECTION`ì„ ì´ìš©í•´ ë°ì´í„°ì˜ ë¬´ê²°ì„±ì„ ë³´ì¥í•˜ëŠ” ë°©ë²•ì„ í•™ìŠµí•œë‹¤.  
  
**ë¬¸ì œ ì‹œë‚˜ë¦¬ì˜¤**
ì—¬ëŸ¬ ëª…ì˜ ê´‘ë¶€(`Miner` ìŠ¤ë ˆë“œ)ê°€ í•˜ë‚˜ì˜ ê´‘ì‚°ì—ì„œ ë™ì‹œì— ê³¨ë“œë¥¼ ì±„êµ´í•œë‹¤. ê° ê´‘ë¶€ëŠ” ìì‹ ì´ ìº” ê³¨ë“œë¥¼ íŒ€ì˜ ê³µìœ  ì°½ê³ (`g_totalGold`)ì— ì¶”ê°€í•œë‹¤. ë§Œì•½ ì—¬ëŸ¬ ê´‘ë¶€ê°€ 'ë™ì‹œì—' ì°½ê³ ì— ê³¨ë“œë¥¼ ì¶”ê°€í•˜ë ¤ê³  í•˜ë©´, ê³„ì‚°ì´ ê¼¬ì—¬ì„œ ìµœì¢… ê³¨ë“œëŸ‰ì´ ì‹¤ì œ ì±„êµ´í•œ ì–‘ë³´ë‹¤ ì ì–´ì§€ëŠ” ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤.  
  
**ë¬¸ì œ ì¡°ê±´**
1.  `g_totalGold`ëŠ” ëª¨ë“  ê´‘ë¶€ ìŠ¤ë ˆë“œê°€ ê³µìœ í•˜ëŠ” ì „ì—­ ë³€ìˆ˜ì´ë‹¤.  
2.  `mineGold` í•¨ìˆ˜ëŠ” ê° ê´‘ë¶€ ìŠ¤ë ˆë“œê°€ ì‹¤í–‰í•  í•¨ìˆ˜ì´ë‹¤.  
3.  ê° ê´‘ë¶€ëŠ” 10 ê³¨ë“œì”©, ì´ 5ë²ˆ ì±„êµ´í•˜ì—¬ `g_totalGold`ì— ì¶”ê°€í•´ì•¼ í•œë‹¤.  
4.  ê³¨ë“œë¥¼ ì¶”ê°€í•˜ëŠ” ê³¼ì •(`g_totalGold` ê°’ì„ ì½ê³ , ë”í•˜ê³ , ë‹¤ì‹œ ì“°ëŠ” ê³¼ì •)ì€ ë°˜ë“œì‹œ **`CRITICAL_SECTION`**ìœ¼ë¡œ ë³´í˜¸ë˜ì–´ì•¼ í•œë‹¤.
5.  `NUM_MINERS`ëŠ” 5ëª…, ê° ê´‘ë¶€ê°€ 10ê³¨ë“œì”© 5ë²ˆ ì±„êµ´í•˜ë¯€ë¡œ, ëª¨ë“  ì‘ì—…ì´ ëë‚¬ì„ ë•Œ `g_totalGold`ëŠ” ì •í™•íˆ **250**ì´ ë˜ì–´ì•¼ í•œë‹¤. (5ëª… * 10ê³¨ë“œ * 5íšŒ)

**ë¯¸ì™„ì„± ì½”ë“œ**

```cpp
#include <iostream>
#include <windows.h>
#include <process.h>
#include <vector>

#define NUM_MINERS 5
#define GOLD_PER_TRIAL 10
#define NUM_TRIALS 5

int g_totalGold = 0; // ê³µìœ  ìì›: íŒ€ì˜ ì´ ê³¨ë“œ
CRITICAL_SECTION cs_gold;

// ê´‘ë¶€ ìŠ¤ë ˆë“œê°€ ì‹¤í–‰í•  í•¨ìˆ˜
unsigned int __stdcall mineGold(void* arg) {
    int minerId = *(int*)arg;

    for (int i = 0; i < NUM_TRIALS; ++i) {
        // ê³¨ë“œë¥¼ ì±„êµ´í•˜ëŠ” ì‹œê°„ ì‹œë®¬ë ˆì´ì…˜
        Sleep(10); 
        
        // TODO 1: g_totalGoldì— ì ‘ê·¼í•˜ê¸° ì „, í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ì— ì§„ì…í•˜ì„¸ìš”.
        // ...

        // --- ê²½ìŸ ìƒíƒœê°€ ë°œìƒí•˜ëŠ” êµ¬ê°„ ---
        int currentGold = g_totalGold; // 1. í˜„ì¬ ê³¨ë“œëŸ‰ì„ ì½ëŠ”ë‹¤.
        printf("ê´‘ë¶€ %d, í˜„ì¬ ê³¨ë“œëŸ‰ %d í™•ì¸ í›„ 10ê³¨ë“œ ì¶”ê°€ ì‹œë„...\n", minerId, currentGold);
        currentGold += GOLD_PER_TRIAL; // 2. ìº” ê³¨ë“œë¥¼ ë”í•œë‹¤.
        Sleep(5); // ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ë¼ì–´ë“¤ ìˆ˜ ìˆëŠ” ì‹œê°„ì ì¸ í‹ˆì„ ë§Œë“¦
        g_totalGold = currentGold;     // 3. ìƒˆë¡œìš´ ê³¨ë“œëŸ‰ìœ¼ë¡œ ë®ì–´ì“´ë‹¤.
        // ---------------------------------
        
        // TODO 2: g_totalGold ì ‘ê·¼ì´ ëë‚¬ìœ¼ë‹ˆ, í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ì—ì„œ ë¹ ì ¸ë‚˜ì˜¤ì„¸ìš”.
        // ...
    }
    return 0;
}

int main() 
{
    // TODO 3: main í•¨ìˆ˜ ì‹œì‘ ì‹œ, í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ì„ ì´ˆê¸°í™”í•˜ì„¸ìš”.
    // ...

    std::vector<HANDLE> threads;
    std::vector<int> minerIds;

    printf("--- %dëª…ì˜ ê´‘ë¶€ê°€ ì±„êµ´ì„ ì‹œì‘í•©ë‹ˆë‹¤! ---\n", NUM_MINERS);
    printf("ê¸°ëŒ€ ê²°ê³¼ê°’: %d\n\n", NUM_MINERS * GOLD_PER_TRIAL * NUM_TRIALS);

    for (int i = 0; i < NUM_MINERS; ++i) {
        minerIds.push_back(i + 1);
        threads.push_back((HANDLE)_beginthreadex(NULL, 0, mineGold, &minerIds.back(), 0, NULL));
    }

    //TODO 4. ëª¨ë“  ìŠ¤ë ˆë“œê°€ ì‘ì—…ì„ ë§ˆì¹  ë•Œê¹Œì§€ ëŒ€ê¸°
    // ...

    for (HANDLE h : threads) {
        CloseHandle(h);
    }

    // TODO 5: main í•¨ìˆ˜ ì¢…ë£Œ ì „, í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ ë¦¬ì†ŒìŠ¤ë¥¼ ì‚­ì œí•˜ì„¸ìš”.
    // ...

    printf("\n--- ëª¨ë“  ì±„êµ´ ì‘ì—… ì™„ë£Œ! ---\n");
    printf("ìµœì¢… ê³¨ë“œëŸ‰: %d\n", g_totalGold);

    return 0;
}
```  

    
  
## ğŸš€ ë¬¸ì œ 4: ì‹¤ì‹œê°„ ê²Œì„ ì•¡ì…˜ í(Queue) ì²˜ë¦¬

**ë¬¸ì œ ëª©ì **
  - ì—¬ëŸ¬ ìŠ¤ë ˆë“œ(ìƒì‚°ì, ì†Œë¹„ì)ê°€ ê³ ì •ëœ í¬ê¸°ì˜ ê³µìœ  ë²„í¼(í)ì— ë°ì´í„°ë¥¼ ì¶”ê°€í•˜ê³  ì œê±°í•˜ëŠ” **ìƒì‚°ì-ì†Œë¹„ì(Producer-Consumer) íŒ¨í„´**ì„ êµ¬í˜„í•œë‹¤.
  - íê°€ ê°€ë“ ì°¼ì„ ë•Œ(Full)ì™€ ë¹„ì–´ìˆì„ ë•Œ(Empty)ì˜ ì˜ˆì™¸ ìƒí™©ì„ ì˜¬ë°”ë¥´ê²Œ ì²˜ë¦¬í•˜ë©°, íì˜ ìƒíƒœë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì—¬ëŸ¬ ë³€ìˆ˜(ë°ì´í„° ë°°ì—´, ì¸ë±ìŠ¤, ì¹´ìš´íŠ¸)ë¥¼ `CRITICAL_SECTION`ìœ¼ë¡œ í•œ ë²ˆì— ë¬¶ì–´ ë³´í˜¸í•˜ëŠ” ë°©ë²•ì„ í•™ìŠµí•œë‹¤.

**ë¬¸ì œ ì‹œë‚˜ë¦¬ì˜¤**
ì‹¤ì‹œê°„ ì „ëµ ê²Œì„(RTS)ì—ì„œëŠ” í”Œë ˆì´ì–´ì˜ ìˆ˜ë§ì€ ìœ ë‹›ë“¤ì´ ê°ìì˜ í–‰ë™(ì´ë™, ê³µê²©, ìŠ¤í‚¬ ì‚¬ìš© ë“±)ì„ ìˆ˜í–‰í•œë‹¤. ì´ ë¬¸ì œì—ì„œëŠ” ì—¬ëŸ¬ 'AI ìœ ë‹›' ìŠ¤ë ˆë“œê°€ ìì‹ ì˜ ë‹¤ìŒ í–‰ë™ì„ ê²°ì •í•˜ì—¬ ì¤‘ì•™ 'ì•¡ì…˜ í'ì— ë“±ë¡í•˜ê³ (ìƒì‚°ì), 'ê²Œì„ ì—”ì§„' ìŠ¤ë ˆë“œëŠ” ì´ íì—ì„œ í–‰ë™ì„ ìˆœì„œëŒ€ë¡œ êº¼ë‚´ì–´ ì²˜ë¦¬(ì†Œë¹„ì)í•˜ëŠ” ìƒí™©ì„ ì‹œë®¬ë ˆì´ì…˜í•œë‹¤. íì˜ í¬ê¸°ëŠ” í•œì •ë˜ì–´ ìˆì–´, íê°€ ê½‰ ì°¨ë©´ ìœ ë‹›ì€ ì ì‹œ ëŒ€ê¸°í•´ì•¼ í•˜ê³ , íê°€ ë¹„ì–´ìˆìœ¼ë©´ ì—”ì§„ì€ í•  ì¼ì´ ìƒê¸¸ ë•Œê¹Œì§€ ê¸°ë‹¤ë ¤ì•¼ í•œë‹¤.

**ë¬¸ì œ ì¡°ê±´**

1.  **ê³µìœ  ìì›**ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.
      * `g_actionQueue`: ì•¡ì…˜(intë¡œ í‘œí˜„)ì„ ì €ì¥í•˜ëŠ” ê³ ì • í¬ê¸° ë°°ì—´.
      * `g_itemCount`: íì— ì €ì¥ëœ ì•¡ì…˜ì˜ ê°œìˆ˜.
      * `g_writeIndex`, `g_readIndex`: ë°ì´í„°ë¥¼ ì“°ê³  ì½ì„ ìœ„ì¹˜ë¥¼ ê°€ë¦¬í‚¤ëŠ” ì¸ë±ìŠ¤ (ìˆœí™˜ í í˜•íƒœ).
2.  **`aiUnitThread` (ìƒì‚°ì):**
      * ì£¼ê¸°ì ìœ¼ë¡œ ìƒˆë¡œìš´ ì•¡ì…˜ì„ ìƒì„±í•œë‹¤.
      * ì•¡ì…˜ì„ íì— ì¶”ê°€í•˜ê¸° ì „, **`CRITICAL_SECTION`**ì— ì§„ì…í•´ì•¼ í•œë‹¤.
      * íê°€ **ê°€ë“ ì°¼ëŠ”ì§€(`g_itemCount == MAX_QUEUE_SIZE`)** í™•ì¸í•œë‹¤.
      * ë§Œì•½ ê°€ë“ ì°¼ë‹¤ë©´, "íê°€ ê°€ë“ ì°¨ ë“±ë¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤." ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•˜ê³ , í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ì„ ë¹ ì ¸ë‚˜ì™€ ì ì‹œ ëŒ€ê¸°(`Sleep`)í•œ í›„ ì¬ì‹œë„í•´ì•¼ í•œë‹¤.
      * ìë¦¬ê°€ ìˆë‹¤ë©´, ì•¡ì…˜ì„ ì¶”ê°€í•˜ê³  `g_writeIndex`ì™€ `g_itemCount`ë¥¼ ê°±ì‹ í•œë‹¤.
      * ì‘ì—…ì´ ëë‚˜ë©´ í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ì„ ë¹ ì ¸ë‚˜ì˜¨ë‹¤.
3.  **`gameEngineThread` (ì†Œë¹„ì):**
      * ì£¼ê¸°ì ìœ¼ë¡œ íì—ì„œ ì•¡ì…˜ì„ ê°€ì ¸ì™€ ì²˜ë¦¬í•œë‹¤.
      * ì•¡ì…˜ì„ ê°€ì ¸ì˜¤ê¸° ì „, **`CRITICAL_SECTION`**ì— ì§„ì…í•´ì•¼ í•œë‹¤.
      * íê°€ **ë¹„ì–´ìˆëŠ”ì§€(`g_itemCount == 0`)** í™•ì¸í•œë‹¤.
      * ë§Œì•½ ë¹„ì–´ìˆë‹¤ë©´, "ì²˜ë¦¬í•  ì•¡ì…˜ì´ ì—†ìŠµë‹ˆë‹¤." ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•˜ê³ , í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ì„ ë¹ ì ¸ë‚˜ì™€ ì ì‹œ ëŒ€ê¸°í•œ í›„ ì¬ì‹œë„í•´ì•¼ í•œë‹¤.
      * ì²˜ë¦¬í•  ì•¡ì…˜ì´ ìˆë‹¤ë©´, ì•¡ì…˜ì„ êº¼ë‚´ê³  `g_readIndex`ì™€ `g_itemCount`ë¥¼ ê°±ì‹ í•œë‹¤.
      * ì‘ì—…ì´ ëë‚˜ë©´ í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ì„ ë¹ ì ¸ë‚˜ì˜¨ë‹¤.
  
**ë¯¸ì™„ì„± ì½”ë“œ**
  
```cpp
#include <iostream>
#include <windows.h>
#include <process.h>
#include <vector>

#define MAX_QUEUE_SIZE 8
#define NUM_UNITS 3      // ìƒì‚°ì ìŠ¤ë ˆë“œ ìˆ˜
#define NUM_ACTIONS 7    // ê° ìœ ë‹›ì´ ìƒì„±í•  ì•¡ì…˜ ìˆ˜

// --- ê³µìœ  ìì› ---
int g_actionQueue[MAX_QUEUE_SIZE];
int g_itemCount = 0;
int g_writeIndex = 0;
int g_readIndex = 0;
CRITICAL_SECTION cs_queue;

// ìƒì‚°ì: AI ìœ ë‹› ìŠ¤ë ˆë“œ
unsigned int __stdcall aiUnitThread(void* arg) {
    int unitId = *(int*)arg;
    srand(unitId); // ê° ìŠ¤ë ˆë“œë§ˆë‹¤ ë‹¤ë¥¸ ì‹œë“œê°’ ë¶€ì—¬

    for (int i = 0; i < NUM_ACTIONS; ++i) {
        int newAction = unitId * 100 + i; // ìœ ë‹› ê³ ìœ ì˜ ì•¡ì…˜ ìƒì„±
        bool success = false;

        while (!success) {
            // TODO 1: íì— ì ‘ê·¼í•˜ê¸° ìœ„í•´ í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ì— ì§„ì…í•˜ì„¸ìš”.
            // ...

            if (g_itemCount < MAX_QUEUE_SIZE) {
                // íì— ìë¦¬ê°€ ìˆì„ ë•Œì˜ ë¡œì§
                g_actionQueue[g_writeIndex] = newAction;
                g_writeIndex = (g_writeIndex + 1) % MAX_QUEUE_SIZE;
                g_itemCount++;
                printf("ìœ ë‹› %d: ì•¡ì…˜ %d íì— ë“±ë¡. (í˜„ì¬ %dê°œ)\n", unitId, newAction, g_itemCount);
                success = true;
            } else {
                // íê°€ ê°€ë“ ì°¼ì„ ë•Œì˜ ë¡œì§
                printf(">> ìœ ë‹› %d: íê°€ ê°€ë“ ì°¨ ë“±ë¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì ì‹œ ëŒ€ê¸°...\n", unitId);
            }

            // TODO 2: í ì ‘ê·¼ì´ ëë‚¬ìœ¼ë‹ˆ í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ì„ ë¹ ì ¸ë‚˜ì˜¤ì„¸ìš”.
            // ...

            if (!success) {
                Sleep(100); // íê°€ ê½‰ ì°¼ìœ¼ë©´ ì ì‹œ ëŒ€ê¸° í›„ ì¬ì‹œë„
            }
        }
        Sleep(rand() % 150); // ìƒˆë¡œìš´ ì•¡ì…˜ì„ ìƒê°í•˜ëŠ” ì‹œê°„
    }
    return 0;
}

// ì†Œë¹„ì: ê²Œì„ ì—”ì§„ ìŠ¤ë ˆë“œ
unsigned int __stdcall gameEngineThread(void* arg) {
    int totalActionsToProcess = NUM_UNITS * NUM_ACTIONS;
    int processedCount = 0;

    while (processedCount < totalActionsToProcess) {
        // TODO 3: íì— ì ‘ê·¼í•˜ê¸° ìœ„í•´ í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ì— ì§„ì…í•˜ì„¸ìš”.
        // ...

        if (g_itemCount > 0) {
            // íì— ì•„ì´í…œì´ ìˆì„ ë•Œì˜ ë¡œì§
            int action = g_actionQueue[g_readIndex];
            g_readIndex = (g_readIndex + 1) % MAX_QUEUE_SIZE;
            g_itemCount--;
            processedCount++;
            printf("ì—”ì§„: ì•¡ì…˜ %d ì²˜ë¦¬ ì™„ë£Œ. (ë‚¨ì€ %dê°œ, ì´ %dê°œ ì²˜ë¦¬)\n", action, g_itemCount, processedCount);
        } else {
            // íê°€ ë¹„ì–´ìˆì„ ë•Œì˜ ë¡œì§
            // (ì‹¤ì œ ì—”ì§„ì´ë¼ë©´ ëŒ€ê¸°í•˜ê² ì§€ë§Œ, ì—¬ê¸°ì„œëŠ” ë©”ì‹œì§€ë§Œ ì¶œë ¥)
        }

        // TODO 4: í ì ‘ê·¼ì´ ëë‚¬ìœ¼ë‹ˆ í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ì„ ë¹ ì ¸ë‚˜ì˜¤ì„¸ìš”.
        // ...

        Sleep(50); // í•œ ì•¡ì…˜ì„ ì²˜ë¦¬í•˜ëŠ”ë° ê±¸ë¦¬ëŠ” ì‹œê°„
    }
    return 0;
}


int main() 
{
    // TODO 5: í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ì„ ì´ˆê¸°í™”í•˜ì„¸ìš”.
    // ...

    std::vector<HANDLE> unitThreads;
    std::vector<int> unitIds;

    // ê²Œì„ ì—”ì§„ ìŠ¤ë ˆë“œ ì‹œì‘
    HANDLE hEngineThread = (HANDLE)_beginthreadex(NULL, 0, gameEngineThread, NULL, 0, NULL);
    
    // AI ìœ ë‹› ìŠ¤ë ˆë“œë“¤ ì‹œì‘
    for (int i = 0; i < NUM_UNITS; ++i) {
        unitIds.push_back(i + 1);
        unitThreads.push_back((HANDLE)_beginthreadex(NULL, 0, aiUnitThread, &unitIds.back(), 0, NULL));
    }

    WaitForMultipleObjects(unitThreads.size(), unitThreads.data(), TRUE, INFINITE);
    WaitForSingleObject(hEngineThread, INFINITE);
    
    for (HANDLE h : unitThreads) CloseHandle(h);
    CloseHandle(hEngineThread);

    // TODO 6: í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ì„ ì‚­ì œí•˜ì„¸ìš”.
    // ...

    printf("\nëª¨ë“  ê²Œì„ ì•¡ì…˜ ì²˜ë¦¬ ì™„ë£Œ.\n");
    return 0;
}
```

  
## ë¬¸ì œ 5: ì„¸ë§ˆí¬ì–´ ì‚¬ìš©í•˜ì§€ ì•Šê¸°  
ì•„ë˜ ì½”ë“œëŠ” ì„¸ë§ˆí¬ì–´ë¥¼ ì‚¬ìš©í•˜ì—¬ ì»¨ë„¥ì…˜í’€ì„ êµ¬í˜„í•˜ì˜€ë‹¤. ì´ê²ƒì„ í¬ë¦¬í‹°ì»¬ì„¹ì…˜ë§Œìœ¼ë¡œ êµ¬í˜„í•´ ë³´ì. DatabaseConnectionPool í´ë˜ìŠ¤ë§Œì„ ì¬êµ¬í˜„í•œë‹¤.     
  
DatabaseConnectionPool í´ë˜ìŠ¤ì—ì„œ ì„¸ë§ˆí¬ì–´(hAva ilableConnections)ë¥¼ ì™„ì „íˆ ì œê±°í•˜ê³ , ì˜¤ì§ í¬ë¦¬í‹°ì»¬ ì„¹ì…˜(cs)ë§Œì„ ì‚¬ìš©í•˜ì—¬ ì—°ê²°ì„ íšë“í•˜ê³  ë°˜ë‚©í•˜ëŠ” ë¡œì§ì„ ì¬êµ¬í˜„í•œë‹¤.
  
**ìš”êµ¬ì‚¬í•­**  
- DatabaseConnectionPool í´ë˜ìŠ¤ì—ì„œ hAvailableConnections ë©¤ë²„ ë³€ìˆ˜ì™€ ê´€ë ¨ëœ ëª¨ë“  ì½”ë“œ(CreateSemaphore, CloseHandle, WaitForSingleObject, ReleaseSemaphore)ë¥¼ ì‚­ì œí•´ì•¼ í•œë‹¤.
  
- AcquireConnection í•¨ìˆ˜ì—ì„œ ì‚¬ìš© ê°€ëŠ¥í•œ ì—°ê²°ì´ ì—†ì„ ê²½ìš°, ìŠ¤ë ˆë“œëŠ” ì„¸ë§ˆí¬ì–´ ëŒ€ê¸° ìƒíƒœì— ë“¤ì–´ê°€ëŠ” ëŒ€ì‹  **ì£¼ê¸°ì ìœ¼ë¡œ ì—°ê²°ì´ ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ë°©ì‹(í´ë§, Polling)**ìœ¼ë¡œ ëŒ€ê¸°í•´ì•¼ í•œë‹¤.
  
- ì´ ê³¼ì •ì—ì„œ ê³¼ë„í•œ CPU ì‚¬ìš©ì„ ë§‰ê¸° ìœ„í•´ ì ì ˆí•œ Sleep í•¨ìˆ˜ í˜¸ì¶œì„ í¬í•¨í•´ì•¼ í•œë‹¤.
  
- availableConnections íì— ëŒ€í•œ ì ‘ê·¼ì€ ì—¬ì „íˆ ìŠ¤ë ˆë“œë¡œë¶€í„° ì•ˆì „í•´ì•¼ í•œë‹¤.  
  
    
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <string>
#include <memory>
#include <process.h>
#include <windows.h> // Win32 API í—¤ë”

// ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° í’€ ì‹œë®¬ë ˆì´ì…˜
class DatabaseConnection
{
private:
    int connectionId;
    bool isConnected;

public:
    DatabaseConnection(int id) : connectionId(id), isConnected(false) {}

    bool Connect() 
    {
        Sleep(100);  // ì—°ê²° ì‹œë®¬ë ˆì´ì…˜
        isConnected = true;
        std::cout << "  ì—°ê²° " << connectionId << " í™œì„±í™”\n";
        return true;
    }

    void Disconnect() 
    {
        isConnected = false;
        Sleep(50);  // ì—°ê²° í•´ì œ ì‹œë®¬ë ˆì´ì…˜
        std::cout << "  ì—°ê²° " << connectionId << " ë¹„í™œì„±í™”\n";
    }

    void ExecuteQuery(const std::string& query) 
    {
        if (isConnected) 
        {
            std::cout << "  ì—°ê²° " << connectionId << "ì—ì„œ ì¿¼ë¦¬ ì‹¤í–‰: " << query << "\n";
            Sleep(500 + (rand() % 1000));  // ì¿¼ë¦¬ ì‹¤í–‰ ì‹œë®¬ë ˆì´ì…˜
        }
    }

    int GetId() const { return connectionId; }
};

class DatabaseConnectionPool
{
private:
    std::vector<std::unique_ptr<DatabaseConnection>> connections;
    std::queue<DatabaseConnection*> availableConnections;
    CRITICAL_SECTION cs;
    HANDLE hAvailableConnections;  // ì‚¬ìš© ê°€ëŠ¥í•œ ì—°ê²° ê°œìˆ˜

public:
    DatabaseConnectionPool(int poolSize) {
        InitializeCriticalSection(&cs);

        // ì´ˆê¸°ì—ëŠ” ëª¨ë“  ì—°ê²°ì´ ì‚¬ìš© ê°€ëŠ¥
        hAvailableConnections = CreateSemaphore(NULL, poolSize, poolSize, NULL);

        // ì—°ê²° ê°ì²´ë“¤ ìƒì„±
        for (int i = 0; i < poolSize; ++i) 
        {
            auto conn = std::make_unique<DatabaseConnection>(i + 1);
            conn->Connect();

            EnterCriticalSection(&cs);
            availableConnections.push(conn.get());
            connections.push_back(std::move(conn));
            LeaveCriticalSection(&cs);
        }

        std::cout << "ì—°ê²° í’€ ìƒì„± ì™„ë£Œ (í¬ê¸°: " << poolSize << ")\n\n";
    }

    ~DatabaseConnectionPool() 
    {
        // ëª¨ë“  ì—°ê²° í•´ì œ
        for (auto& conn : connections) 
        {
            conn->Disconnect();
        }

        DeleteCriticalSection(&cs);
        
        if (hAvailableConnections) CloseHandle(hAvailableConnections);
    }

    DatabaseConnection* AcquireConnection(DWORD timeout = INFINITE) 
    {
        // 1. ì‚¬ìš© ê°€ëŠ¥í•œ ì—°ê²°ì´ ìˆì„ ë•Œê¹Œì§€ ëŒ€ê¸°
        if (WaitForSingleObject(hAvailableConnections, timeout) != WAIT_OBJECT_0) {
            return nullptr;  // íƒ€ì„ì•„ì›ƒ
        }

        // 2. íì—ì„œ ì—°ê²° íšë“
        EnterCriticalSection(&cs);
        DatabaseConnection* conn = nullptr;
        if (!availableConnections.empty()) 
        {
            conn = availableConnections.front();
            availableConnections.pop();
        }
        LeaveCriticalSection(&cs);

        return conn;
    }

    void ReleaseConnection(DatabaseConnection* conn) 
    {
        if (!conn) return;

        // 1. íì— ì—°ê²° ë°˜ë‚©
        EnterCriticalSection(&cs);
        availableConnections.push(conn);
        LeaveCriticalSection(&cs);

        // 2. ì‚¬ìš© ê°€ëŠ¥í•œ ì—°ê²° ê°œìˆ˜ ì¦ê°€
        ReleaseSemaphore(hAvailableConnections, 1, NULL);
    }

    size_t GetAvailableCount() 
    {
        EnterCriticalSection(&cs);
        size_t count = availableConnections.size();
        LeaveCriticalSection(&cs);
        return count;
    }
};

// RAII íŒ¨í„´ìœ¼ë¡œ ìë™ í•´ì œ ë³´ì¥
class ScopedConnection 
{
private:
    DatabaseConnectionPool* pool;
    DatabaseConnection* connection;

public:
    ScopedConnection(DatabaseConnectionPool* p, DWORD timeout = INFINITE)
        : pool(p), connection(nullptr) 
    {
        connection = pool->AcquireConnection(timeout);
    }

    ~ScopedConnection() 
    {
        if (connection && pool) {
            pool->ReleaseConnection(connection);
        }
    }

    DatabaseConnection* Get() const { return connection; }
    bool IsValid() const { return connection != nullptr; }
};


// í´ë¼ì´ì–¸íŠ¸ ìŠ¤ë ˆë“œì— ì „ë‹¬í•  ë°ì´í„° êµ¬ì¡°ì²´
struct ClientThreadParams 
{
    DatabaseConnectionPool* pool;
    int clientId;
};

// í´ë¼ì´ì–¸íŠ¸ ìŠ¤ë ˆë“œ í•¨ìˆ˜
unsigned int __stdcall ClientThreadFunc(void* lpParam) 
{
    ClientThreadParams* params = static_cast<ClientThreadParams*>(lpParam);
    DatabaseConnectionPool* pool = params->pool;
    int clientId = params->clientId;

    std::cout << "í´ë¼ì´ì–¸íŠ¸ " << clientId << " ì‹œì‘\n";

    // RAII íŒ¨í„´ìœ¼ë¡œ ì—°ê²° ê´€ë¦¬
    ScopedConnection scopedConn(pool, 3000);  // 3ì´ˆ íƒ€ì„ì•„ì›ƒ

    if (scopedConn.IsValid()) {
        DatabaseConnection* conn = scopedConn.Get();
        std::cout << "í´ë¼ì´ì–¸íŠ¸ " << clientId << "ê°€ ì—°ê²° "
            << conn->GetId() << " íšë“\n";

        // ì—¬ëŸ¬ ì¿¼ë¦¬ ì‹¤í–‰
        conn->ExecuteQuery("SELECT * FROM users WHERE id = " + std::to_string(clientId));
        conn->ExecuteQuery("UPDATE stats SET count = count + 1");

        std::cout << "í´ë¼ì´ì–¸íŠ¸ " << clientId << " ì‘ì—… ì™„ë£Œ\n";
    }
    else 
    {
        std::cout << "í´ë¼ì´ì–¸íŠ¸ " << clientId << " ì—°ê²° íšë“ ì‹¤íŒ¨ (íƒ€ì„ì•„ì›ƒ)\n";
    }

    // scopedConnì´ ì†Œë©¸ë˜ë©´ì„œ ìë™ìœ¼ë¡œ ì—°ê²° ë°˜ë‚©

    delete params; // ìŠ¤ë ˆë“œë¡œ ì „ë‹¬ëœ ë°ì´í„° êµ¬ì¡°ì²´ ë©”ëª¨ë¦¬ í•´ì œ
    return 0;
}

// ëª¨ë‹ˆí„° ìŠ¤ë ˆë“œ í•¨ìˆ˜
DWORD WINAPI MonitorThreadFunc(LPVOID lpParam) 
{
    DatabaseConnectionPool* pool = static_cast<DatabaseConnectionPool*>(lpParam);
    for (int i = 0; i < 10; ++i) {
        Sleep(1000);
        std::cout << "[ëª¨ë‹ˆí„°] ì‚¬ìš© ê°€ëŠ¥í•œ ì—°ê²°: "
            << pool->GetAvailableCount() << "/3\n";
    }
    return 0;
}


// ì—°ê²° í’€ í…ŒìŠ¤íŠ¸
void TestConnectionPool()
{
    const int POOL_SIZE = 3;
    const int CLIENT_COUNT = 8;

    DatabaseConnectionPool pool(POOL_SIZE);
    std::vector<HANDLE> clientHandles; // ìŠ¤ë ˆë“œ í•¸ë“¤ì„ ì €ì¥í•  ë²¡í„°

    std::cout << "=== ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° í’€ í…ŒìŠ¤íŠ¸ ===\n";
    std::cout << "í’€ í¬ê¸°: " << POOL_SIZE << "\n";
    std::cout << "í´ë¼ì´ì–¸íŠ¸ ìˆ˜: " << CLIENT_COUNT << "\n\n";

    // í´ë¼ì´ì–¸íŠ¸ ìŠ¤ë ˆë“œ ìƒì„±
    for (int i = 0; i < CLIENT_COUNT; ++i) {
        // ìŠ¤ë ˆë“œì— ì „ë‹¬í•  íŒŒë¼ë¯¸í„°ë¥¼ ë™ì ìœ¼ë¡œ í• ë‹¹
        ClientThreadParams* params = new ClientThreadParams{ &pool, i };

        uintptr_t hThreadRaw = _beginthreadex(
            NULL,                   // ê¸°ë³¸ ë³´ì•ˆ ì†ì„±
            0,                      // ê¸°ë³¸ ìŠ¤íƒ í¬ê¸°
            ClientThreadFunc,       // ìŠ¤ë ˆë“œ í•¨ìˆ˜
            params,                 // ìŠ¤ë ˆë“œ í•¨ìˆ˜ì— ì „ë‹¬í•  ì¸ì
            0,                      // ì¦‰ì‹œ ì‹¤í–‰
            NULL                    // ìŠ¤ë ˆë“œ IDëŠ” ë°›ì§€ ì•ŠìŒ
        );

        if (hThreadRaw != 0) {
            clientHandles.push_back((HANDLE)hThreadRaw);
        }
    }

    // ëª¨ë‹ˆí„° ìŠ¤ë ˆë“œ ìƒì„±
    HANDLE hMonitorThread = CreateThread(NULL, 0, MonitorThreadFunc, &pool, 0, NULL);

    // ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ ìŠ¤ë ˆë“œê°€ ëë‚  ë•Œê¹Œì§€ ëŒ€ê¸°
    WaitForMultipleObjects(clientHandles.size(), clientHandles.data(), TRUE, INFINITE);

    // ëª¨ë‹ˆí„° ìŠ¤ë ˆë“œê°€ ëë‚  ë•Œê¹Œì§€ ëŒ€ê¸°
    if (hMonitorThread) 
    {
        WaitForSingleObject(hMonitorThread, INFINITE);
    }

    // ëª¨ë“  ìŠ¤ë ˆë“œ í•¸ë“¤ ë‹«ê¸°
    for (HANDLE h : clientHandles) 
    {
        CloseHandle(h);
    }
    
    if (hMonitorThread) 
    {
        CloseHandle(hMonitorThread);
    }

    std::cout << "\nëª¨ë“  í´ë¼ì´ì–¸íŠ¸ ì‘ì—… ì™„ë£Œ\n";
}

int main()
{
    srand(static_cast<unsigned int>(time(NULL))); // rand() í•¨ìˆ˜ ì‹œë“œ ì´ˆê¸°í™”
    TestConnectionPool();
    return 0;
}
``` 