# 4주차 과제    
  
## 🛡️ 문제 1: 공유 자원 '체력 물약' 사용하기

**문제 목적**
  - 여러 스레드가 공유 자원(체력 물약)에 동시에 접근할 때 발생하는 문제점(Race Condition)을 이해하고, `CRITICAL_SECTION`을 이용해 이를 해결하는 방법을 배운다.  

**문제 조건**
1.  `potion_count`는 모든 플레이어 스레드가 공유하는 전역 변수이다.
2.  `usePotion` 함수는 각 플레이어가 물약을 사용하는 행동을 묘사한다. 물약이 남아있으면 1개 사용하고, "Player X가 물약을 사용했습니다." 메시지를 출력한다.
3.  `CRITICAL_SECTION`을 사용하여 `potion_count`를 확인하고 감소시키는 코드를 보호해야 한다. 이를 통해 정확히 10개의 물약만 소모되도록 보장해야 한다.
  
**미완성 코드**  

```cpp
#include <iostream>
#include <windows.h>
#include <process.h>
#include <vector>

int potion_count = 10; // 공유 자원: 물약 10개
CRITICAL_SECTION cs;     // 크리티컬 섹션

unsigned int __stdcall usePotion(void* arg) {
    int playerId = *(int*)arg;

    // TODO: 크리티컬 섹션 시작
    // ...

    if (potion_count > 0) {
        Sleep(10); // 물약을 마시는 데 시간이 걸리는 것을 시뮬레이션
        potion_count--;
        printf("Player %d가 물약을 사용했습니다. 남은 물약: %d\n", playerId, potion_count);
    }

    // TODO: 크리티컬 섹션 끝
    // ...

    return 0;
}

int main() 
{
    const int NUM_PLAYERS = 20;
    std::vector<HANDLE> threads;
    std::vector<int> playerIds;

    // TODO: 크리티컬 섹션 초기화
    // ...

    for (int i = 0; i < NUM_PLAYERS; ++i) {
        playerIds.push_back(i + 1);
        HANDLE hThread = (HANDLE)_beginthreadex(NULL, 0, usePotion, &playerIds[i], 0, NULL);
        if (hThread) {
            threads.push_back(hThread);
        }
    }

    WaitForMultipleObjects(threads.size(), threads.data(), TRUE, INFINITE);

    for (HANDLE hThread : threads) {
        CloseHandle(hThread);
    }

    // TODO: 크리티컬 섹션 삭제
    // ...

    printf("최종 남은 물약 개수: %d\n", potion_count);

    return 0;
}
```

  
## 🐉 문제 2: 보스 몬스터 등장 동기화

**문제 목적**
  - 특정 작업(보스 몬스터 로딩)이 완료될 때까지 다른 스레드(플레이어들)가 기다리도록 만들어야 할 때, `Event` 객체를 사용한 스레드 간의 신호 동기화 방법을 학습한다.  
  
**문제 조건**
1.  `loadBoss` 스레드는 보스 몬스터를 로딩하는 역할이며, 3초의 시간이 걸린다.
2.  `enterBattle` 스레드들은 플레이어가 전투에 돌입하는 역할이다.
3.  플레이어들은 보스 로딩이 완료되기 전까지는 "보스 로딩을 기다리는 중..." 메시지를 출력하며 대기해야 한다.
4.  `loadBoss` 스레드는 로딩이 완료되면 `Event`를 `Set` 상태로 만들어 플레이어 스레드들에게 전투 시작을 알려야 한다.
5.  플레이어 스레드들은 `Event`가 `Set` 상태가 되면 대기를 멈추고 "전투 시작!" 메시지를 출력한다.

**미완성 코드**

```cpp
#include <iostream>
#include <windows.h>
#include <process.h>

HANDLE g_hBossReadyEvent; // 보스 준비 완료 이벤트

// 보스 몬스터를 로딩하는 스레드 함수
unsigned int __stdcall loadBoss(void* arg) {
    printf("보스 몬스터를 로딩 중입니다...\n");
    Sleep(3000); // 3초 동안 로딩
    printf("보스 로딩 완료!\n");

    // TODO: 보스 준비 완료 이벤트를 Set 상태로 만드세요.
    // ...

    return 0;
}

// 플레이어가 전투에 참여하는 스레드 함수
unsigned int __stdcall enterBattle(void* arg) {
    int playerId = *(int*)arg;
    printf("Player %d, 보스 로딩을 기다리는 중...\n", playerId);

    // TODO: 보스 준비 완료 이벤트가 Set 상태가 될 때까지 기다리세요.
    // ...

    printf("Player %d, 전투 시작!\n", playerId);
    return 0;
}

int main() 
{
    // TODO: Manual-reset, non-signaled 상태의 이벤트를 생성하세요.
    // g_hBossReadyEvent = CreateEvent(...);

    if (g_hBossReadyEvent == NULL) {
        printf("이벤트 생성 실패\n");
        return 1;
    }

    HANDLE hBossThread = (HANDLE)_beginthreadex(NULL, 0, loadBoss, NULL, 0, NULL);

    const int NUM_PLAYERS = 5;
    HANDLE hPlayerThreads[NUM_PLAYERS];
    int playerIds[NUM_PLAYERS];
    for (int i = 0; i < NUM_PLAYERS; ++i) {
        playerIds[i] = i + 1;
        hPlayerThreads[i] = (HANDLE)_beginthreadex(NULL, 0, enterBattle, &playerIds[i], 0, NULL);
    }

    WaitForSingleObject(hBossThread, INFINITE);
    WaitForMultipleObjects(NUM_PLAYERS, hPlayerThreads, TRUE, INFINITE);

    CloseHandle(hBossThread);
    for (int i = 0; i < NUM_PLAYERS; ++i) {
        CloseHandle(hPlayerThreads[i]);
    }
    // TODO: 생성한 이벤트를 닫으세요.
    // ...

    return 0;
}
```    
    
    
    
## 🚀 문제 3: 골드 광산 동시 채굴

**문제 목적**
  - 여러 스레드가 동시에 하나의 공유 변수(총 골드량)를 수정할 때 발생하는 **경쟁 상태(Race Condition)**를 직접 확인하고, `CRITICAL_SECTION`을 이용해 데이터의 무결성을 보장하는 방법을 학습한다.  
  
**문제 시나리오**
여러 명의 광부(`Miner` 스레드)가 하나의 광산에서 동시에 골드를 채굴한다. 각 광부는 자신이 캔 골드를 팀의 공유 창고(`g_totalGold`)에 추가한다. 만약 여러 광부가 '동시에' 창고에 골드를 추가하려고 하면, 계산이 꼬여서 최종 골드량이 실제 채굴한 양보다 적어지는 문제가 발생할 수 있다.  
  
**문제 조건**
1.  `g_totalGold`는 모든 광부 스레드가 공유하는 전역 변수이다.  
2.  `mineGold` 함수는 각 광부 스레드가 실행할 함수이다.  
3.  각 광부는 10 골드씩, 총 5번 채굴하여 `g_totalGold`에 추가해야 한다.  
4.  골드를 추가하는 과정(`g_totalGold` 값을 읽고, 더하고, 다시 쓰는 과정)은 반드시 **`CRITICAL_SECTION`**으로 보호되어야 한다.
5.  `NUM_MINERS`는 5명, 각 광부가 10골드씩 5번 채굴하므로, 모든 작업이 끝났을 때 `g_totalGold`는 정확히 **250**이 되어야 한다. (5명 * 10골드 * 5회)

**미완성 코드**

```cpp
#include <iostream>
#include <windows.h>
#include <process.h>
#include <vector>

#define NUM_MINERS 5
#define GOLD_PER_TRIAL 10
#define NUM_TRIALS 5

int g_totalGold = 0; // 공유 자원: 팀의 총 골드
CRITICAL_SECTION cs_gold;

// 광부 스레드가 실행할 함수
unsigned int __stdcall mineGold(void* arg) {
    int minerId = *(int*)arg;

    for (int i = 0; i < NUM_TRIALS; ++i) {
        // 골드를 채굴하는 시간 시뮬레이션
        Sleep(10); 
        
        // TODO 1: g_totalGold에 접근하기 전, 크리티컬 섹션에 진입하세요.
        // ...

        // --- 경쟁 상태가 발생하는 구간 ---
        int currentGold = g_totalGold; // 1. 현재 골드량을 읽는다.
        printf("광부 %d, 현재 골드량 %d 확인 후 10골드 추가 시도...\n", minerId, currentGold);
        currentGold += GOLD_PER_TRIAL; // 2. 캔 골드를 더한다.
        Sleep(5); // 다른 스레드가 끼어들 수 있는 시간적인 틈을 만듦
        g_totalGold = currentGold;     // 3. 새로운 골드량으로 덮어쓴다.
        // ---------------------------------
        
        // TODO 2: g_totalGold 접근이 끝났으니, 크리티컬 섹션에서 빠져나오세요.
        // ...
    }
    return 0;
}

int main() 
{
    // TODO 3: main 함수 시작 시, 크리티컬 섹션을 초기화하세요.
    // ...

    std::vector<HANDLE> threads;
    std::vector<int> minerIds;

    printf("--- %d명의 광부가 채굴을 시작합니다! ---\n", NUM_MINERS);
    printf("기대 결과값: %d\n\n", NUM_MINERS * GOLD_PER_TRIAL * NUM_TRIALS);

    for (int i = 0; i < NUM_MINERS; ++i) {
        minerIds.push_back(i + 1);
        threads.push_back((HANDLE)_beginthreadex(NULL, 0, mineGold, &minerIds.back(), 0, NULL));
    }

    //TODO 4. 모든 스레드가 작업을 마칠 때까지 대기
    // ...

    for (HANDLE h : threads) {
        CloseHandle(h);
    }

    // TODO 5: main 함수 종료 전, 크리티컬 섹션 리소스를 삭제하세요.
    // ...

    printf("\n--- 모든 채굴 작업 완료! ---\n");
    printf("최종 골드량: %d\n", g_totalGold);

    return 0;
}
```  

    
  
## 🚀 문제 4: 실시간 게임 액션 큐(Queue) 처리

**문제 목적**
  - 여러 스레드(생산자, 소비자)가 고정된 크기의 공유 버퍼(큐)에 데이터를 추가하고 제거하는 **생산자-소비자(Producer-Consumer) 패턴**을 구현한다.
  - 큐가 가득 찼을 때(Full)와 비어있을 때(Empty)의 예외 상황을 올바르게 처리하며, 큐의 상태를 나타내는 여러 변수(데이터 배열, 인덱스, 카운트)를 `CRITICAL_SECTION`으로 한 번에 묶어 보호하는 방법을 학습한다.

**문제 시나리오**
실시간 전략 게임(RTS)에서는 플레이어의 수많은 유닛들이 각자의 행동(이동, 공격, 스킬 사용 등)을 수행한다. 이 문제에서는 여러 'AI 유닛' 스레드가 자신의 다음 행동을 결정하여 중앙 '액션 큐'에 등록하고(생산자), '게임 엔진' 스레드는 이 큐에서 행동을 순서대로 꺼내어 처리(소비자)하는 상황을 시뮬레이션한다. 큐의 크기는 한정되어 있어, 큐가 꽉 차면 유닛은 잠시 대기해야 하고, 큐가 비어있으면 엔진은 할 일이 생길 때까지 기다려야 한다.

**문제 조건**

1.  **공유 자원**은 다음과 같다.
      * `g_actionQueue`: 액션(int로 표현)을 저장하는 고정 크기 배열.
      * `g_itemCount`: 큐에 저장된 액션의 개수.
      * `g_writeIndex`, `g_readIndex`: 데이터를 쓰고 읽을 위치를 가리키는 인덱스 (순환 큐 형태).
2.  **`aiUnitThread` (생산자):**
      * 주기적으로 새로운 액션을 생성한다.
      * 액션을 큐에 추가하기 전, **`CRITICAL_SECTION`**에 진입해야 한다.
      * 큐가 **가득 찼는지(`g_itemCount == MAX_QUEUE_SIZE`)** 확인한다.
      * 만약 가득 찼다면, "큐가 가득 차 등록에 실패했습니다." 메시지를 출력하고, 크리티컬 섹션을 빠져나와 잠시 대기(`Sleep`)한 후 재시도해야 한다.
      * 자리가 있다면, 액션을 추가하고 `g_writeIndex`와 `g_itemCount`를 갱신한다.
      * 작업이 끝나면 크리티컬 섹션을 빠져나온다.
3.  **`gameEngineThread` (소비자):**
      * 주기적으로 큐에서 액션을 가져와 처리한다.
      * 액션을 가져오기 전, **`CRITICAL_SECTION`**에 진입해야 한다.
      * 큐가 **비어있는지(`g_itemCount == 0`)** 확인한다.
      * 만약 비어있다면, "처리할 액션이 없습니다." 메시지를 출력하고, 크리티컬 섹션을 빠져나와 잠시 대기한 후 재시도해야 한다.
      * 처리할 액션이 있다면, 액션을 꺼내고 `g_readIndex`와 `g_itemCount`를 갱신한다.
      * 작업이 끝나면 크리티컬 섹션을 빠져나온다.
  
**미완성 코드**
  
```cpp
#include <iostream>
#include <windows.h>
#include <process.h>
#include <vector>

#define MAX_QUEUE_SIZE 8
#define NUM_UNITS 3      // 생산자 스레드 수
#define NUM_ACTIONS 7    // 각 유닛이 생성할 액션 수

// --- 공유 자원 ---
int g_actionQueue[MAX_QUEUE_SIZE];
int g_itemCount = 0;
int g_writeIndex = 0;
int g_readIndex = 0;
CRITICAL_SECTION cs_queue;

// 생산자: AI 유닛 스레드
unsigned int __stdcall aiUnitThread(void* arg) {
    int unitId = *(int*)arg;
    srand(unitId); // 각 스레드마다 다른 시드값 부여

    for (int i = 0; i < NUM_ACTIONS; ++i) {
        int newAction = unitId * 100 + i; // 유닛 고유의 액션 생성
        bool success = false;

        while (!success) {
            // TODO 1: 큐에 접근하기 위해 크리티컬 섹션에 진입하세요.
            // ...

            if (g_itemCount < MAX_QUEUE_SIZE) {
                // 큐에 자리가 있을 때의 로직
                g_actionQueue[g_writeIndex] = newAction;
                g_writeIndex = (g_writeIndex + 1) % MAX_QUEUE_SIZE;
                g_itemCount++;
                printf("유닛 %d: 액션 %d 큐에 등록. (현재 %d개)\n", unitId, newAction, g_itemCount);
                success = true;
            } else {
                // 큐가 가득 찼을 때의 로직
                printf(">> 유닛 %d: 큐가 가득 차 등록에 실패했습니다. 잠시 대기...\n", unitId);
            }

            // TODO 2: 큐 접근이 끝났으니 크리티컬 섹션을 빠져나오세요.
            // ...

            if (!success) {
                Sleep(100); // 큐가 꽉 찼으면 잠시 대기 후 재시도
            }
        }
        Sleep(rand() % 150); // 새로운 액션을 생각하는 시간
    }
    return 0;
}

// 소비자: 게임 엔진 스레드
unsigned int __stdcall gameEngineThread(void* arg) {
    int totalActionsToProcess = NUM_UNITS * NUM_ACTIONS;
    int processedCount = 0;

    while (processedCount < totalActionsToProcess) {
        // TODO 3: 큐에 접근하기 위해 크리티컬 섹션에 진입하세요.
        // ...

        if (g_itemCount > 0) {
            // 큐에 아이템이 있을 때의 로직
            int action = g_actionQueue[g_readIndex];
            g_readIndex = (g_readIndex + 1) % MAX_QUEUE_SIZE;
            g_itemCount--;
            processedCount++;
            printf("엔진: 액션 %d 처리 완료. (남은 %d개, 총 %d개 처리)\n", action, g_itemCount, processedCount);
        } else {
            // 큐가 비어있을 때의 로직
            // (실제 엔진이라면 대기하겠지만, 여기서는 메시지만 출력)
        }

        // TODO 4: 큐 접근이 끝났으니 크리티컬 섹션을 빠져나오세요.
        // ...

        Sleep(50); // 한 액션을 처리하는데 걸리는 시간
    }
    return 0;
}


int main() 
{
    // TODO 5: 크리티컬 섹션을 초기화하세요.
    // ...

    std::vector<HANDLE> unitThreads;
    std::vector<int> unitIds;

    // 게임 엔진 스레드 시작
    HANDLE hEngineThread = (HANDLE)_beginthreadex(NULL, 0, gameEngineThread, NULL, 0, NULL);
    
    // AI 유닛 스레드들 시작
    for (int i = 0; i < NUM_UNITS; ++i) {
        unitIds.push_back(i + 1);
        unitThreads.push_back((HANDLE)_beginthreadex(NULL, 0, aiUnitThread, &unitIds.back(), 0, NULL));
    }

    WaitForMultipleObjects(unitThreads.size(), unitThreads.data(), TRUE, INFINITE);
    WaitForSingleObject(hEngineThread, INFINITE);
    
    for (HANDLE h : unitThreads) CloseHandle(h);
    CloseHandle(hEngineThread);

    // TODO 6: 크리티컬 섹션을 삭제하세요.
    // ...

    printf("\n모든 게임 액션 처리 완료.\n");
    return 0;
}
```

  
## 문제 5: 세마포어 사용하지 않기  
아래 코드는 세마포어를 사용하여 컨넥션풀을 구현하였다. 이것을 크리티컬섹션만으로 구현해 보자. DatabaseConnectionPool 클래스만을 재구현한다.     
  
DatabaseConnectionPool 클래스에서 세마포어(hAva ilableConnections)를 완전히 제거하고, 오직 크리티컬 섹션(cs)만을 사용하여 연결을 획득하고 반납하는 로직을 재구현한다.
  
**요구사항**  
- DatabaseConnectionPool 클래스에서 hAvailableConnections 멤버 변수와 관련된 모든 코드(CreateSemaphore, CloseHandle, WaitForSingleObject, ReleaseSemaphore)를 삭제해야 한다.
  
- AcquireConnection 함수에서 사용 가능한 연결이 없을 경우, 스레드는 세마포어 대기 상태에 들어가는 대신 **주기적으로 연결이 있는지 확인하는 방식(폴링, Polling)**으로 대기해야 한다.
  
- 이 과정에서 과도한 CPU 사용을 막기 위해 적절한 Sleep 함수 호출을 포함해야 한다.
  
- availableConnections 큐에 대한 접근은 여전히 스레드로부터 안전해야 한다.  
  
    
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <string>
#include <memory>
#include <process.h>
#include <windows.h> // Win32 API 헤더

// 데이터베이스 연결 풀 시뮬레이션
class DatabaseConnection
{
private:
    int connectionId;
    bool isConnected;

public:
    DatabaseConnection(int id) : connectionId(id), isConnected(false) {}

    bool Connect() 
    {
        Sleep(100);  // 연결 시뮬레이션
        isConnected = true;
        std::cout << "  연결 " << connectionId << " 활성화\n";
        return true;
    }

    void Disconnect() 
    {
        isConnected = false;
        Sleep(50);  // 연결 해제 시뮬레이션
        std::cout << "  연결 " << connectionId << " 비활성화\n";
    }

    void ExecuteQuery(const std::string& query) 
    {
        if (isConnected) 
        {
            std::cout << "  연결 " << connectionId << "에서 쿼리 실행: " << query << "\n";
            Sleep(500 + (rand() % 1000));  // 쿼리 실행 시뮬레이션
        }
    }

    int GetId() const { return connectionId; }
};

class DatabaseConnectionPool
{
private:
    std::vector<std::unique_ptr<DatabaseConnection>> connections;
    std::queue<DatabaseConnection*> availableConnections;
    CRITICAL_SECTION cs;
    HANDLE hAvailableConnections;  // 사용 가능한 연결 개수

public:
    DatabaseConnectionPool(int poolSize) {
        InitializeCriticalSection(&cs);

        // 초기에는 모든 연결이 사용 가능
        hAvailableConnections = CreateSemaphore(NULL, poolSize, poolSize, NULL);

        // 연결 객체들 생성
        for (int i = 0; i < poolSize; ++i) 
        {
            auto conn = std::make_unique<DatabaseConnection>(i + 1);
            conn->Connect();

            EnterCriticalSection(&cs);
            availableConnections.push(conn.get());
            connections.push_back(std::move(conn));
            LeaveCriticalSection(&cs);
        }

        std::cout << "연결 풀 생성 완료 (크기: " << poolSize << ")\n\n";
    }

    ~DatabaseConnectionPool() 
    {
        // 모든 연결 해제
        for (auto& conn : connections) 
        {
            conn->Disconnect();
        }

        DeleteCriticalSection(&cs);
        
        if (hAvailableConnections) CloseHandle(hAvailableConnections);
    }

    DatabaseConnection* AcquireConnection(DWORD timeout = INFINITE) 
    {
        // 1. 사용 가능한 연결이 있을 때까지 대기
        if (WaitForSingleObject(hAvailableConnections, timeout) != WAIT_OBJECT_0) {
            return nullptr;  // 타임아웃
        }

        // 2. 큐에서 연결 획득
        EnterCriticalSection(&cs);
        DatabaseConnection* conn = nullptr;
        if (!availableConnections.empty()) 
        {
            conn = availableConnections.front();
            availableConnections.pop();
        }
        LeaveCriticalSection(&cs);

        return conn;
    }

    void ReleaseConnection(DatabaseConnection* conn) 
    {
        if (!conn) return;

        // 1. 큐에 연결 반납
        EnterCriticalSection(&cs);
        availableConnections.push(conn);
        LeaveCriticalSection(&cs);

        // 2. 사용 가능한 연결 개수 증가
        ReleaseSemaphore(hAvailableConnections, 1, NULL);
    }

    size_t GetAvailableCount() 
    {
        EnterCriticalSection(&cs);
        size_t count = availableConnections.size();
        LeaveCriticalSection(&cs);
        return count;
    }
};

// RAII 패턴으로 자동 해제 보장
class ScopedConnection 
{
private:
    DatabaseConnectionPool* pool;
    DatabaseConnection* connection;

public:
    ScopedConnection(DatabaseConnectionPool* p, DWORD timeout = INFINITE)
        : pool(p), connection(nullptr) 
    {
        connection = pool->AcquireConnection(timeout);
    }

    ~ScopedConnection() 
    {
        if (connection && pool) {
            pool->ReleaseConnection(connection);
        }
    }

    DatabaseConnection* Get() const { return connection; }
    bool IsValid() const { return connection != nullptr; }
};


// 클라이언트 스레드에 전달할 데이터 구조체
struct ClientThreadParams 
{
    DatabaseConnectionPool* pool;
    int clientId;
};

// 클라이언트 스레드 함수
unsigned int __stdcall ClientThreadFunc(void* lpParam) 
{
    ClientThreadParams* params = static_cast<ClientThreadParams*>(lpParam);
    DatabaseConnectionPool* pool = params->pool;
    int clientId = params->clientId;

    std::cout << "클라이언트 " << clientId << " 시작\n";

    // RAII 패턴으로 연결 관리
    ScopedConnection scopedConn(pool, 3000);  // 3초 타임아웃

    if (scopedConn.IsValid()) {
        DatabaseConnection* conn = scopedConn.Get();
        std::cout << "클라이언트 " << clientId << "가 연결 "
            << conn->GetId() << " 획득\n";

        // 여러 쿼리 실행
        conn->ExecuteQuery("SELECT * FROM users WHERE id = " + std::to_string(clientId));
        conn->ExecuteQuery("UPDATE stats SET count = count + 1");

        std::cout << "클라이언트 " << clientId << " 작업 완료\n";
    }
    else 
    {
        std::cout << "클라이언트 " << clientId << " 연결 획득 실패 (타임아웃)\n";
    }

    // scopedConn이 소멸되면서 자동으로 연결 반납

    delete params; // 스레드로 전달된 데이터 구조체 메모리 해제
    return 0;
}

// 모니터 스레드 함수
DWORD WINAPI MonitorThreadFunc(LPVOID lpParam) 
{
    DatabaseConnectionPool* pool = static_cast<DatabaseConnectionPool*>(lpParam);
    for (int i = 0; i < 10; ++i) {
        Sleep(1000);
        std::cout << "[모니터] 사용 가능한 연결: "
            << pool->GetAvailableCount() << "/3\n";
    }
    return 0;
}


// 연결 풀 테스트
void TestConnectionPool()
{
    const int POOL_SIZE = 3;
    const int CLIENT_COUNT = 8;

    DatabaseConnectionPool pool(POOL_SIZE);
    std::vector<HANDLE> clientHandles; // 스레드 핸들을 저장할 벡터

    std::cout << "=== 데이터베이스 연결 풀 테스트 ===\n";
    std::cout << "풀 크기: " << POOL_SIZE << "\n";
    std::cout << "클라이언트 수: " << CLIENT_COUNT << "\n\n";

    // 클라이언트 스레드 생성
    for (int i = 0; i < CLIENT_COUNT; ++i) {
        // 스레드에 전달할 파라미터를 동적으로 할당
        ClientThreadParams* params = new ClientThreadParams{ &pool, i };

        uintptr_t hThreadRaw = _beginthreadex(
            NULL,                   // 기본 보안 속성
            0,                      // 기본 스택 크기
            ClientThreadFunc,       // 스레드 함수
            params,                 // 스레드 함수에 전달할 인자
            0,                      // 즉시 실행
            NULL                    // 스레드 ID는 받지 않음
        );

        if (hThreadRaw != 0) {
            clientHandles.push_back((HANDLE)hThreadRaw);
        }
    }

    // 모니터 스레드 생성
    HANDLE hMonitorThread = CreateThread(NULL, 0, MonitorThreadFunc, &pool, 0, NULL);

    // 모든 클라이언트 스레드가 끝날 때까지 대기
    WaitForMultipleObjects(clientHandles.size(), clientHandles.data(), TRUE, INFINITE);

    // 모니터 스레드가 끝날 때까지 대기
    if (hMonitorThread) 
    {
        WaitForSingleObject(hMonitorThread, INFINITE);
    }

    // 모든 스레드 핸들 닫기
    for (HANDLE h : clientHandles) 
    {
        CloseHandle(h);
    }
    
    if (hMonitorThread) 
    {
        CloseHandle(hMonitorThread);
    }

    std::cout << "\n모든 클라이언트 작업 완료\n";
}

int main()
{
    srand(static_cast<unsigned int>(time(NULL))); // rand() 함수 시드 초기화
    TestConnectionPool();
    return 0;
}
``` 