# Thread Local Storage (TLS) í™œìš©

## TLSì˜ ê°œë…ê³¼ í•„ìš”ì„±
ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œ ê° ìŠ¤ë ˆë“œëŠ” ë…ë¦½ì ì¸ ì‹¤í–‰ ì»¨í…ìŠ¤íŠ¸ë¥¼ ê°€ì§€ì§€ë§Œ, ì „ì—­ ë³€ìˆ˜ë‚˜ static ë³€ìˆ˜ëŠ” ëª¨ë“  ìŠ¤ë ˆë“œê°€ ê³µìœ í•©ë‹ˆë‹¤. ë•Œë¡œëŠ” ê° ìŠ¤ë ˆë“œë§ˆë‹¤ ê³ ìœ í•œ ë°ì´í„°ë¥¼ ìœ ì§€í•´ì•¼ í•  í•„ìš”ê°€ ìˆëŠ”ë°, ì´ë•Œ Thread Local Storage(TLS)ë¥¼ ì‚¬ìš©í•œë‹¤.

TLSëŠ” ê° ìŠ¤ë ˆë“œê°€ ìì‹ ë§Œì˜ ê³ ìœ í•œ ë°ì´í„° ë³µì‚¬ë³¸ì„ ê°€ì§ˆ ìˆ˜ ìˆê²Œ í•´ì£¼ëŠ” ë©”ì»¤ë‹ˆì¦˜ì´ë‹¤. ë™ì¼í•œ TLS ì¸ë±ìŠ¤ë¥¼ ì‚¬ìš©í•˜ë”ë¼ë„ ê° ìŠ¤ë ˆë“œëŠ” ì„œë¡œ ë‹¤ë¥¸ ê°’ì„ ì €ì¥í•˜ê³  ì½ì–´ì˜¬ ìˆ˜ ìˆë‹¤.
  
**TLSê°€ í•„ìš”í•œ ê²½ìš°:**

ìŠ¤ë ˆë“œë³„ë¡œ ê³ ìœ í•œ ìƒíƒœ ì •ë³´ë¥¼ ìœ ì§€í•´ì•¼ í•  ë•Œ TLSê°€ ìœ ìš©í•˜ë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ê° ìŠ¤ë ˆë“œê°€ ìì‹ ë§Œì˜ ì—ëŸ¬ ì½”ë“œë¥¼ ê´€ë¦¬í•˜ê±°ë‚˜, ìŠ¤ë ˆë“œë³„ í†µê³„ ì •ë³´ë¥¼ ìˆ˜ì§‘í•˜ê±°ë‚˜, ìŠ¤ë ˆë“œë³„ ìºì‹œë¥¼ ìœ ì§€í•´ì•¼ í•˜ëŠ” ê²½ìš°ì´ë‹¤. ë˜í•œ ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œ ë™ê¸°í™” ì˜¤ë²„í—¤ë“œ ì—†ì´ ìŠ¤ë ˆë“œë³„ ë°ì´í„°ì— ì ‘ê·¼í•´ì•¼ í•  ë•Œë„ TLSë¥¼ í™œìš©í•œë‹¤.
  

## Win32 TLS API
Win32ëŠ” ë™ì  TLSë¥¼ ìœ„í•œ ë„¤ ê°€ì§€ ì£¼ìš” APIë¥¼ ì œê³µí•œë‹¤.  
  
**TlsAlloc()**: TLS ìŠ¬ë¡¯ì„ í• ë‹¹í•œë‹¤. ì„±ê³µ ì‹œ TLS ì¸ë±ìŠ¤ë¥¼ ë°˜í™˜í•˜ê³ , ì‹¤íŒ¨ ì‹œ TLS_OUT_OF_INDEXESë¥¼ ë°˜í™˜í•œë‹¤. ì‹œìŠ¤í…œì€ í”„ë¡œì„¸ìŠ¤ë‹¹ ìµœì†Œ 64ê°œì˜ TLS ìŠ¬ë¡¯ì„ ë³´ì¥í•˜ë©°, Windows Vista ì´í›„ì—ëŠ” 1088ê°œê¹Œì§€ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

**TlsSetValue()**: í˜„ì¬ ìŠ¤ë ˆë“œì˜ TLS ìŠ¬ë¡¯ì— ê°’ì„ ì €ì¥í•œë‹¤. ì²« ë²ˆì§¸ ë§¤ê°œë³€ìˆ˜ëŠ” TLS ì¸ë±ìŠ¤ì´ê³ , ë‘ ë²ˆì§¸ ë§¤ê°œë³€ìˆ˜ëŠ” ì €ì¥í•  í¬ì¸í„° ê°’ì´ë‹¤. ì„±ê³µ ì‹œ TRUEë¥¼ ë°˜í™˜í•œë‹¤.

**TlsGetValue()**: í˜„ì¬ ìŠ¤ë ˆë“œì˜ TLS ìŠ¬ë¡¯ì—ì„œ ê°’ì„ ì½ì–´ì˜¨ë‹¤. TLS ì¸ë±ìŠ¤ë¥¼ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ì•„ ì €ì¥ëœ í¬ì¸í„° ê°’ì„ ë°˜í™˜í•œë‹¤. ê°’ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ê±°ë‚˜ ëª…ì‹œì ìœ¼ë¡œ NULLì´ ì €ì¥ëœ ê²½ìš° NULLì„ ë°˜í™˜í•œë‹¤.

**TlsFree()**: TLS ìŠ¬ë¡¯ì„ í•´ì œí•œë‹¤. ëª¨ë“  ìŠ¤ë ˆë“œì—ì„œ í•´ë‹¹ ì¸ë±ìŠ¤ì˜ ê°’ì´ ì´ˆê¸°í™”ë˜ë©°, ì¸ë±ìŠ¤ëŠ” ì¬ì‚¬ìš© ê°€ëŠ¥í•˜ê²Œ ëœë‹¤.
  

## TLS ì‚¬ìš© íŒ¨í„´
TLSë¥¼ ì‚¬ìš©í•˜ëŠ” ì¼ë°˜ì ì¸ íŒ¨í„´ì€ ë‹¤ìŒê³¼ ê°™ë‹¤. 
- ë¨¼ì € í”„ë¡œê·¸ë¨ ì‹œì‘ ì‹œ TlsAlloc()ìœ¼ë¡œ TLS ì¸ë±ìŠ¤ë¥¼ í• ë‹¹í•œë‹¤. 
- ê° ìŠ¤ë ˆë“œëŠ” ì‹œì‘í•  ë•Œ ìì‹ ì˜ ë°ì´í„°ë¥¼ í• ë‹¹í•˜ê³  TlsSetValue()ë¡œ ì €ì¥í•œë‹¤. 
- ìŠ¤ë ˆë“œ ì‹¤í–‰ ì¤‘ì—ëŠ” TlsGetValue()ë¡œ ë°ì´í„°ë¥¼ ì½ì–´ì˜¤ê³  ì‚¬ìš©í•œë‹¤. 
- ìŠ¤ë ˆë“œ ì¢…ë£Œ ì‹œì—ëŠ” í• ë‹¹í•œ ë©”ëª¨ë¦¬ë¥¼ í•´ì œí•˜ê³ , í”„ë¡œê·¸ë¨ ì¢…ë£Œ ì‹œì—ëŠ” TlsFree()ë¡œ TLS ì¸ë±ìŠ¤ë¥¼ í•´ì œí•œë‹¤.  
  

## ì‹¤ìŠµ ì˜ˆì œ: ìŠ¤ë ˆë“œë³„ í†µê³„ ìˆ˜ì§‘ê¸°
ë‹¤ìŒ ì˜ˆì œëŠ” ì—¬ëŸ¬ ì‘ì—… ìŠ¤ë ˆë“œê°€ ê°ìì˜ ì‘ì—… í†µê³„ë¥¼ ìˆ˜ì§‘í•˜ëŠ” ì‹œìŠ¤í…œì„ êµ¬í˜„í•œë‹¤. ê° ìŠ¤ë ˆë“œëŠ” ì²˜ë¦¬í•œ ì‘ì—… ìˆ˜ì™€ ì´ ì²˜ë¦¬ ì‹œê°„ì„ ë…ë¦½ì ìœ¼ë¡œ ê´€ë¦¬í•œë‹¤.  
  
```cpp
#include <windows.h>
#include <iostream>
#include <vector>
#include <random>

// ìŠ¤ë ˆë“œë³„ í†µê³„ ì •ë³´ êµ¬ì¡°ì²´
struct ThreadStatistics {
    DWORD threadId;
    int taskCount;          // ì²˜ë¦¬í•œ ì‘ì—… ìˆ˜
    ULONGLONG totalTime;    // ì´ ì²˜ë¦¬ ì‹œê°„ (ë°€ë¦¬ì´ˆ)
    ULONGLONG startTime;    // ìŠ¤ë ˆë“œ ì‹œì‘ ì‹œê°„
    
    ThreadStatistics() : threadId(0), taskCount(0), totalTime(0), startTime(0) {}
};

// ì „ì—­ TLS ì¸ë±ìŠ¤
DWORD g_tlsIndex = TLS_OUT_OF_INDEXES;

// ì‘ì—… í ì‹œë®¬ë ˆì´ì…˜ì„ ìœ„í•œ ì „ì—­ ë³€ìˆ˜
CRITICAL_SECTION g_csTaskQueue;
int g_remainingTasks = 100;

// TLS ì´ˆê¸°í™” í•¨ìˆ˜
bool InitializeThreadStatistics() {
    ThreadStatistics* pStats = new ThreadStatistics();
    if (pStats == nullptr) {
        return false;
    }
    
    pStats->threadId = GetCurrentThreadId();
    pStats->startTime = GetTickCount64();
    
    if (!TlsSetValue(g_tlsIndex, pStats)) {
        delete pStats;
        return false;
    }
    
    return true;
}

// TLSì—ì„œ í†µê³„ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
ThreadStatistics* GetThreadStatistics() {
    return static_cast<ThreadStatistics*>(TlsGetValue(g_tlsIndex));
}

// TLS ì •ë¦¬ í•¨ìˆ˜
void CleanupThreadStatistics() {
    ThreadStatistics* pStats = GetThreadStatistics();
    if (pStats != nullptr) {
        delete pStats;
        TlsSetValue(g_tlsIndex, nullptr);
    }
}

// ì‘ì—… ì²˜ë¦¬ í•¨ìˆ˜ (ì‹œë®¬ë ˆì´ì…˜)
void ProcessTask() {
    ThreadStatistics* pStats = GetThreadStatistics();
    if (pStats == nullptr) return;
    
    // ì‘ì—… ì‹œì‘ ì‹œê°„ ê¸°ë¡
    ULONGLONG taskStartTime = GetTickCount64();
    
    // ì‘ì—… ì‹œë®¬ë ˆì´ì…˜ (10-50msì˜ ëœë¤ ì‘ì—… ì‹œê°„)
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(10, 50);
    Sleep(dis(gen));
    
    // ì‘ì—… ì™„ë£Œ í›„ í†µê³„ ì—…ë°ì´íŠ¸
    ULONGLONG taskDuration = GetTickCount64() - taskStartTime;
    pStats->taskCount++;
    pStats->totalTime += taskDuration;
}

// ì‘ì—…ì ìŠ¤ë ˆë“œ í•¨ìˆ˜
DWORD WINAPI WorkerThread(LPVOID lpParam) {
    // ìŠ¤ë ˆë“œë³„ í†µê³„ ì´ˆê¸°í™”
    if (!InitializeThreadStatistics()) {
        std::cerr << "TLS ì´ˆê¸°í™” ì‹¤íŒ¨" << std::endl;
        return 1;
    }
    
    ThreadStatistics* pStats = GetThreadStatistics();
    std::cout << "ìŠ¤ë ˆë“œ " << pStats->threadId << " ì‹œì‘" << std::endl;
    
    // ì‘ì—… ì²˜ë¦¬ ë£¨í”„
    while (true) {
        int taskId = -1;
        
        // ì‘ì—… íì—ì„œ ì‘ì—… ê°€ì ¸ì˜¤ê¸°
        EnterCriticalSection(&g_csTaskQueue);
        if (g_remainingTasks > 0) {
            taskId = 101 - g_remainingTasks;
            g_remainingTasks--;
        }
        LeaveCriticalSection(&g_csTaskQueue);
        
        // ë” ì´ìƒ ì‘ì—…ì´ ì—†ìœ¼ë©´ ì¢…ë£Œ
        if (taskId == -1) break;
        
        // ì‘ì—… ì²˜ë¦¬
        ProcessTask();
    }
    
    // ìµœì¢… í†µê³„ ì¶œë ¥
    ULONGLONG threadLifetime = GetTickCount64() - pStats->startTime;
    std::cout << "\nìŠ¤ë ˆë“œ " << pStats->threadId << " í†µê³„:" << std::endl;
    std::cout << "  - ì²˜ë¦¬í•œ ì‘ì—… ìˆ˜: " << pStats->taskCount << std::endl;
    std::cout << "  - ì´ ì‘ì—… ì‹œê°„: " << pStats->totalTime << "ms" << std::endl;
    std::cout << "  - ìŠ¤ë ˆë“œ ìƒì¡´ ì‹œê°„: " << threadLifetime << "ms" << std::endl;
    if (pStats->taskCount > 0) {
        std::cout << "  - í‰ê·  ì‘ì—… ì‹œê°„: " 
                  << (pStats->totalTime / pStats->taskCount) << "ms" << std::endl;
        std::cout << "  - CPU í™œìš©ë¥ : " 
                  << ((pStats->totalTime * 100) / threadLifetime) << "%" << std::endl;
    }
    
    // TLS ì •ë¦¬
    CleanupThreadStatistics();
    
    return 0;
}

int main() {
    std::cout << "=== TLSë¥¼ ì´ìš©í•œ ìŠ¤ë ˆë“œë³„ í†µê³„ ìˆ˜ì§‘ ì˜ˆì œ ===" << std::endl;
    
    // TLS ì¸ë±ìŠ¤ í• ë‹¹
    g_tlsIndex = TlsAlloc();
    if (g_tlsIndex == TLS_OUT_OF_INDEXES) {
        std::cerr << "TLS í• ë‹¹ ì‹¤íŒ¨" << std::endl;
        return 1;
    }
    
    // Critical Section ì´ˆê¸°í™”
    InitializeCriticalSection(&g_csTaskQueue);
    
    // ì‘ì—…ì ìŠ¤ë ˆë“œ ìƒì„±
    const int THREAD_COUNT = 4;
    std::vector<HANDLE> threads(THREAD_COUNT);
    
    for (int i = 0; i < THREAD_COUNT; i++) {
        threads[i] = CreateThread(
            nullptr,
            0,
            WorkerThread,
            nullptr,
            0,
            nullptr
        );
        
        if (threads[i] == nullptr) {
            std::cerr << "ìŠ¤ë ˆë“œ ìƒì„± ì‹¤íŒ¨" << std::endl;
            // ì—ëŸ¬ ì²˜ë¦¬ ìƒëµ
        }
    }
    
    // ëª¨ë“  ìŠ¤ë ˆë“œ ì™„ë£Œ ëŒ€ê¸°
    WaitForMultipleObjects(THREAD_COUNT, threads.data(), TRUE, INFINITE);
    
    // ë¦¬ì†ŒìŠ¤ ì •ë¦¬
    for (HANDLE hThread : threads) {
        CloseHandle(hThread);
    }
    
    DeleteCriticalSection(&g_csTaskQueue);
    TlsFree(g_tlsIndex);
    
    std::cout << "\nëª¨ë“  ì‘ì—… ì™„ë£Œ" << std::endl;
    
    return 0;
}
```
  
### g_tlsIndex ì˜ ì˜ë¯¸
`g_tlsIndex`ëŠ” ìŠ¤ë ˆë“œë³„ë¡œ í• ë‹¹ë˜ëŠ” **ë°ì´í„°(ê°’)ê°€ ì•„ë‹ˆë¼**, í”„ë¡œì„¸ìŠ¤(í”„ë¡œê·¸ë¨)ê°€ ì‹œì‘ë  ë•Œ `TlsAlloc()`ì„ í†µí•´ **ë‹¨ í•œ ë²ˆ** í• ë‹¹ë°›ëŠ” **"ìŠ¬ë¡¯ ë²ˆí˜¸"** ë˜ëŠ” **"ì¸ë±ìŠ¤"** ì´ë‹¤.

#### ë½ì»¤ë£¸(ì‚¬ë¬¼í•¨) ë¹„ìœ 
ì´í•´ë¥¼ ë•ê¸° ìœ„í•´ ë½ì»¤ë£¸ì— ë¹„ìœ í•´ ë³´ê² ë‹¤.

1.  **`TlsAlloc()` (main ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰)**
    * `main` ìŠ¤ë ˆë“œê°€ ë½ì»¤ë£¸ ê´€ë¦¬ìì—ê²Œ ê°€ì„œ "ìš°ë¦¬ ìŠ¤ë ˆë“œë“¤ì´ ì´ì œë¶€í„° í†µê³„ ìë£Œë¥¼ ë³´ê´€í•  ê±´ë°, ëª‡ ë²ˆ ë½ì»¤ë¥¼ ì“°ë©´ ë ê¹Œìš”?"ë¼ê³  ë¬»ëŠ”ë‹¤.
    * ê´€ë¦¬ìê°€ "ë„¤, **3ë²ˆ** ë½ì»¤ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”."ë¼ê³  ë‹µí•´ì¤€ë‹¤.
    * ì´ë•Œ `g_tlsIndex = 3`ì´ ëœë‹¤. ì´ '3'ì´ë¼ëŠ” ë²ˆí˜¸ëŠ” **ì „ì—­ ë³€ìˆ˜**ì´ë¯€ë¡œ ëª¨ë“  ìŠ¤ë ˆë“œê°€ ë³¼ ìˆ˜ ìˆë‹¤.

2.  **`WorkerThread` ìƒì„± ë° `TlsSetValue()`**
    * **ìŠ¤ë ˆë“œ A**ê°€ ë½ì»¤ë£¸ì— ë“¤ì–´ì˜¨ë‹¤. ì „ì—­ ê³µì§€(`g_tlsIndex`)ë¥¼ ë³´ê³  "ì•„, ë‚˜ëŠ” 3ë²ˆ ë½ì»¤ë¥¼ ì¨ì•¼ í•˜ëŠ”êµ¬ë‚˜"ë¼ê³  ì¸ì§€í•œë‹¤.
    * ìŠ¤ë ˆë“œ AëŠ” **ìì‹ ì—ê²Œ í• ë‹¹ëœ êµ¬ì—­**ìœ¼ë¡œ ê°€ì„œ **3ë²ˆ ë½ì»¤**ë¥¼ ì—°ë‹¤. ê·¸ë¦¬ê³  ìì‹ ì˜ `ThreadStatistics` ê°ì²´(`pStats_A`)ë¥¼ ê·¸ ì•ˆì— ë„£ëŠ”ë‹¤.
    * **ìŠ¤ë ˆë“œ B**ê°€ ë½ì»¤ë£¸ì— ë“¤ì–´ì˜¨ë‹¤. ë˜‘ê°™ì´ ì „ì—­ ê³µì§€(`g_tlsIndex`)ë¥¼ ë³´ê³  "ë‚˜ë„ 3ë²ˆ ë½ì»¤ë¥¼ ì¨ì•¼ í•˜ë„¤"ë¼ê³  ì¸ì§€í•œë‹¤.
    * ìŠ¤ë ˆë“œ BëŠ” **ìì‹ ì—ê²Œ í• ë‹¹ëœ (ìŠ¤ë ˆë“œ Aì™€ëŠ” ì™„ì „íˆ ë‹¤ë¥¸) êµ¬ì—­**ìœ¼ë¡œ ê°€ì„œ **3ë²ˆ ë½ì»¤**ë¥¼ ì—°ë‹¤. ê·¸ë¦¬ê³  ìì‹ ì˜ `ThreadStatistics` ê°ì²´(`pStats_B`)ë¥¼ ê·¸ ì•ˆì— ë„£ëŠ”ë‹¤.

3.  **`TlsGetValue()`**
    * ë‚˜ì¤‘ì— ìŠ¤ë ˆë“œ Aê°€ `TlsGetValue(g_tlsIndex)`ë¥¼ í˜¸ì¶œí•˜ë©´, ì‹œìŠ¤í…œì€ "ì•„, ìŠ¤ë ˆë“œ Aêµ¬ë‚˜. A êµ¬ì—­ì˜ 3ë²ˆ ë½ì»¤ë¥¼ ì—´ì–´ì¤„ê²Œ"ë¼ë©° `pStats_A`ë¥¼ êº¼ë‚´ì¤€ë‹¤.
    * ìŠ¤ë ˆë“œ Bê°€ `TlsGetValue(g_tlsIndex)`ë¥¼ í˜¸ì¶œí•˜ë©´, ì‹œìŠ¤í…œì€ "ìŠ¤ë ˆë“œ Bë„¤. B êµ¬ì—­ì˜ 3ë²ˆ ë½ì»¤ë¥¼ ì—´ì–´ì¤„ê²Œ"ë¼ë©° `pStats_B`ë¥¼ êº¼ë‚´ì¤€ë‹¤.

#### ğŸ“‹ ìš”ì•½

| êµ¬ë¶„ | `g_tlsIndex` (ì¸ë±ìŠ¤) | `TlsGetValue(g_tlsIndex)` (ì‹¤ì œ ë°ì´í„°) |
| :--- | :--- | :--- |
| **ê°’** | **ê³µìœ ë¨** (ëª¨ë“  ìŠ¤ë ˆë“œê°€ ë™ì¼í•œ ê°’, ì˜ˆ: 3) | **ìŠ¤ë ˆë“œë§ˆë‹¤ ê³ ìœ í•¨** (AëŠ” Aì˜ ë°ì´í„°, BëŠ” Bì˜ ë°ì´í„°) |
| **ì˜ë¯¸** | "ëª‡ ë²ˆ ìŠ¬ë¡¯ì„ ì‚¬ìš©í•  ê²ƒì¸ê°€"í•˜ëŠ” **ì•½ì†** | "í•´ë‹¹ ìŠ¬ë¡¯ì— ì €ì¥ëœ **ì‹¤ì œ ê°’**(í¬ì¸í„°)" |
| **í• ë‹¹** | í”„ë¡œì„¸ìŠ¤ ì‹œì‘ ì‹œ `TlsAlloc()`ë¡œ **1íšŒ** | ìŠ¤ë ˆë“œ ì‹œì‘ ì‹œ `TlsSetValue()`ë¡œ **ê° ìŠ¤ë ˆë“œë§ˆë‹¤** |

ê²°ë¡ ì ìœ¼ë¡œ, `g_tlsIndex`ëŠ” **"ì£¼ì†Œ"ê°€ ì•„ë‹ˆë¼**, ê° ìŠ¤ë ˆë“œê°€ ìì‹ ë§Œì˜ "ì‚¬ë¬¼í•¨(ì €ì¥ ê³µê°„)"ì„ ì°¾ê¸° ìœ„í•´ ì‚¬ìš©í•˜ëŠ” **"ë²ˆí˜¸í‘œ"** ì´ë‹¤.


## ì •ì  TLS (__declspec(thread))
Visual C++ëŠ” `__declspec(thread)` í‚¤ì›Œë“œë¥¼ í†µí•´ ì •ì  TLSë¥¼ ì§€ì›í•œë‹¤. ì´ëŠ” ì»´íŒŒì¼ëŸ¬ê°€ ìë™ìœ¼ë¡œ TLSë¥¼ ê´€ë¦¬í•´ì£¼ë¯€ë¡œ ì‚¬ìš©ì´ ê°„í¸í•˜ì§€ë§Œ, DLLì—ì„œ ì‚¬ìš©í•  ë•ŒëŠ” ì œì•½ì‚¬í•­ì´ ìˆë‹¤.

```cpp
#include <windows.h>
#include <iostream>

// ì •ì  TLS ë³€ìˆ˜ ì„ ì–¸
__declspec(thread) int g_threadCounter = 0;
__declspec(thread) DWORD g_threadStartTime = 0;

DWORD WINAPI StaticTLSThread(LPVOID lpParam) {
    int threadNum = *static_cast<int*>(lpParam);
    
    // ê° ìŠ¤ë ˆë“œëŠ” ìì‹ ë§Œì˜ g_threadCounterì™€ g_threadStartTimeì„ ê°€ì§
    g_threadStartTime = GetTickCount();
    
    for (int i = 0; i < 5; i++) {
        g_threadCounter++;
        std::cout << "ìŠ¤ë ˆë“œ " << threadNum 
                  << ": ì¹´ìš´í„° = " << g_threadCounter << std::endl;
        Sleep(100);
    }
    
    DWORD elapsed = GetTickCount() - g_threadStartTime;
    std::cout << "ìŠ¤ë ˆë“œ " << threadNum 
              << " ì™„ë£Œ (ê²½ê³¼ ì‹œê°„: " << elapsed << "ms)" << std::endl;
    
    return 0;
}

int main() {
    std::cout << "=== ì •ì  TLS ì˜ˆì œ ===" << std::endl;
    
    const int THREAD_COUNT = 3;
    HANDLE threads[THREAD_COUNT];
    int threadNums[THREAD_COUNT];
    
    for (int i = 0; i < THREAD_COUNT; i++) {
        threadNums[i] = i + 1;
        threads[i] = CreateThread(
            nullptr,
            0,
            StaticTLSThread,
            &threadNums[i],
            0,
            nullptr
        );
    }
    
    WaitForMultipleObjects(THREAD_COUNT, threads, TRUE, INFINITE);
    
    for (int i = 0; i < THREAD_COUNT; i++) {
        CloseHandle(threads[i]);
    }
    
    return 0;
}
```
  

## TLS ì‚¬ìš© ì‹œ ì£¼ì˜ì‚¬í•­
TLSë¥¼ ì‚¬ìš©í•  ë•ŒëŠ” ëª‡ ê°€ì§€ ì¤‘ìš”í•œ ì‚¬í•­ì„ ê³ ë ¤í•´ì•¼ í•œë‹¤.   
- ì²«ì§¸, TLSì— ì €ì¥í•œ í¬ì¸í„°ê°€ ê°€ë¦¬í‚¤ëŠ” ë©”ëª¨ë¦¬ëŠ” ë°˜ë“œì‹œ ìŠ¤ë ˆë“œ ì¢…ë£Œ ì „ì— í•´ì œí•´ì•¼ í•œë‹¤. ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ê°€ ë°œìƒí•œë‹¤. 
- ë‘˜ì§¸, TLS ìŠ¬ë¡¯ì˜ ê°œìˆ˜ëŠ” ì œí•œì ì´ë¯€ë¡œ í•„ìš”í•œ ë§Œí¼ë§Œ í• ë‹¹í•˜ê³  ì‚¬ìš© í›„ ë°˜ë“œì‹œ í•´ì œí•´ì•¼ í•œë‹¤. 
- ì…‹ì§¸, DLLì—ì„œ ì •ì  TLSë¥¼ ì‚¬ìš©í•  ë•ŒëŠ” LoadLibraryë¡œ ë™ì  ë¡œë”©í•˜ëŠ” ê²½ìš° ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì£¼ì˜ê°€ í•„ìš”í•˜ë‹¤. 
- ë§ˆì§€ë§‰ìœ¼ë¡œ TLSëŠ” ìŠ¤ë ˆë“œ í’€ê³¼ í•¨ê»˜ ì‚¬ìš©í•  ë•Œ íŠ¹ë³„í•œ ì£¼ì˜ê°€ í•„ìš”í•œë°, ìŠ¤ë ˆë“œ í’€ì˜ ìŠ¤ë ˆë“œëŠ” ì¬ì‚¬ìš©ë˜ë¯€ë¡œ TLS ê°’ì´ ì´ì „ ì‘ì—…ì˜ ê²ƒì´ ë‚¨ì•„ìˆì„ ìˆ˜ ìˆë‹¤. 
  

## TLS ì‚¬ìš© ì‚¬ë¡€
TLS(ìŠ¤ë ˆë“œ ë¡œì»¬ ì €ì¥ì†Œ)ëŠ” **"ì´ ë°ì´í„°ëŠ” ì „ì—­ ë³€ìˆ˜ì²˜ëŸ¼ í¸í•˜ê²Œ ì“°ê³  ì‹¶ì§€ë§Œ, ë‹¤ë¥¸ ìŠ¤ë ˆë“œì™€ëŠ” ì ˆëŒ€ ê³µìœ í•˜ê³  ì‹¶ì§€ ì•Šì„ ë•Œ"** ê°€ì¥ ìœ ìš©í•˜ë‹¤.

ê° ìŠ¤ë ˆë“œê°€ **ìì‹ ë§Œì˜ ê³ ìœ í•œ** ì €ì¥ ê³µê°„ì„ ê°–ëŠ” ê²ƒì´ë¯€ë¡œ, **ë®¤í…ìŠ¤(Mutex)ë‚˜ í¬ë¦¬í‹°ì»¬ ì„¹ì…˜(Critical Section) ê°™ì€ ì ê¸ˆ ì¥ì¹˜ë¥¼ ì „í˜€ ì‚¬ìš©í•˜ì§€ ì•Šê³ ë„** ë°ì´í„°ë¥¼ ì•ˆì „í•˜ê²Œ ì½ê³  ì“¸ ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì´ í•µì‹¬ ì¥ì ì´ë‹¤.


### 1. ğŸ¯ ìŠ¤ë ˆë“œë³„ ì˜¤ë¥˜ ì½”ë“œ ì €ì¥ (ì˜ˆ: `errno`)
ê°€ì¥ ê³ ì „ì ì´ê³  ì™„ë²½í•œ ì‚¬ìš© ì‚¬ë¡€ì´ë‹¤.

* **ë¬¸ì œì :** ë§Œì•½ `errno` (Cì–¸ì–´)ë‚˜ `GetLastError()` (Windows) ê°™ì€ ì˜¤ë¥˜ ë³€ìˆ˜ê°€ ëª¨ë“  ìŠ¤ë ˆë“œì— ê³µìœ ë˜ëŠ” ë‹¨ í•˜ë‚˜ì˜ ì „ì—­ ë³€ìˆ˜ë¼ë©´, ìŠ¤ë ˆë“œ Aê°€ ì˜¤ë¥˜ë¥¼ ë°œìƒì‹œí‚¨ ì§í›„ ìŠ¤ë ˆë“œ Bê°€ ë‹¤ë¥¸ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ ê·¸ ê°’ì„ ë®ì–´ì¨ ë²„ë¦´ ìˆ˜ ìˆë‹¤.
* **TLS í™œìš©:** `errno`ë¥¼ TLSì— ì €ì¥í•˜ë©´, ê° ìŠ¤ë ˆë“œëŠ” **ìì‹ ë§Œì˜ `errno` ë³€ìˆ˜**ë¥¼ ê°–ê²Œ ëœë‹¤. ìŠ¤ë ˆë“œ Aê°€ `errno`ë¥¼ 10ìœ¼ë¡œ ì„¤ì •í•´ë„ ìŠ¤ë ˆë“œ Bì˜ `errno`ëŠ” 0ì¼ ìˆ˜ ìˆìœ¼ë©°, ì„œë¡œ ì ˆëŒ€ ê°„ì„­í•˜ì§€ ì•ŠëŠ”ë‹¤.


### 2. ğŸ“Š ìŠ¤ë ˆë“œë³„ í†µê³„ ë° ì„±ëŠ¥ ì¹´ìš´í„°
ì•ì— ë‚˜ì˜¨ ì˜ˆì œ ì½”ë“œì˜ ìš©ë„ì´ë‹¤.  

* **ë¬¸ì œì :** "ì´ ì²˜ë¦¬ ì‘ì—… ìˆ˜" ê°™ì€ ë³€ìˆ˜ë¥¼ ì „ì—­ ë³€ìˆ˜ë¡œ ë‘ê³  ëª¨ë“  ìŠ¤ë ˆë“œê°€ ë½(Lock)ì„ ì¡ê³  1ì”© ì¦ê°€ì‹œí‚¨ë‹¤ë©´, ì‘ì—…ì´ ë¹ˆë²ˆí• ìˆ˜ë¡ ì´ ë½(Lock)ì—ì„œ ì—„ì²­ë‚œ **ì„±ëŠ¥ ë³‘ëª©**ì´ ë°œìƒë‹¤.
* **TLS í™œìš©:** ê° ìŠ¤ë ˆë“œê°€ TLSì— **ìì‹ ë§Œì˜ ì¹´ìš´í„°**(`my_task_count`)ë¥¼ ë‘”ë‹¤. ìŠ¤ë ˆë“œëŠ” **ë½ ì—†ì´** ìì‹ ì˜ ì¹´ìš´í„°ë¥¼ 100ë²ˆ, 1000ë²ˆ ë¹ ë¥´ê²Œ ì¦ê°€ì‹œí‚¨ë‹¤. ëª¨ë“  ì‘ì—…ì´ ëë‚œ í›„, ë©”ì¸ ìŠ¤ë ˆë“œê°€ ê° ìŠ¤ë ˆë“œì— "ë„ˆ ëª‡ ê°œ ì²˜ë¦¬í–ˆì–´?"ë¼ê³  ë¬¼ì–´ë³´ê³ (í˜¹ì€ ìŠ¤ë ˆë“œê°€ ì¢…ë£Œ ì‹œ ìì‹ ì„ ë“±ë¡ í•´ì œí•˜ë©° ê°’ì„ ë°˜ë‚©í•˜ê³ ) ê·¸ ê°’ë“¤ì„ ëª¨ë‘ í•©ì‚°í•˜ë©´, ë½ ê²½í•© ì—†ì´ë„ ì •í™•í•œ ì´í•©ì„ ì•Œ ìˆ˜ ìˆë‹¤.


### 3. ğŸ“ ë¡œê¹…(Logging) ë° íŠ¸ëœì­ì…˜ ì»¨í…ìŠ¤íŠ¸
ì›¹ ì„œë²„ë‚˜ ë³µì¡í•œ ì‹œìŠ¤í…œì—ì„œ ë§¤ìš° ìœ ìš©í•˜ë‹¤.

* **ë¬¸ì œì :** ìŠ¤ë ˆë“œ Aê°€ "ìš”ì²­ ID: 123"ì„ ì²˜ë¦¬í•˜ê³ , ìŠ¤ë ˆë“œ Bê°€ "ìš”ì²­ ID: 456"ì„ ì²˜ë¦¬ ì¤‘ì´ë¼ê³  ê°€ì •í•´ ë³´ì. í•¨ìˆ˜ê°€ 10ë‹¨ê³„ ê¹Šì´ë¡œ í˜¸ì¶œë  ë•Œ, ì´ "ìš”ì²­ ID"ë¥¼ ë¡œê¹…í•˜ê¸° ìœ„í•´ ëª¨ë“  í•¨ìˆ˜ê°€ `requestId`ë¥¼ ì¸ì(parameter)ë¡œ ë„˜ê²¨ë°›ì•„ì•¼ í•œë‹¤ë©´ ì½”ë“œê°€ ë§¤ìš° ì§€ì €ë¶„í•´ì§„ë‹¤.
* **TLS í™œìš©:** ì‘ì—… ìŠ¤ë ˆë“œê°€ "ìš”ì²­ ID: 123"ì„ ë°›ìœ¼ë©´, ì´ IDë¥¼ **TLSì— ì €ì¥**í•œë‹¤. ê·¸ í›„ 10ë‹¨ê³„ ê¹Šì´ì˜ í•¨ìˆ˜ì—ì„œ ë¡œê·¸ë¥¼ ë‚¨ê¸¸ ë•Œ, ê·¸ í•¨ìˆ˜ëŠ” ê·¸ëƒ¥ TLSì—ì„œ **"í˜„ì¬ ë‚´ ìŠ¤ë ˆë“œì˜ ìš”ì²­ ID"**ë¥¼ êº¼ë‚´ì„œ ë¡œê·¸ì— ì°ìœ¼ë©´ ëœë‹¤. ì¸ìë¥¼ ì§€ì €ë¶„í•˜ê²Œ ë„˜ê¸¸ í•„ìš”ê°€ ì—†ì–´ì§„ë‹¤.  

  
### 4. â™»ï¸ ë¦¬ì†ŒìŠ¤ ì¬ì‚¬ìš© ë° ìŠ¤ë ˆë“œë³„ ìºì‹œ
ìì£¼ í•„ìš”í•˜ì§€ë§Œ ìŠ¤ë ˆë“œ ê°„ ê³µìœ ê°€ ë¶ˆê°€ëŠ¥í•˜ê±°ë‚˜(non-thread-safe) ë¹„íš¨ìœ¨ì ì¸ ê°ì²´ì— ì‚¬ìš©í•œë‹¤.

* **ë¬¸ì œì :**
    1.  `rand()` ê°™ì€ ì¼ë¶€ ì˜¤ë˜ëœ C í•¨ìˆ˜ëŠ” ë‚´ë¶€ ìƒíƒœë¥¼ ê³µìœ í•´ ìŠ¤ë ˆë“œì— ì•ˆì „í•˜ì§€ ì•Šë‹¤.
    2.  ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°(DB Connection) ê°ì²´ë‚˜ ë‚œìˆ˜ ìƒì„±ê¸°(`std::mt19937`)ì²˜ëŸ¼ ìƒì„± ë¹„ìš©ì´ ë¹„ì‹¼ ê°ì²´ë¥¼ ë§¤ë²ˆ í•¨ìˆ˜ í˜¸ì¶œ ì‹œë§ˆë‹¤ ë§Œë“¤ê³  íŒŒê´´í•˜ëŠ” ê²ƒì€ ë‚­ë¹„ì´ë‹¤.
* **TLS í™œìš©:** ê° ìŠ¤ë ˆë“œê°€ **ìì‹ ë§Œì˜ ë‚œìˆ˜ ìƒì„±ê¸° ê°ì²´**ë‚˜ **ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ê°ì²´**ë¥¼ í•˜ë‚˜ ìƒì„±í•´ì„œ TLSì— ë³´ê´€í•œë‹¤. ê·¸ë¦¬ê³  ì‘ì—…ì´ í•„ìš”í•  ë•Œë§ˆë‹¤ TLSì—ì„œ êº¼ë‚´ì–´ **ì¬ì‚¬ìš©**í•œë‹¤. ê°ì²´ ìƒì„± ë¹„ìš©ì„ ì•„ë‚„ ìˆ˜ ìˆê³ , ë‹¤ë¥¸ ìŠ¤ë ˆë“œì™€ ì¶©ëŒí•  ì—¼ë ¤ë„ ì—†ë‹¤.    


</br>  
  
## C++ì—ì„œì˜ Thread Local Storage(TLS): ì •ì˜ì™€ ì‚¬ìš©ë²•

### ê¸°ë³¸ ë¬¸ë²•

* ìŠ¤í† ë¦¬ì§€ ì§€ì •ì: `thread_local`
* ì¡°í•© ê°€ëŠ¥: `static`, `constinit` ë“±ê³¼ ì¡°í•© ê°€ëŠ¥í•˜ë‹¤.
* ì´ˆê¸°í™”: ê° ìŠ¤ë ˆë“œê°€ **ì²˜ìŒ í•´ë‹¹ ë³€ìˆ˜ë¥¼ ODR-ì‚¬ìš©**(ì‹¤ì œ ì°¸ì¡°)í•  ë•Œ ì´ˆê¸°í™”ëœë‹¤.
* ìˆ˜ëª…: ìŠ¤ë ˆë“œ ì‹œì‘ ì‹œ ìƒì„±(ë˜ëŠ” ì²« ì‚¬ìš© ì‹œ ì´ˆê¸°í™”)ë˜ê³  ìŠ¤ë ˆë“œ ì¢…ë£Œ ì‹œ íŒŒê´´ëœë‹¤.  
  
>>> ODRì€ **One Definition Rule(ë‹¨ì¼ ì •ì˜ ê·œì¹™)** ì˜ ì•½ìë‹¤.  

```cpp
#include <thread>
#include <iostream>

thread_local int tls_counter = 0;        // ëª¨ë“  ìŠ¤ë ˆë“œê°€ ê°ì 0ìœ¼ë¡œ ì‹œì‘í•œë‹¤

void worker(int id) {
    for (int i = 0; i < 3; ++i) {
        ++tls_counter;
        std::cout << "T" << id << " -> " << tls_counter << '\n';
    }
}

int main() {
    std::thread a(worker, 1);
    std::thread b(worker, 2);
    a.join(); b.join();
}
```

### í•¨ìˆ˜ ì§€ì—­ `thread_local`ê³¼ ì •ì  ë©¤ë²„

```cpp
struct Logger {
    static thread_local std::string buffer; // ìŠ¤ë ˆë“œë³„ ë¡œê·¸ ë²„í¼
    static void log(std::string s) { buffer += s; }
};
thread_local std::string Logger::buffer;    // ODR ì •ì˜ í•„ìš”
//C++17 ì´ìƒì—ì„œëŠ”
/*
struct Logger {
    // inlineì„ ì‚¬ìš©í•˜ì—¬ ì„ ì–¸ê³¼ ë™ì‹œì— ì •ì˜
    static inline thread_local std::string buffer; 

    static void log(std::string s) { buffer += s; }
};
*/

void f() {
    static thread_local int cache = []{
        // ë³µì¡í•œ ì´ˆê¸°í™” ê°€ëŠ¥
        return 42;
    }();
    (void)cache;
}
```

### ì†Œë©¸ì í˜¸ì¶œê³¼ ì£¼ì˜ì 

* `thread_local` ê°ì²´ì— ì†Œë©¸ìê°€ ìˆìœ¼ë©´ ìŠ¤ë ˆë“œ ì¢…ë£Œ ì‹œ í˜¸ì¶œëœë‹¤.
* ìŠ¤ë ˆë“œ ì¢…ë£Œ ìˆœì„œ ë¬¸ì œë¡œ, ë‹¤ë¥¸ ì •ì  ê°ì²´ì— ì˜ì¡´í•˜ëŠ” ì†Œë©¸ ì‘ì—…ì€ ìœ„í—˜í•  ìˆ˜ ìˆë‹¤. ê°€ëŠ¥í•˜ë©´ ì†Œë©¸ìì—ì„œ ì „ì—­ ë¦¬ì†ŒìŠ¤ ì˜ì¡´ì„ í”¼í•œë‹¤.

### ëª¨ë“ˆ/ë¼ì´ë¸ŒëŸ¬ë¦¬ ê²½ê³„

* ë™ì  ë¼ì´ë¸ŒëŸ¬ë¦¬ ê²½ê³„ì—ì„œ `thread_local`ì˜ ìƒì„±/ì†Œë©¸ íƒ€ì´ë°ì€ êµ¬í˜„ì²´ì— ë”°ë¥´ë©°, ì¼ë¶€ í™˜ê²½ì—ì„œëŠ” ë¹„ìš©ì´ ë°œìƒí•œë‹¤. ì„±ëŠ¥ í¬ë¦¬í‹°ì»¬ ê²½ë¡œì—ì„œëŠ” ì›ì‹œ íƒ€ì… ë˜ëŠ” PODë¥¼ ê¶Œì¥í•œë‹¤.


### RAIIë¡œ ìŠ¤ë ˆë“œ ì»¨í…ìŠ¤íŠ¸ í‘¸ì‹œ/íŒ

```cpp
#include <string>
#include <utility>

thread_local std::string g_ctx;

struct ThreadContextGuard {
    std::string prev;
    explicit ThreadContextGuard(std::string next)
        : prev(std::exchange(g_ctx, std::move(next))) {}
    ~ThreadContextGuard() { g_ctx = std::move(prev); }
};

// ì‚¬ìš© ì˜ˆ
void foo() {
    ThreadContextGuard guard("REQ-123");   // ìŠ¤ì½”í”„ ë™ì•ˆë§Œ ì»¨í…ìŠ¤íŠ¸ êµì²´
    // ...
}
```

### ì œë„¤ë¦­ TLS í•¸ë“¤ëŸ¬

```cpp
template <class T>
class Tls {
public:
    static T& get() {
        static thread_local T instance{};
        return instance;
    }
};

// ì‚¬ìš© ì˜ˆ
struct Stats { long counter = 0; };
void work() {
    auto& stats = Tls<Stats>::get();
    ++stats.counter;
}
```  