# Win32 멀티스레드 프로그래밍 핵심 정리

## 📚 학습 경로 요약

### **1단계: 기초 개념 (1-2주차)**

#### 커널(Kernel)의 역할
- **하드웨어와 소프트웨어의 중개자** 역할
- CPU, 메모리, I/O 등 모든 시스템 자원 관리
- 애플리케이션의 모든 시스템 요청(시스템 콜) 처리

#### 유저 모드 vs 커널 모드
```
유저 모드: 애플리케이션 실행 영역 (제한된 권한)
    ↓ (시스템 콜)
커널 모드: OS 커널 실행 영역 (전체 권한)
    ↑ (리턴)
유저 모드: 계속 실행
```

**모드 전환의 성능 영향**: 자주 일어나면 성능 저하 → 불필요한 동기화 최소화 필요

#### 프로세스 vs 스레드

| 구분 | 프로세스 | 스레드 |
|------|---------|--------|
| **메모리** | 독립된 가상 주소 공간 | 같은 프로세스 내 메모리 공유 |
| **생성 비용** | 높음 | 낮음 |
| **통신** | IPC 필요 | 직접 메모리 공유 |
| **격리도** | 높음 (안전) | 낮음 (위험) |

---

### **2단계: 동기화 기본 (3-4주차)**

#### ⚠️ 경쟁 조건(Race Condition) - 가장 중요한 문제

```cpp
// 위험한 코드
int counter = 0;

// 스레드1        스레드2
counter++;     counter++;

// 예상: counter = 2
// 실제: counter = 1 (데이터 손실!)
```

**이유**: `counter++`는 실제로 3단계
```
1. 메모리에서 값 읽기
2. 계산 (+1)
3. 메모리에 값 쓰기

두 스레드가 동시에 실행하면 값이 덮어써짐
```

#### 해결책: 상호 배제(Mutual Exclusion)

**동기화 객체 선택 기준**:

```
Critical Section (가장 자주 사용)
├─ 프로세스 내부 스레드 간 동기화
├─ 가장 빠름 (커널 오브젝트 없음)
└─ 재진입 불가

Mutex (프로세스 간 동기화 필요시)
├─ 프로세스 간 공유 가능
├─ Critical Section보다 무거움
└─ 소유권 개념 제공

SRWLOCK (읽기 > 쓰기인 경우)
├─ Reader-Writer Lock
├─ 여러 Reader 동시 접근 가능
└─ Writer는 배타적 접근

Event (신호/대기 패턴)
├─ 상태 변화 알림
├─ 브로드캐스트 가능
└─ 다른 객체와 WaitForMultipleObjects 가능

ConditionVariable (깔끔한 대기/신호)
├─ 반드시 락과 함께 사용
├─ 바쁜 대기(polling) 제거
└─ "거짓 깨어남" 대비 while 재검사 필수
```

---

### **3단계: 고급 동기화 (5-6주차)**

#### Interlocked 함수들 - "락 없는 원자 연산"

```cpp
// Critical Section (느림)
EnterCriticalSection(&cs);
counter++;
LeaveCriticalSection(&cs);

// Interlocked (빠름)
InterlockedIncrement(&counter);  // 원자적 + 메모리 장벽 제공
```

**자주 쓰는 함수들**:
```cpp
InterlockedIncrement(&var)          // var++ (원자적)
InterlockedDecrement(&var)          // var--
InterlockedExchange(&var, newVal)   // swap (원래값 반환)
InterlockedCompareExchange(&var, new, old)  // CAS (Lock-Free 알고리즘 기반)
InterlockedAdd(&var, value)         // var += value
```

#### Lock-Free 큐 구현 핵심

```cpp
// SPSC (Single Producer, Single Consumer)는 간단
bool Enqueue(Queue* q, int value) {
    LONG nextTail = (q->tail + 1) % SIZE;
    if (nextTail == q->head) return false;  // 가득 참
    
    q->buffer[q->tail] = value;
    MemoryBarrier();  // 메모리 재배치 방지 (중요!)
    q->tail = nextTail;
    return true;
}

// MPMC (Multi Producer, Multi Consumer)는 CAS 필요
bool Enqueue_MPMC(Queue* q, int value) {
    while (true) {
        LONG tail = q->tail;
        LONG nextTail = (tail + 1) % SIZE;
        
        if (nextTail == q->head) return false;
        if (InterlockedCompareExchange(&q->tail, nextTail, tail) == tail) {
            q->buffer[tail] = value;
            return true;  // 성공
        }
        // 실패 시 재시도
    }
}
```

---

## 🎯 핵심 패턴 3가지

### **패턴 1: 생산자-소비자 (Producer-Consumer)**

```cpp
// 여러 생산자가 데이터 생성 → 여러 소비자가 소비
// 버퍼(큐)로 속도 차이 조절

class ThreadSafeQueue {
private:
    std::queue<int> data;
    CRITICAL_SECTION cs;
    HANDLE hNotEmpty;  // 소비자 대기용
    HANDLE hNotFull;   // 생산자 대기용
};

// Enqueue: 버퍼 가득 → 대기
// Dequeue: 버퍼 비움 → 대기
```

### **패턴 2: Reader-Writer (SRWLOCK)**

```cpp
// 읽기 >> 쓰기인 경우 (예: 설정값 조회, 캐시)

AcquireSRWLockShared(&lock);      // 여러 Reader 동시 접근
  // 읽기만 수행
ReleaseSRWLockShared(&lock);

AcquireSRWLockExclusive(&lock);   // Writer 배타적 접근
  // 읽기/쓰기 가능
ReleaseSRWLockExclusive(&lock);
```

### **패턴 3: 조건 변수 (Condition Variable)**

```cpp
// "특정 조건"을 만족할 때까지 효율적으로 대기

EnterCriticalSection(&cs);
while (!condition) {  // 반드시 while! (허위 깨어남 대비)
    SleepConditionVariableCS(&cv, &cs, INFINITE);
    // 여기서 락이 원자적으로 풀림
}
// 조건 만족 상태로 깨어남
LeaveCriticalSection(&cs);

// 신호 보내기 (다른 스레드에서, 반드시 락 안에서!)
EnterCriticalSection(&cs);
condition = true;
WakeConditionVariable(&cv);  // 하나만 깨움
// 또는 WakeAllConditionVariable(&cv);  // 모두 깨움
LeaveCriticalSection(&cs);
```

---

## ⚡ 실무에서 꼭 기억할 것

### **1. 동기화 선택 기준**

| 상황 | 선택 | 이유 |
|------|------|------|
| 짧은 임계구간 | Critical Section | 가장 빠름 |
| 읽기 많은 경우 | SRWLOCK | 병렬성 좋음 |
| 조건 대기 | Condition Variable | 바쁜 대기 제거 |
| 프로세스 간 | Mutex/Event | 프로세스 경계 넘음 |
| 원자적 연산만 | Interlocked | 락 없이 빠름 |

### **2. 메모리 가시성 (Visibility)**

```cpp
// ❌ 틀린 코드
volatile bool ready = false;  // volatile은 동기화 안 함!

void Producer() {
    data = 42;
    ready = true;  // 다른 CPU 코어가 이것을 안 볼 수 있음
}

void Consumer() {
    while (!ready) {}
    int x = data;  // 0 또는 42? 보장 없음!
}

// ✅ 올바른 코드
void Producer() {
    data = 42;
    MemoryBarrier();  // 또는 Interlocked 사용
    InterlockedExchange(&ready, 1);
}

void Consumer() {
    while (InterlockedCompareExchange(&ready, 1, 1) != 1) {}
    int x = data;  // 항상 42 (메모리 장벽이 순서 보장)
}
```

### **3. 조건 변수의 "허위 깨어남(Spurious Wakeup)" 대비**

```cpp
// ❌ 틀린 코드 (if 사용)
if (!condition) {
    SleepConditionVariableCS(&cv, &cs, INFINITE);
}
// 여기서 condition이 거짓일 수 있음!

// ✅ 올바른 코드 (while 사용)
while (!condition) {
    SleepConditionVariableCS(&cv, &cs, INFINITE);
}
// 반복해서 재검사하므로 안전
```

### **4. 신호는 "반드시" 락 안에서**

```cpp
// ❌ 위험 (Lost Wakeup 가능)
EnterCriticalSection(&cs);
condition = true;
LeaveCriticalSection(&cs);  // 락 해제
WakeConditionVariable(&cv);  // 락 밖에서 신호!

// ✅ 안전
EnterCriticalSection(&cs);
condition = true;
WakeConditionVariable(&cv);  // 락 안에서 신호
LeaveCriticalSection(&cs);
```

---

## 📊 성능 비교

| 동기화 방식 | 상대 속도 | 상황 |
|-----------|---------|------|
| Critical Section (경쟁 X) | 1배 | 기준 |
| Interlocked (인자 1개) | 1배 | 원자 연산만 |
| Critical Section (경쟁 O) | 100배 | 커널 모드 전환 |
| Mutex (경쟁 O) | 500배 | 프로세스 간 추가비용 |
| Event (경쟁 O) | 500배 | 커널 오브젝트 |

**결론**: 경쟁이 없으면 모두 빠르다! 경쟁에 대비한 설계가 중요

---

## 🔍 일반적인 버그 패턴과 해결책

### **버그 1: 데드락 (Deadlock)**
```
Thread A: Lock1 잡음 → Lock2 대기
Thread B: Lock2 잡음 → Lock1 대기
→ 영원히 서로를 기다림
```
**해결**: 항상 **같은 순서**로 락 획득

### **버그 2: 경쟁 조건 (Race Condition)**
```
공유 변수를 동기화 없이 접근
```
**해결**: Critical Section 또는 Interlocked 사용

### **버그 3: 신호 유실 (Lost Wakeup)**
```
락 해제 후 → 신호 보냄 사이에
대기 스레드가 신호 신호를 못 받음
```
**해결**: 신호를 **락 안에서** 보냄

### **버그 4: 기아 상태 (Starvation)**
```
높은 우선순위 스레드가 계속 실행
→ 낮은 우선순위 스레드는 기회 없음
```
**해결**: 우선순위 설정 신중하게, 세마포어로 공정성 확보

---

## 🎓 학습의 다음 단계

1. **스레드 풀 (Thread Pool)**
   - `QueueUserWorkItem` - 간단한 작업
   - TP API (Vista+) - 복잡한 비동기 작업

2. **I/O Completion Ports**
   - 고성능 네트워크 프로그래밍
   - 게임 서버/채팅 서버 구현

3. **성능 최적화**
   - Lock-Free 알고리즘 심화
   - NUMA 고려
   - False Sharing 제거

---

이 정리가 학습 로드맵으로 도움이 되기를 바랍니다! 🚀