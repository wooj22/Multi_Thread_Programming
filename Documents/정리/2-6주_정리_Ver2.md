# Win32 스레드 프로그래밍 핵심 정리

## 📌 1. 기본 개념 (2주차)

### 커널(Kernel)의 역할
- **정의**: 운영체제의 핵심 구성요소로 하드웨어와 소프트웨어의 중개자
- **핵심 기능**: 
  - 프로세스/스레드 관리
  - 메모리 관리 (가상 메모리, 페이징)
  - 파일 시스템 관리
  - 네트워크 관리

### 유저 모드 vs 커널 모드
```
┌─────────────────────────┐
│   애플리케이션 (유저 모드)  │
├─────────────────────────┤ ← 모드 전환 경계
│   운영체제 커널 (커널 모드) │
├─────────────────────────┤
│      하드웨어            │
└─────────────────────────┘
```

**모드 전환이 발생하는 경우**:
- 시스템 콜 호출
- I/O 작업
- 동기화 객체 대기 (뮤텍스 경합 시)

### 프로세스 vs 스레드

| 구분 | 프로세스 | 스레드 |
|------|---------|--------|
| 메모리 | 독립적 가상 메모리 | 프로세스 메모리 공유 |
| 생성 비용 | 높음 | 낮음 |
| 통신 | IPC 필요 | 직접 공유 가능 |
| 안정성 | 높음 (격리) | 낮음 (공유로 인한 위험) |

## 📌 2. 스레드 생성과 관리 (3주차)

### CreateThread vs _beginthreadex

```cpp
// CreateThread (Win32 API)
HANDLE CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
);

// _beginthreadex (C 런타임 권장)
uintptr_t _beginthreadex(
    void *security,
    unsigned stack_size,
    unsigned (__stdcall *start_address)(void *),
    void *arglist,
    unsigned initflag,
    unsigned *thrdaddr
);
```

**⚠️ 중요**: C++ 프로그램에서는 반드시 `_beginthreadex` 사용
- CreateThread는 C 런타임 초기화 누락
- 메모리 누수, 예외 처리 문제 발생 가능

### 스레드 생명주기

```
[생성] → [실행가능] → [실행] → [대기] → [종료]
         ↑______________|
```

**상태 전환 조건**:
- **생성 → 실행가능**: 스레드 시작
- **실행가능 → 실행**: 스케줄러가 CPU 할당
- **실행 → 대기**: I/O 작업, 동기화 객체 대기
- **실행 → 실행가능**: 시간 할당량 소진, 선점

## 📌 3. 컨텍스트 스위칭 (2주차)

### 발생 원인
1. **타이머 인터럽트**: 시간 할당량(~20ms) 소진
2. **I/O 대기**: 파일/네트워크 작업
3. **우선순위 변화**: 더 높은 우선순위 스레드 등장
4. **명시적 양보**: `Thread.Yield()` 호출

### 성능 영향
```
컨텍스트 스위칭 비용 = 커널 모드 전환 + 레지스터 저장/복원 + 캐시 무효화
                    ≈ 1~10 마이크로초
```

**게임 클라이언트 영향**:
- 프레임 드롭 (60fps → 30fps)
- 입력 지연
- 오디오 끊김
- UI 응답성 저하

## 📌 4. 동기화 기초 (4주차)

### Race Condition 문제

```cpp
// ❌ 위험한 코드
int counter = 0;
void Increment() {
    counter++; // 실제로는 3단계: 읽기-증가-쓰기
}

// ✅ 안전한 코드
CRITICAL_SECTION cs;
void SafeIncrement() {
    EnterCriticalSection(&cs);
    counter++;
    LeaveCriticalSection(&cs);
}
```

### 동기화 객체 비교

| 객체 | 속도 | 범위 | 특징 | 용도 |
|------|------|------|------|------|
| Critical Section | 빠름 | 프로세스 내 | 재진입 가능 | 간단한 상호배제 |
| Mutex | 보통 | 프로세스 간 | 소유권 개념 | 프로세스 간 동기화 |
| Semaphore | 보통 | 프로세스 간 | 카운터 기반 | 자원 풀 관리 |
| Event | 보통 | 프로세스 간 | 상태 알림 | 조건 대기/신호 |

### Event 객체 (Manual/Auto Reset)

```cpp
// Auto-Reset: 한 스레드만 깨움
HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

// Manual-Reset: 모든 스레드 깨움
HANDLE hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
```

**사용 예시**:
```cpp
// 생산자
g_data = 42;
SetEvent(g_hEvent);  // 소비자에게 신호

// 소비자
WaitForSingleObject(g_hEvent, INFINITE);
int value = g_data;  // 안전하게 읽기
```

## 📌 5. Interlocked 함수 (5주차)

### 원자적 연산의 중요성

```cpp
// ❌ 비원자적 - Race Condition 발생
LONG g_counter = 0;
g_counter++;  // 위험!

// ✅ 원자적 - 안전
LONG g_counter = 0;
InterlockedIncrement(&g_counter);  // 안전!
```

### 주요 Interlocked 함수

```cpp
// 증감
InterlockedIncrement(&value);
InterlockedDecrement(&value);

// 교환
InterlockedExchange(&target, newValue);

// CAS (Compare And Swap)
InterlockedCompareExchange(&dest, exchange, comparand);

// 덧셈
InterlockedAdd(&value, amount);

// 포인터 교환
InterlockedExchangePointer(&ptr, newPtr);

// 메모리 장벽
MemoryBarrier();
```

### Lock-Free 스핀락 구현

```cpp
class SpinLock {
    volatile LONG locked;
public:
    SpinLock() : locked(0) {}
    
    void Lock() {
        while (InterlockedCompareExchange(&locked, 1, 0) != 0) {
            YieldProcessor();  // CPU 양보
        }
    }
    
    void Unlock() {
        InterlockedExchange(&locked, 0);
    }
};
```

## 📌 6. 흐름 제어 패턴 (5주차)

### 생산자-소비자 패턴

```cpp
CRITICAL_SECTION cs;
HANDLE hEvent;
std::queue<int> buffer;

// 생산자
void Produce(int value) {
    EnterCriticalSection(&cs);
    buffer.push(value);
    LeaveCriticalSection(&cs);
    SetEvent(hEvent);  // 소비자 깨우기
}

// 소비자
int Consume() {
    WaitForSingleObject(hEvent, INFINITE);
    EnterCriticalSection(&cs);
    int value = buffer.front();
    buffer.pop();
    LeaveCriticalSection(&cs);
    return value;
}
```

### 리더-라이터 패턴 (Reader-Writer Lock)

```cpp
// 여러 리더 동시 접근, 단일 라이터
SRWLOCK lock;
InitializeSRWLock(&lock);

// 읽기
AcquireSRWLockShared(&lock);
// ... 읽기 작업 ...
ReleaseSRWLockShared(&lock);

// 쓰기
AcquireSRWLockExclusive(&lock);
// ... 쓰기 작업 ...
ReleaseSRWLockExclusive(&lock);
```

## 📌 7. 고급 동기화 (6주차)

### Condition Variable

```cpp
CRITICAL_SECTION cs;
CONDITION_VARIABLE cv;
bool ready = false;

// 대기
EnterCriticalSection(&cs);
while (!ready) {
    SleepConditionVariableCS(&cv, &cs, INFINITE);
}
LeaveCriticalSection(&cs);

// 신호
EnterCriticalSection(&cs);
ready = true;
WakeConditionVariable(&cv);
LeaveCriticalSection(&cs);
```

**핵심 규칙**:
- 항상 `while` 루프로 조건 재검사
- 상태 변경 후 락 안에서 신호
- `WakeConditionVariable` (1개) vs `WakeAllConditionVariable` (전체)

### 스레드 풀 API

```cpp
// 기본 작업
PTP_WORK work = CreateThreadpoolWork(callback, data, &env);
SubmitThreadpoolWork(work);
WaitForThreadpoolWorkCallbacks(work, FALSE);
CloseThreadpoolWork(work);

// 타이머
PTP_TIMER timer = CreateThreadpoolTimer(callback, data, &env);
SetThreadpoolTimer(timer, &dueTime, period, 0);

// 대기
PTP_WAIT wait = CreateThreadpoolWait(callback, data, &env);
SetThreadpoolWait(wait, hEvent, NULL);

// 비동기 I/O
PTP_IO io = CreateThreadpoolIo(hFile, callback, data, &env);
StartThreadpoolIo(io);
ReadFile(hFile, buffer, size, NULL, &overlapped);
```

## 📌 8. 실무 베스트 프랙티스

### 1. 동기화 객체 선택 가이드

```
프로세스 내 간단한 보호 → Critical Section
프로세스 간 동기화 → Mutex
자원 풀 제한 → Semaphore
조건 대기 → Condition Variable
읽기 다수, 쓰기 소수 → SRW Lock
```

### 2. 데드락 방지

```cpp
// ❌ 나쁜 예 - 데드락 가능
void ThreadA() {
    EnterCriticalSection(&cs1);
    EnterCriticalSection(&cs2);  // 위험!
    // ...
    LeaveCriticalSection(&cs2);
    LeaveCriticalSection(&cs1);
}

void ThreadB() {
    EnterCriticalSection(&cs2);
    EnterCriticalSection(&cs1);  // 데드락!
}

// ✅ 좋은 예 - 항상 같은 순서
void Safe() {
    EnterCriticalSection(&cs1);  // 항상 1 먼저
    EnterCriticalSection(&cs2);  // 항상 2 나중
    // ...
    LeaveCriticalSection(&cs2);
    LeaveCriticalSection(&cs1);
}
```

### 3. 성능 최적화

```cpp
// 스핀 카운트 설정으로 커널 전환 줄이기
InitializeCriticalSectionAndSpinCount(&cs, 4000);

// Try 함수로 블로킹 회피
if (TryEnterCriticalSection(&cs)) {
    // 작업 수행
    LeaveCriticalSection(&cs);
} else {
    // 다른 작업 수행
}
```

### 4. 메모리 가시성

```cpp
// volatile은 동기화가 아님!
volatile int flag = 0;  // ❌ 멀티스레드 안전하지 않음

// Interlocked나 락 사용
LONG flag = 0;
InterlockedExchange(&flag, 1);  // ✅ 안전
```

## 📌 9. 디버깅 팁

### 동기화 문제 탐지

1. **ThreadSanitizer** 사용 (Visual Studio)
2. **Application Verifier** 활용
3. **Performance Monitor**로 컨텍스트 스위칭 모니터링
4. **WinDbg**로 데드락 분석

```
// WinDbg 명령어
!locks          // 모든 락 상태 확인
!cs -l          // Critical Section 상태
!runaway        // CPU 시간 분석
```

## 📌 10. 요약 체크리스트

✅ **기본 개념**
- [ ] 프로세스와 스레드 차이 이해
- [ ] 유저/커널 모드 전환 이해
- [ ] 컨텍스트 스위칭 영향 파악

✅ **스레드 관리**
- [ ] `_beginthreadex` 사용
- [ ] 스레드 생명주기 관리
- [ ] 안전한 종료 패턴 적용

✅ **동기화**
- [ ] Race Condition 이해
- [ ] 적절한 동기화 객체 선택
- [ ] 데드락 방지 패턴 적용

✅ **성능**
- [ ] Interlocked 함수 활용
- [ ] Lock-Free 자료구조 이해
- [ ] 컨텍스트 스위칭 최소화

✅ **고급 기법**
- [ ] Condition Variable 사용
- [ ] 스레드 풀 활용
- [ ] 비동기 I/O 이해

---

이 정리가 Win32 멀티스레드 프로그래밍 학습에 도움이 되기를 바랍니다! 추가 질문이 있으시면 언제든 물어보세요.