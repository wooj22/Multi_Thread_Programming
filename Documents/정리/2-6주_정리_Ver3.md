## 🧩 1. 멀티스레드 기본 개념

### 스레드(Thread)

* **프로세스(Process)**: 실행 중인 프로그램의 인스턴스
* **스레드(Thread)**: 프로세스 내에서 독립적으로 실행되는 단위
* 하나의 프로세스는 여러 스레드를 가질 수 있으며, **메모리(데이터 영역)를 공유**한다.

### 장점과 단점

* **장점**

  * 병렬 처리로 CPU 활용도 극대화
  * 반응성 향상 (특히 GUI 프로그램)
  * 공유 메모리를 통한 효율적 통신
* **단점**

  * 동기화 문제 발생 가능
  * 디버깅 어려움
  * 교착상태(Deadlock) 위험

---

## ⚙️ 2. Windows API 기반 스레드 생성과 관리

### 스레드 생성

```cpp
HANDLE hThread = CreateThread(
    NULL,        // 보안 속성
    0,           // 스택 크기
    ThreadFunc,  // 스레드 함수
    param,       // 전달할 인자
    0,           // 생성 옵션
    NULL         // 스레드 ID 반환
);
```

* `CreateThread()` 함수는 새로운 스레드를 생성하고 `HANDLE`을 반환함
* 스레드가 종료되면 반드시 `CloseHandle()`로 핸들을 닫아야 함

### 스레드 종료

* 스레드 내에서 `return` 또는 `ExitThread()`로 종료 가능
* 다른 스레드에서 강제로 종료 시 `TerminateThread()` 사용하지만 **비추천**

  * 리소스 정리 없이 종료되어 메모리 누수 및 예측 불가 상태 유발 가능

---

## ⏱️ 3. 동기화 기초 (Synchronization Primitives)

멀티스레드 환경에서 가장 중요한 부분은 **공유 자원에 대한 동기화**다.

### 1) Critical Section

* **단일 프로세스 내부**에서만 사용 가능
* 빠르고 가볍다

```cpp
CRITICAL_SECTION cs;
InitializeCriticalSection(&cs);
EnterCriticalSection(&cs);
// 공유 자원 접근
LeaveCriticalSection(&cs);
DeleteCriticalSection(&cs);
```

### 2) Mutex

* **프로세스 간 동기화** 가능
* 커널 오브젝트로 관리되어 Critical Section보다 느리지만 더 범용적이다

```cpp
HANDLE hMutex = CreateMutex(NULL, FALSE, NULL);
WaitForSingleObject(hMutex, INFINITE);
// 공유 자원 접근
ReleaseMutex(hMutex);
CloseHandle(hMutex);
```

### 3) Semaphore

* 동시 접근 가능한 스레드 수를 제한

```cpp
HANDLE hSem = CreateSemaphore(NULL, 2, 2, NULL);
WaitForSingleObject(hSem, INFINITE);
ReleaseSemaphore(hSem, 1, NULL);
```

### 4) Event

* **스레드 간 시그널 통신용** 오브젝트
* 수동/자동 리셋 모드 지원

---

## 🔄 4. 스레드 동작 제어

### 1) 스레드 우선순위

* `SetThreadPriority()`로 설정 가능
* 우선순위가 높다고 반드시 먼저 실행되는 것은 아님 (OS 스케줄러 정책에 따라 다름)

### 2) 스레드 상태 제어

* `SuspendThread()`, `ResumeThread()`로 일시 중단 / 재개 가능
* 동기화 대기 시 `WaitForSingleObject()`와 `WaitForMultipleObjects()` 사용

---

## 🧮 5. 생산자-소비자(Producer–Consumer) 문제

멀티스레드 학습의 대표적 예제로, **큐(Queue)** 또는 **버퍼(Buffer)** 를 공유하는 구조다.

* **생산자 스레드**: 데이터를 생성하여 버퍼에 추가
* **소비자 스레드**: 버퍼에서 데이터를 꺼내 소비

### 해결 핵심

* 버퍼 접근 시 동기화(뮤텍스/세마포어)
* 버퍼가 가득 찼을 때/비었을 때 이벤트로 대기 제어

---

## 🧵 6. C++11 표준 스레드 활용

Windows API 대신 C++11 이후 표준 라이브러리 사용 가능
→ **이식성, 코드 간결성, 안전성**이 높음

### 기본 스레드 생성

```cpp
#include <thread>

void work(int id) { ... }

int main() {
    std::thread t1(work, 1);
    t1.join(); // 스레드 종료 대기
}
```

### 동기화 도구

* `std::mutex`, `std::lock_guard`, `std::unique_lock`
* `std::condition_variable` : 이벤트 제어
* `std::future`, `std::promise` : 결과 전달/비동기 실행 관리

---

## 🧠 7. 교착상태(Deadlock)와 해결 전략

### 교착상태 발생 조건

1. 상호 배제 (Mutual Exclusion)
2. 점유 대기 (Hold and Wait)
3. 비선점 (No Preemption)
4. 순환 대기 (Circular Wait)

### 해결 방법

* 자원 획득 순서 강제
* 타임아웃 설정 (`WaitForSingleObject` 등)
* 교착 상태 탐지 및 회피 알고리즘

---

## 🚀 8. 실무 관점에서의 중요 포인트

1. **Critical Section → Mutex → Semaphore → Event** 순서로 이해하기
   → 범위와 비용의 균형을 알면 실무 동기화 설계에 유리함
2. **CPU 병렬 처리**는 I/O-bound vs CPU-bound 구분이 필요함
3. **스레드 풀(Thread Pool)** 구조를 이해해야 실무 성능을 확보할 수 있음
4. **디버깅 시 Visual Studio의 Concurrency Visualizer**로 타임라인 분석
5. **교착상태 재현 및 예방 패턴** 익히기 (특히 락 순서 규칙 설정)

---

## 📘 종합 요약

| 개념               | 역할           | 비고           |
| ---------------- | ------------ | ------------ |
| Thread           | 병렬 실행 단위     | 프로세스 메모리 공유  |
| Critical Section | 단일 프로세스 보호   | 빠름, 간단함      |
| Mutex            | 프로세스 간 보호    | 느리지만 범용      |
| Semaphore        | 접근 수 제한      | 자원 제한 관리     |
| Event            | 시그널 동기화      | 상태 제어용       |
| std::thread      | C++11 표준 스레드 | 이식성 우수       |
| Deadlock         | 동기화 실패       | 순환 대기 제거로 예방 |

