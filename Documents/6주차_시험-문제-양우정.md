# 시험 문제

## 문제 1. 커널(Kernel)의 역할에 대해서 설명해주세요
커널은 소프트웨어와 하드웨어의 중계자로 하드웨어 관리, 메모리 관리, 스케줄링 등의 역할을 담당한다.



## 문제 2. 프로세스(Process)와 스레드(Thread)의 차이를 설명해주세요
프로세스는 실행중인 프로그램의 인스턴스로 하나의 프로그램은 하나의 프로세스가 된다. 스레드는 하나의 프로세스 안에서의 실행 단위를 의미하며 하나의 프로세스에는 여러 스레드가 실행될 수 있다. 프로세스는 고유 프로세스 ID를 가지며 프로세스와 프로세스간의 메모리 공유는 되지 않는다. 스레드는 고유 스레드 ID를 가지며 각 스레드마다 스택과 레지스터를 갖는다. 프로세스의 컨텍스트 스위칭 비용은 높지만 스레드의 컨텍스트 스위치 비용은 낮다.



## 문제 3. 유저 모드(User Mode)와 커널 모드(Kernel Mode)의 차이를 설명하고, 전환이 발생하는 상황을 예를 들어주세요
유저모드는 소프트웨어가 실행되는 단계를 의미하며, 커널모드는 커널이 실행되는 단계를 의미한다. 유저모드는 CPU의 모든 명령어를 사용할 수 없고 가상 메모리 영역만 사용할 수 있으며 안전한 환경에서 실행된다. 커널모드는 CPU의 강력한 명령어까지 모두 사용 가능하며 모든 메모리에 접근이 가능하다.
유저모드는 안전하지만 모든 기능을 사용할 수 없는 환경이라면 커널 모드는 위험하지만 강력하고 완전한 환경이다.

전환이 발생하는 상황은 소프트웨어가 시스템콜을 호출할 때 발생하며, 모든 IO작업이나 스레드 생성과 종료 등의 작업은 유저모드에서 작업이 불가능하기 때문에 시스템 콜을 통해 유저모드에서 커널모드로 전환이 이루어져 커널이 요청받은 작업을 수행하게 된다.



## 문제 4. 컨텍스트 스위칭(Context Switching)의 개념과 성능에 미치는 영향을 설명해주세요
여러 프로세스들은 운영체제의 스케줄링에 의해 CPU를 할당받아 돌아가며 작업을 수행하게 된다. 이때 한 프로세스의 CPU할당 시간이 끝나고 다른 프로세스로 실행될 대상이 전환되는 것을 컨텍스트 스위칭이라고 한다. 이때 수행중인 작업을 멈추고 실행중이던 프로세스는 메모리에서 내려가며 캐시가 지워지고, 실행할 프로세스를 메모리에 올려 작업하기 때문에 다시 CPU를 할당받아 작업을 수행하려면 이어서 작업하는 것 보다 성능이 떨어진다.



## 문제 5. Windows의 선점형 멀티태스킹(preemptive multitasking)의 특징을 설명해주세요
  선점형 멀티태스킹은 우선순위가 높은 스레드가 실행 준비 되었을 때, 우선순위가 낮은 스레드가 실행중이라면 즉시 중단시키고 CPU를 선점하는 것을 의미한다. 이때 우선순위가 낮은 스레드가 계속 선점 당하여 실행되지 못하고 있는 상태를 기아상태라고 한다.



## 문제 6.`CreateThread`와 `_beginthreadex`의 차이점을 설명해주세요

CreateThread는 로우레벨에서 스레드를 생성하여 반환해주는 함수로 스레드 함수의 규격은 DWORD WINAPI를 따른다. 하지만 CreateThread는 C 런타임 초기화가 진행되지 않기 때문에 전역/정적 변수 초기화나 메모리 관련 작업이 제대로 이루어지지 않는 치명적인 문제가 발생할 수 있다. _beginthreadex는 C 런타임 초기화 후에 내부적으로 CreateThread를 호출하여 스레드르르 생성하는 함수로 안전하게 사용 가능하며 스레드 소멸시에 _endthreadex를 자동으로 호출하여 메모리 누락을 방지한다.





## 문제 7. 아래 코드의 빈칸을 채워 두 개의 스레드가 동시에 실행되도록 하세요
각 스레드는 “Thread A”, “Thread B” 메시지를 꼭 5번 출력해야 한다.

```cpp
#include <windows.h>
#include <iostream>

DWORD WINAPI PrintThread(LPVOID lpParam) {
    const char* name = static_cast<const char*>(lpParam);
    for (int i = 0; i < 5; i++) {
        std::cout << name << " 실행 중 (" << i+1 << "/5)" << std::endl;
        Sleep(500);
    }
    return 0;
}

int main() {
    HANDLE hA = CreateThread(NULL, 0, PrintThread, (LPVOID)"Thread A", 0, NULL);
    HANDLE hB = CreateThread(NULL, 0, PrintThread, (LPVOID)"Thread B", 0, NULL);
    HANDLE threads[] = {hA, hB};

    WaitForMultiObjects(2, threads, TRUE, INFINITE);
    CloseHandle(hA);
    CloseHandle(hB);
}
```



## 문제 8. 아래 코드의 출력이 3개의 스레드가 순차적으로 실행되도록 하려면 `Event` 객체를 사용해야 한다. `WaitForSingleObject`와 `SetEvent`를 적절히 배치하세요

```cpp
HANDLE startEvent = CreateEvent(NULL, FALSE, FALSE, NULL);   // 자동 리셋, non signaled

DWORD WINAPI Worker(LPVOID lpParam) {
    int id = (int)(size_t)lpParam;
    // (1) 이벤트 신호 대기
    WaitForSingleObject(startEvent, INFINITE);              // signaled 상태가 될때까지 무한 대기
    std::cout << "스레드 " << id << " 실행" << std::endl;
    return 0;
}

int main() {
    HANDLE h1 = CreateThread(NULL, 0, Worker, (LPVOID)1, 0, NULL);
    HANDLE h2 = CreateThread(NULL, 0, Worker, (LPVOID)2, 0, NULL);
    HANDLE h3 = CreateThread(NULL, 0, Worker, (LPVOID)3, 0, NULL);

    Sleep(1000);
    for (int i = 0; i < 3; i++) {
        std::cout << i + 1 << "번째 스레드 실행 신호" << std::endl;
        // (2) signaled
        SetEvent(startEvent);
        Sleep(1000);
    }
}
```



  
## 문제 9. Race Condition에 대해서 설명하세요. 혹은 발생하는 상황을 의사코드로 제시해도 괜찮습니다
경쟁 조건은 여러 스레드가 공유 자원에 동시에 접근할 때 잘못된 데이터가 발생하는 문제 상황을 의미한다.
예를 들어 int counter변수가 있고 스레드 A가 counter++명령어를 실행함과 거의 동시에 스레드 B가 counter변수를 읽는다면
스레드 B에서는 counter++이 되지 않은 값이 읽어져올 수 도 있다. 이러한 문제 상황을 경쟁 조건이라고 한다.



## 문제 10. Event의 Auto-Reset과 Manual-Reset 차이를 설명하세요
Auto-Reset(자동 리셋)은 대기중인 스레드가 깨어나면 자동으로 non-signaled상태로 바뀌어 한번 signaled가 되었을 때 하나의 스레드만 작업을 재개하게 되는 방식이다.
Manual-Reset(수동 리셋)은 대기중인 스레드가 깨어나도 계속 signaled 상태를 유지하며, non-signaled 상태는 직접 변경해주어야 하는 방식이다.


  

## 문제 11. 아래의 각각의 상황에 가장 적합한 동기화 객체를 고르고 이유를 간단히 쓰세요
a) 같은 프로세스 내 짧은 임계영역 보호가 핵심이다 
    >> CriticalSection
        크리티컬 섹션은 하나의 프로세스 안에서만 가능한 동기화 도구로 비용이 적기 때문에 간단한 락에는 이것을 사용한다.

b) 다수 프로세스가 하나의 로그 파일에 순차적으로 쓴다
    >> Mutex
        순차적으로 쓴다는 것은 한번에 하나의 스레드만 접근이 가능하다는 것이고, 다수의 프로세스 동기화를 위해서는 뮤텍스를 사용하여야 한다.

c) DB 연결 5개를 여러 스레드가 공유한다
    >> Semaphore
        세마포어는 카운터를 관리하여 여러 공유 자원의 관리에 적합하다.

d) “다운로드 완료” 신호가 오면 여러 워커가 동시에 후속 작업을 시작한다
    >> Event
        수동 리셋 이벤트를 사용하면 한번의 setevent()로 여러 워커들이 동시에 작업을 개제할 수 있다.




## 문제 12. Critical Section으로 BankAccount 보수하세요

**문제**
아래 코드의 `/* TODO */` 부분을 채워 스레드 안전한 입금/조회가 되게 하라.

```cpp
class ThreadSafeAccount {
    CRITICAL_SECTION cs;
    int balance = 0;
public:
    ThreadSafeAccount() { /* TODO: 초기화 */ CreateCriticalSection(cs);}
    ~ThreadSafeAccount() { /* TODO: 삭제 */ DeleteCriticalSection(cs);}

    void Deposit(int amount) {
        /* TODO: 진입 */
        EnterCriticalSection();
        int t = balance;
        Sleep(1);
        balance = t + amount;
        /* TODO: 해제 */
        ReleseCriticalSection();
    }

    int Get() {
        /* TODO: 진입 */
        EnterCriticalSection();
        int v = balance;
        /* TODO: 해제 */
        ReleseCriticalSection();
        return v;
    }
};
```

   


## 문제 13. Semaphore로 연결 최대치 3개인 풀의 진입/반납 로직을 완성하세요

```cpp
static const LONG MAX_CONN = 3;
HANDLE gSem = /* TODO: 초기값=3, 최대=3 세마포어 생성 */
                CreateSemaphore(NULL, 3, 3, 0);

void Acquire() {
    /* TODO: 세마포어 대기 (무기한) */
    WatieForSigleObject(gSem, INFINITE);
}

void Release() {
    /* TODO: 세마포어 카운트 1 증가 */
    ResetSemaphore(gSem);
}
```




## 문제 14: 보스 몬스터 등장 동기화

**문제 조건**
1.  `loadBoss` 스레드는 보스 몬스터를 로딩하는 역할이며, 3초의 시간이 걸린다.
2.  `enterBattle` 스레드들은 플레이어가 전투에 돌입하는 역할이다.
3.  플레이어들은 보스 로딩이 완료되기 전까지는 "보스 로딩을 기다리는 중..." 메시지를 출력하며 대기해야 한다.
4.  `loadBoss` 스레드는 로딩이 완료되면 `Event`를 `Set` 상태로 만들어 플레이어 스레드들에게 전투 시작을 알려야 한다.
5.  플레이어 스레드들은 `Event`가 `Set` 상태가 되면 대기를 멈추고 "전투 시작!" 메시지를 출력한다.

**미완성 코드**

```cpp
#include <iostream>
#include <windows.h>
#include <process.h>

HANDLE g_hBossReadyEvent; // 보스 준비 완료 이벤트

// 보스 몬스터를 로딩하는 스레드 함수
unsigned int __stdcall loadBoss(void* arg) {
    printf("보스 몬스터를 로딩 중입니다...\n");
    Sleep(3000); // 3초 동안 로딩
    printf("보스 로딩 완료!\n");

    // TODO: 보스 준비 완료 이벤트를 Set 상태로 만드세요.
    SetEvent(g_hBossReadyEvent);

    return 0;
}

// 플레이어가 전투에 참여하는 스레드 함수
unsigned int __stdcall enterBattle(void* arg) {
    int playerId = *(int*)arg;
    printf("Player %d, 보스 로딩을 기다리는 중...\n", playerId);

    // TODO: 보스 준비 완료 이벤트가 Set 상태가 될 때까지 기다리세요.
    WaitForSigleObject(g_hBossReadyEvent, INFINITE);

    printf("Player %d, 전투 시작!\n", playerId);
    return 0;
}

int main() 
{
    // TODO: Manual-reset, non-signaled 상태의 이벤트를 생성하세요.
    g_hBossReadyEvent = CreateEvent(NULL, TURE, FALSE, 0);

    if (g_hBossReadyEvent == NULL) {
        printf("이벤트 생성 실패\n");
        return 1;
    }

    HANDLE hBossThread = (HANDLE)_beginthreadex(NULL, 0, loadBoss, NULL, 0, NULL);

    const int NUM_PLAYERS = 5;
    HANDLE hPlayerThreads[NUM_PLAYERS];
    int playerIds[NUM_PLAYERS];
    for (int i = 0; i < NUM_PLAYERS; ++i) {
        playerIds[i] = i + 1;
        hPlayerThreads[i] = (HANDLE)_beginthreadex(NULL, 0, enterBattle, &playerIds[i], 0, NULL);
    }

    WaitForSingleObject(hBossThread, INFINITE);
    WaitForMultipleObjects(NUM_PLAYERS, hPlayerThreads, TRUE, INFINITE);

    CloseHandle(hBossThread);
    for (int i = 0; i < NUM_PLAYERS; ++i) {
        CloseHandle(hPlayerThreads[i]);
    }
    // TODO: 생성한 이벤트를 닫으세요.
    CloseHandle(g_hBossReadyEvent);

    return 0;
}
```    
    
 




## 문제 15. Critical Section, Mutex, Semaphore, Event의 일반적 성능 경향과 그 이유를 요약하세요

Critical Section은 프로세스 내 동기화 도구로 비용이 낮지만,  Mutex, Semaphore, Event는 프로세스 간의 동기화까지 가능하여 비용이 높다.



## 문제 16. 다음 코드에서 `InterlockedIncrement()`를 사용하는 이유를 설명하세요

```cpp
LONG counter = 0;
DWORD WINAPI ThreadProc(LPVOID) {
    for (int i = 0; i < 1000; i++)
        InterlockedIncrement(&counter);
    return 0;
}
```

InterlockedIncrement는 원자적으로 1을 증가시키는 함수로 작업이 중간이 끊기지 않기 때문에 다른 스레드가 counter에 접근하더라도 경쟁조건의 문제가 발생하지 않는다.



## 문제 17. 다음 두 코드 중에서 교착 상태가 발생하는 이유를 설명하세요

```cpp
// Thread A
EnterCriticalSection(&lockA);
EnterCriticalSection(&lockB);

// Thread B
EnterCriticalSection(&lockB);
EnterCriticalSection(&lockA);
```

스레드 A는 lockA 자원을 확보하고 B의 자원을 기다리고 있다. 
스레드 B는 lockB 자원을 확보하고 A의 자원을 기다리고 있다.
이 두 스레드는 확보된 서로의 자원을 영원히 기다리는 교착 상태에 빠지게 된다.


## 문제 18. `volatile` 키워드의 역할에 대해서 설명하세요

컴파일러에게 최적화를 하지 말라는 키워드이다. 컴파일러는 const 변수같은 최적화를 위해 경우 캐시에 올려놓고 빠르게 사용하는데, 만약 외부 스레드에서 해당 변수의 const를 제거해서 값을 변경한다면 캐시에 올려둔 상수값을 사용하는 곳은 이상한 값이 나올 것이다. 이 때 volatile키워드를 붙이면 이 문제를 방지할 수 있다.



## 문제 19: 단 한번만 실행되는 초기화 구현하세요

**요구사항:**
여러 스레드가 `InitializeResource()` 함수를 호출하지만, 실제 리소스 초기화 작업(`printf`로 대체)은 단 한 번만 수행되어야 한다. `Interlocked` 함수를 사용하여 첫 번째로 이 함수를 호출한 스레드만 초기화 코드를 실행하도록 만들자.

**실습 코드:**

```cpp
#include <windows.h>
#include <iostream>
#include <vector>

#define NUM_THREADS 5

LONG g_initialized = 0; // 0: 초기화 안됨, 1: 초기화 완료

void InitializeResource() {
    // TODO: g_initialized 값을 1로 바꾸되,
    // 오직 바꾸기 전의 값이 0이었던 스레드만 아래 "리소스 초기화" 코드를 실행하도록 만드세요.
    // 힌트: 값을 교환(Exchange)하고 이전 값을 반환하는 함수를 사용하세요.

    if (InterlockedExchange(g_initialized, 1, 0) == 0) 
    {
        printf("[Thread %lu] 리소스 초기화 수행!\n", GetCurrentThreadId());
    } 
    else 
    {
        printf("[Thread %lu] 이미 다른 스레드가 초기화를 완료했습니다.\n", GetCurrentThreadId());
    }
}

DWORD WINAPI ThreadProc(LPVOID lpParam) {
    InitializeResource();
    return 0;
}

int main() {
    std::vector<HANDLE> hThreads;
    for (int i = 0; i < NUM_THREADS; ++i) {
        HANDLE hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);
        if (hThread) {
            hThreads.push_back(hThread);
        }
    }

    WaitForMultipleObjects(hThreads.size(), hThreads.data(), TRUE, INFINITE);

    for (HANDLE hThread : hThreads) {
        CloseHandle(hThread);
    }
    return 0;
}
```




## 문제 20: CAS를 이용한 Lock-Free 데이터 업데이트

**요구사항:**
전역 변수 `g_value`가 있다. 스레드는 `g_value`가 특정 값(`expectedValue`)일 때만 새로운 값(`newValue`)으로 업데이트해야 한다. 이러한 '비교 후 교체' 연산을 Interlocked 함수 중 CAS 기능을 가진 함수를 사용하여 구현한다.

**실습 코드:**

```cpp
#include <windows.h>
#include <iostream>

LONG g_value = 100;

// g_value가 expectedValue와 같을 때만 newValue로 업데이트하는 함수
void UpdateValue(LONG newValue, LONG expectedValue) {
    LONG originalValue;

    // TODO: g_value의 현재 값이 expectedValue와 같으면 newValue로 교체하세요.
    // Interlocked 함수 중 CAS 기능을 가진 함수를 사용하고, 반환값(교체 전의 값)을 originalValue에 저장하세요.
    originalValue = InterlockedCompareExchanged(g_value, newValue, expectedValue);

    if (originalValue == expectedValue) {
        printf("[성공] 값이 %ld에서 %ld로 변경되었습니다.\n", originalValue, g_value);
    } else {
        printf("[실패] 값 변경 시도 실패. (기대값: %ld, 현재값: %ld)\n", expectedValue, originalValue);
    }
}

int main() {
    printf("초기값: %ld\n", g_value);

    // 성공 케이스: g_value가 100일 때 200으로 변경 시도
    UpdateValue(200, 100);

    // 실패 케이스: g_value가 100일 때 300으로 변경 시도 (기대값이 틀림)
    UpdateValue(300, 100); // 이 시점에서 g_value는 이미 200이므로 실패해야 함

    printf("최종값: %ld\n", g_value);
    return 0;
}
```


