<!DOCTYPE html><html lang="ko"><head><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>멀티스레드 프로그래밍의 현실적 어려움</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            overflow: hidden;
        }

        .presentation-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .slide {
            display: none;
            width: 90%;
            max-width: 1000px;
            height: 90%;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            padding: 60px;
            overflow-y: auto;
            animation: slideIn 0.5s ease-out;
        }

        .slide.active {
            display: block;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 30px;
            text-align: center;
            border-bottom: 3px solid #3498db;
            padding-bottom: 15px;
        }

        h2 {
            color: #e74c3c;
            font-size: 2em;
            margin-bottom: 25px;
            display: flex;
            align-items: center;
        }

        h2::before {
            content: "▶";
            margin-right: 15px;
            color: #3498db;
        }

        h3 {
            color: #8e44ad;
            font-size: 1.4em;
            margin: 20px 0 10px 0;
        }

        p, li {
            font-size: 1.1em;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .code-example {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.85em;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
            max-width: 100%;
        }

        .problem-box {
            background: #ffe6e6;
            border-left: 5px solid #e74c3c;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .solution-box {
            background: #e8f5e8;
            border-left: 5px solid #27ae60;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .controls {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 100;
        }

        .btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }

        .btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }

        .btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .slide-counter {
            position: fixed;
            top: 30px;
            right: 30px;
            background: rgba(255,255,255,0.9);
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            color: #2c3e50;
        }

        .real-example {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }

        .warning {
            background: #fff3cd;
            border-left: 5px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }

        ul {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        /* 반응형 디자인 */
        @media (max-width: 768px) {
            .slide {
                width: 95%;
                padding: 30px;
                height: 95%;
            }
            
            h1 {
                font-size: 1.8em;
            }
            
            h2 {
                font-size: 1.5em;
            }
            
            .code-example {
                font-size: 0.75em;
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="presentation-container">
        <div class="slide-counter">
            <span id="current-slide">1</span> / <span id="total-slides">12</span>
        </div>

        <!-- 슬라이드 1: 제목 -->
        <div class="slide active">
            <h1>실제 프로그램에서 멀티스레드 사용이 어려운 현실적 이유</h1>
            <div style="text-align: center; margin-top: 60px;">
                <p style="font-size: 1.3em; color: #7f8c8d; margin-bottom: 40px;">
                    "이론과 현실 사이의 깊은 골짜기"
                </p>
                <div style="background: #ecf0f1; padding: 30px; border-radius: 10px;">
                    <h3>발표 목차</h3>
                    <ul style="text-align: left; margin-top: 20px;">
                        <li>실제 회사에서 겪은 멀티스레드 재앙 사례</li>
                        <li>디버깅 지옥: 재현되지 않는 버그들</li>
                        <li>성능 향상? 오히려 성능 저하!</li>
                        <li>개발 팀이 겪는 현실적 문제들</li>
                        <li>대안적 해결책들</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- 슬라이드 2: 실제 사례 1 -->
        <div class="slide">
            <h2>실제 사례 1: 전자상거래 재고 관리 시스템</h2>
            
            <div class="real-example">
                <h3>🏢 상황: 대형 온라인 쇼핑몰</h3>
                <p>동시에 수천 명이 같은 상품을 주문하는 상황에서 재고 관리를 위해 멀티스레드 도입</p>
            </div>

            <div class="code-example">// 문제가 된 코드 (간소화된 버전)
class InventoryManager {
    private int stock = 100;
    
    public boolean purchaseItem() {
        if (stock &gt; 0) {           
            // 스레드 A, B 모두 체크 통과
            // 재고 확인과 차감 사이의 미세한 시간 간격
            Thread.sleep(1);       
            // 실제로는 DB 조회 시간
            stock--;               
            // 두 스레드가 모두 차감
            return true;
        }
        return false;
    }
}</div>

            <div class="problem-box">
                <h3>⚠️ 발생한 문제</h3>
                <ul>
                    <li><strong>음수 재고 발생:</strong> 재고가 1개인데 2명이 동시 구매 성공</li>
                    <li><strong>고객 클레임:</strong> 결제 완료 후 "재고 부족" 통보</li>
                    <li><strong>매출 손실:</strong> 신뢰도 하락으로 주요 고객 이탈</li>
                </ul>
            </div>

            <div class="warning">
                💰 <strong>비용:</strong> 버그 수정 및 보상에 3주 소요, 약 5억원 손실
            </div>
        </div>

        <!-- 슬라이드 3: 실제 사례 2 -->
        <div class="slide">
            <h2>실제 사례 2: 은행 계좌 이체 시스템</h2>
            
            <div class="real-example">
                <h3>🏦 상황: 인터넷 뱅킹 시스템</h3>
                <p>성능 향상을 위해 계좌 이체 로직에 멀티스레드 적용</p>
            </div>

            <div class="code-example">// 데드락이 발생한 코드 패턴
public void transfer(Account from, Account to, double amount) {
    synchronized(from) {
        synchronized(to) {
            from.withdraw(amount);
            to.deposit(amount);
        }
    }
}

// 스레드 1: transfer(계좌A, 계좌B, 1000)
// 스레드 2: transfer(계좌B, 계좌A, 500)  
// &lt;- 데드락 발생!</div>

            <div class="problem-box">
                <h3>💀 데드락 지옥</h3>
                <ul>
                    <li><strong>오후 2시경 시스템 완전 멈춤:</strong> 모든 이체 거래 중단</li>
                    <li><strong>원인 파악에 6시간 소요:</strong> 로그에서 명확한 오류 메시지 없음</li>
                    <li><strong>고객 불만 폭주:</strong> 급여 이체일과 겹쳐 대형 사고</li>
                </ul>
            </div>

            <div class="solution-box">
                <h3>🔧 최종 해결책</h3>
                <p><strong>멀티스레드 포기!</strong> 단일 스레드 + 큐 기반 처리로 변경<br>
                → 안정성 확보, 처리량도 오히려 개선됨</p>
            </div>
        </div>

        <!-- 슬라이드 4: 디버깅의 악몽 -->
        <div class="slide">
            <h2>디버깅의 악몽: 하이젠버그와 슈뢰딩거의 버그</h2>

            <div class="real-example">
                <h3>🔍 실제 겪은 디버깅 경험</h3>
                <p><strong>게임 회사 사례:</strong> 멀티플레이어 게임에서 간헐적 크래시</p>
            </div>

            <div class="problem-box">
                <h3>👻 하이젠버그 버그의 특징</h3>
                <ul>
                    <li><strong>운영에서만 발생:</strong> 개발/테스트 환경에서는 절대 재현 안됨</li>
                    <li><strong>디버거 연결시 사라짐:</strong> 관찰하려 하면 숨어버림</li>
                    <li><strong>로그 추가하면 사라짐:</strong> 타이밍이 미세하게 변경되어</li>
                    <li><strong>주말에만 발생:</strong> 사용자 패턴이 달라져서</li>
                </ul>
            </div>

            <div class="code-example">// 문제의 코드 - 로그 추가 전 (크래시 발생)
void processPlayerAction() {
    player.updatePosition();    // 스레드 A
    enemy.checkCollision();     // 스레드 B
    // 미세한 타이밍 이슈로 크래시
}

// 로그 추가 후 (크래시 사라짐!)
void processPlayerAction() {
    System.out.println("Processing..."); 
    // 이 한 줄로 타이밍 변경
    player.updatePosition();
    enemy.checkCollision();
}</div>

            <div class="warning">
                ⏱️ <strong>해결 시간:</strong> 2명의 시니어 개발자가 3주간 매달려도 원인 파악 실패<br>
                결국 전체 아키텍처 단순화로 해결
            </div>
        </div>

        <!-- 슬라이드 5: 성능 오해 -->
        <div class="slide">
            <h2>성능 향상? 오히려 성능 저하!</h2>

            <div class="real-example">
                <h3>📊 실제 성능 측정 결과</h3>
                <p><strong>웹 크롤러 프로젝트:</strong> "스레드 늘리면 빨라질 거야!"</p>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                <div class="problem-box">
                    <h3>❌ 기대했던 것</h3>
                    <ul>
                        <li>스레드 1개: 100페이지/분</li>
                        <li>스레드 10개: 1000페이지/분</li>
                        <li>스레드 100개: 10000페이지/분</li>
                    </ul>
                </div>
                <div class="warning">
                    <h3>😱 실제 결과</h3>
                    <ul>
                        <li>스레드 1개: 100페이지/분</li>
                        <li>스레드 10개: 80페이지/분</li>
                        <li>스레드 100개: 20페이지/분</li>
                    </ul>
                </div>
            </div>

            <div class="code-example">// 문제 분석: 병목점은 스레드가 아니었다!
class WebCrawler {
    // 1. 네트워크 I/O 병목 (서버측 제한)
    // 2. 디스크 쓰기 병목 (하나의 파일에 동시 쓰기)
    // 3. 메모리 부족 (스레드당 스택 메모리)
    // 4. 컨텍스트 스위칭 오버헤드
    
    // 실제 개선 방법: 비동기 I/O + 배치 처리
}</div>

            <div class="solution-box">
                <h3>💡 교훈</h3>
                <p>스레드 추가하기 전에 <strong>프로파일링</strong>으로 진짜 병목점 찾기!<br>
                대부분의 경우 I/O, 알고리즘, 메모리 사용량이 문제</p>
            </div>
        </div>

        <!-- 슬라이드 6: 팀 차원의 문제 -->
        <div class="slide">
            <h2>개발팀이 겪는 현실적 문제들</h2>

            <div class="real-example">
                <h3>👥 스타트업 A사의 경험담</h3>
                <p>5명 개발팀, 시니어 1명 + 주니어 4명</p>
            </div>

            <div class="problem-box">
                <h3>🎯 학습 곡선 문제</h3>
                <ul>
                    <li><strong>시니어 개발자:</strong> 멀티스레드 설계 가능하지만 시간 부족</li>
                    <li><strong>주니어 개발자:</strong> synchronized만 알고 있음</li>
                    <li><strong>코드 리뷰:</strong> 동시성 버그 찾아내기 어려움</li>
                    <li><strong>지식 전파:</strong> 복잡한 개념 설명하기 힘듦</li>
                </ul>
            </div>

            <div class="warning">
                <h3>⏰ 일정 압박의 현실</h3>
                <p>"일단 동작하게 만들고, 나중에 최적화하자"<br>
                → 기술부채 누적 → 수정 불가능한 지경에 도달</p>
            </div>

            <div class="code-example">// 주니어가 작성한 "안전한" 코드
synchronized void doEverything() {  
    // 메서드 전체에 락!
    // 100줄의 복잡한 로직
    // 성능은 끔찍하지만 "안전"
}

// 시니어가 짜려던 복잡한 코드 (시간 부족으로 포기)
class OptimizedSolution {
    private final ReadWriteLock lock = 
        new ReentrantReadWriteLock();
    private final ConcurrentHashMap<string, atomicinteger=""> 
        counters;
    // ... 복잡한 lock-free 알고리즘
}</string,></div>
        </div>

        <!-- 슬라이드 7: 테스트의 한계 -->
        <div class="slide">
            <h2>테스트의 한계: 동시성은 어떻게 테스트하나?</h2>

            <div class="real-example">
                <h3>🧪 실제 테스트 시도 사례</h3>
                <p><strong>채팅 서버 개발팀:</strong> 1000명 동시 접속 처리 테스트</p>
            </div>

            <div class="problem-box">
                <h3>🎭 테스트의 함정들</h3>
                <ul>
                    <li><strong>단위 테스트:</strong> 멀티스레드 환경 재현 불가</li>
                    <li><strong>통합 테스트:</strong> 타이밍 이슈로 간헐적 실패</li>
                    <li><strong>부하 테스트:</strong> 테스트 환경 ≠ 운영 환경</li>
                    <li><strong>CI/CD:</strong> 동시성 테스트로 파이프라인 불안정</li>
                </ul>
            </div>

            <div class="code-example">// 멀티스레드 테스트의 어려움
@Test
public void testConcurrency() {
    ExecutorService executor = 
        Executors.newFixedThreadPool(100);
    CountDownLatch latch = new CountDownLatch(100);
    
    for (int i = 0; i &lt; 100; i++) {
        executor.submit(() -&gt; {
            // 이 테스트는...
            myService.doSomething();  // 때로는 성공
            latch.countDown();        // 때로는 실패
        });                          // 예측 불가!
    }
    
    latch.await();
    // 결과 검증도 애매함
}</div>

            <div class="warning">
                <h3>📈 테스트 결과</h3>
                <p><strong>로컬:</strong> 10번 중 1번 실패<br>
                <strong>CI:</strong> 10번 중 5번 실패<br>
                <strong>운영:</strong> 하루에 2-3번 이상 현상 발생</p>
            </div>
        </div>

        <!-- 슬라이드 8: 플랫폼별 차이 -->
        <div class="slide">
            <h2>플랫폼과 환경별 차이점</h2>

            <div class="real-example">
                <h3>🌍 글로벌 서비스의 악몽</h3>
                <p><strong>모바일 게임 회사:</strong> 안드로이드/iOS 멀티스레드 구현</p>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div class="problem-box">
                    <h3>📱 Android에서</h3>
                    <ul>
                        <li>메모리 압박으로 OOM 발생</li>
                        <li>GC로 인한 프레임 드롭</li>
                        <li>디바이스별 성능 편차</li>
                    </ul>
                </div>
                <div class="problem-box">
                    <h3>🍎 iOS에서</h3>
                    <ul>
                        <li>메모리 경고로 앱 종료</li>
                        <li>백그라운드 스레드 제한</li>
                        <li>App Store 리젝</li>
                    </ul>
                </div>
            </div>

            <div class="code-example">// 같은 코드, 다른 결과
class GameEngine {
    void updatePhysics() {
        // Java/Android: GC 때문에 끊김
        // Swift/iOS: ARC 때문에 다른 타이밍
        // C++/Windows: 또 다른 스케줄링
        
        // 결국 플랫폼별로 다른 코드 작성 필요
    }
}</div>

            <div class="warning">
                <h3>💸 결과</h3>
                <p>하나의 로직을 플랫폼별로 3번 구현<br>
                → 개발 시간 3배, 버그 발생률 5배 증가</p>
            </div>
        </div>

        <!-- 슬라이드 9: 현대적 대안들 -->
        <div class="slide">
            <h2>현대적 대안들: 멀티스레드 없이도 잘 살 수 있다</h2>

            <div class="solution-box">
                <h3>🚀 Node.js의 성공 사례</h3>
                <p>단일 스레드 + 이벤트 루프로 높은 동시성 달성</p>
            </div>

            <div class="code-example">// 비동기 처리 - 멀티스레드 없이도 동시성
async function handleRequest(req, res) {
    const user = await database.getUser(req.userId);     
    // 논블로킹
    const posts = await database.getPosts(user.id);     
    // 논블로킹
    const comments = await database.getComments(posts); 
    // 논블로킹
    
    res.json({ user, posts, comments });
    // 스레드 안전성 걱정 없음!
}</div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div class="solution-box">
                    <h3>✅ 비동기 프로그래밍</h3>
                    <ul>
                        <li>async/await 패턴</li>
                        <li>Promise 기반 처리</li>
                        <li>콜백 지옥 해결</li>
                        <li>디버깅 용이</li>
                    </ul>
                </div>
                <div class="solution-box">
                    <h3>⚡ 액터 모델</h3>
                    <ul>
                        <li>Erlang/Elixir</li>
                        <li>Akka (Scala/Java)</li>
                        <li>메시지 전달 방식</li>
                        <li>고립된 상태</li>
                    </ul>
                </div>
            </div>

            <div class="real-example">
                <h3>📊 실제 성능 비교 (대용량 웹 서버)</h3>
                <p><strong>멀티스레드 서버:</strong> 1만 동시 연결시 메모리 부족<br>
                <strong>Node.js 서버:</strong> 10만 동시 연결 처리 가능</p>
            </div>
        </div>

        <!-- 슬라이드 10: 함수형 프로그래밍 -->
        <div class="slide">
            <h2>함수형 프로그래밍: 불변성의 힘</h2>

            <div class="solution-box">
                <h3>🛡️ 불변 데이터의 장점</h3>
                <p>데이터가 변하지 않으면 동시성 문제 자동 해결!</p>
            </div>

            <div class="code-example">// 전통적인 방식 (문제 발생)
class Counter {
    private int count = 0;
    
    public void increment() {  
        // 스레드 안전하지 않음
        count++;
    }
}

// 함수형 방식 (안전함)
class ImmutableCounter {
    private final int count;
    
    public ImmutableCounter(int count) {
        this.count = count;
    }
    
    public ImmutableCounter increment() {  
        // 새 객체 반환
        return new ImmutableCounter(count + 1);
    }
}</div>

            <div class="real-example">
                <h3>🌟 실제 적용 사례: 금융회사 거래 시스템</h3>
                <ul>
                    <li><strong>도입 전:</strong> 락으로 인한 성능 저하, 데드락 빈발</li>
                    <li><strong>도입 후:</strong> 처리량 300% 증가, 버그 90% 감소</li>
                    <li><strong>개발 시간:</strong> 초기 2주 학습 후 오히려 빨라짐</li>
                </ul>
            </div>

            <div class="solution-box">
                <h3>🔧 추천 도구들</h3>
                <p><strong>언어:</strong> Clojure, Haskell, F#<br>
                <strong>라이브러리:</strong> Immutable.js, Vavr (Java)<br>
                <strong>패러다임:</strong> Redux, MobX (상태 관리)</p>
            </div>
        </div>

        <!-- 슬라이드 11: 실용적 권장사항 -->
        <div class="slide">
            <h2>실무에서 적용할 수 있는 현실적 권장사항</h2>

            <div class="solution-box">
                <h3>🎯 멀티스레드를 고려하기 전에 체크리스트</h3>
            </div>

            <div style="margin: 20px 0;">
                <h3>1단계: 진짜 필요한가?</h3>
                <ul>
                    <li>✅ 프로파일링으로 CPU 병목 확인했는가?</li>
                    <li>✅ 알고리즘 최적화를 시도했는가?</li>
                    <li>✅ 데이터베이스 쿼리를 최적화했는가?</li>
                    <li>✅ 캐싱을 적용했는가?</li>
                </ul>
            </div>

            <div style="margin: 20px 0;">
                <h3>2단계: 대안은 없는가?</h3>
                <ul>
                    <li>🔄 비동기 프로그래밍으로 해결 가능한가?</li>
                    <li>📦 마이크로서비스로 분할 가능한가?</li>
                    <li>☁️ 클라우드 스케일링으로 해결 가능한가?</li>
                    <li>🛠️ 검증된 라이브러리가 있는가?</li>
                </ul>
            </div>

            <div class="warning">
                <h3>⚠️ 정말 멀티스레드가 필요하다면</h3>
                <ul>
                    <li><strong>팀 역량 평가:</strong> 시니어 개발자 2명 이상 필요</li>
                    <li><strong>개발 기간:</strong> 예상 시간의 3배 할당</li>
                    <li><strong>테스트 환경:</strong> 부하 테스트 인프라 구축</li>
                    <li><strong>모니터링:</strong> 상세한 로깅과 메트릭 수집</li>
                </ul>
            </div>
        </div>

        <!-- 슬라이드 12: 결론 -->
        <div class="slide">
            <h2>결론: 멀티스레드는 만능이 아니다</h2>

            <div class="real-example">
                <h3>💡 핵심 메시지</h3>
                <p style="font-size: 1.3em; text-align: center; color: #e74c3c; font-weight: bold;">
                    "복잡성 추가 전에 단순한 해결책부터 찾아라"
                </p>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin: 30px 0;">
                <div class="problem-box">
                    <h3>❌ 멀티스레드가 필요 없는 경우</h3>
                    <ul>
                        <li>I/O 바운드 작업</li>
                        <li>네트워크 통신 위주</li>
                        <li>사용자 상호작용 처리</li>
                        <li>일반적인 웹 애플리케이션</li>
                        <li>CRUD 중심 시스템</li>
                    </ul>
                </div>
                <div class="solution-box">
                    <h3>✅ 정말 필요한 경우</h3>
                    <ul>
                        <li>CPU 집약적 계산</li>
                        <li>실시간 게임 엔진</li>
                        <li>고성능 수치 계산</li>
                        <li>동영상/이미지 처리</li>
                        <li>기계학습 모델 학습</li>
                    </ul>
                </div>
            </div>

            <div class="solution-box">
                <h3>🎯 실무 조언</h3>
                <ol>
                    <li><strong>측정 먼저:</strong> 추측하지 말고 프로파일링으로 확인</li>
                    <li><strong>단순함 우선:</strong> 복잡한 해결책은 마지막 선택지</li>
                    <li><strong>검증된 도구:</strong> 바퀴를 다시 발명하지 말 것</li>
                    <li><strong>팀 역량 고려:</strong> 유지보수 가능한 코드가 최고</li>
                </ol>
            </div>

            <div style="text-align: center; margin-top: 40px; font-style: italic; color: #7f8c8d;">
                "가장 빠른 코드는 실행되지 않는 코드이고,<br>
                가장 안전한 멀티스레드 코드는 작성되지 않은 코드다"
            </div>
        </div>
    </div>

    <div class="controls">
        <button class="btn" id="prevBtn" onclick="changeSlide(-1)">◀ 이전</button>
        <button class="btn" id="nextBtn" onclick="changeSlide(1)">다음 ▶</button>
    </div>

    <script>
        let currentSlide = 0;
        const slides = document.querySelectorAll('.slide');
        const totalSlides = slides.length;

        document.getElementById('total-slides').textContent = totalSlides;

        function showSlide(n) {
            slides[currentSlide].classList.remove('active');
            currentSlide = (n + totalSlides) % totalSlides;
            slides[currentSlide].classList.add('active');
            
            document.getElementById('current-slide').textContent = currentSlide + 1;
            
            // 버튼 상태 업데이트
            document.getElementById('prevBtn').disabled = currentSlide === 0;
            document.getElementById('nextBtn').disabled = currentSlide === totalSlides - 1;
        }

        function changeSlide(direction) {
            if (direction === 1 && currentSlide < totalSlides - 1) {
                showSlide(currentSlide + 1);
            } else if (direction === -1 && currentSlide > 0) {
                showSlide(currentSlide - 1);
            }
        }

        // 키보드 이벤트
        document.addEventListener('keydown', function(event) {
            if (event.key === 'ArrowRight' || event.key === ' ') {
                changeSlide(1);
            } else if (event.key === 'ArrowLeft') {
                changeSlide(-1);
            }
        });

        // 초기 상태 설정
        showSlide(0);
    </script>


</body></html>