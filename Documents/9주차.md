# 9ì£¼ì°¨ C++ STL ìŠ¤ë ˆë“œ í”„ë¡œê·¸ë˜ë° 3
    
## std::atomic - ì›ìì  ì—°ì‚°ê³¼ ë©”ëª¨ë¦¬ ë™ê¸°í™”
ë©€í‹°ìŠ¤ë ˆë“œ í”„ë¡œê·¸ë˜ë°ì—ì„œ ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì¼í•œ ë°ì´í„°ì— ì ‘ê·¼í•  ë•Œ **ë°ì´í„° ë ˆì´ìŠ¤(data race)**ê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤. `std::atomic`ì€ ì´ëŸ¬í•œ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ **ì›ìì (atomic) ì—°ì‚°**ì„ ì œê³µí•˜ëŠ” í…œí”Œë¦¿ í´ë˜ìŠ¤ì´ë‹¤.

### ì›ìì  ì—°ì‚°ì´ë€?
ì›ìì  ì—°ì‚°ì€ **ì¤‘ë‹¨ë  ìˆ˜ ì—†ëŠ” ë‹¨ì¼ ì—°ì‚°**ì´ë‹¤. ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ì¤‘ê°„ ìƒíƒœë¥¼ ê´€ì°°í•  ìˆ˜ ì—†ìœ¼ë©°, ì—°ì‚°ì´ ì™„ì „íˆ ì‹¤í–‰ë˜ê±°ë‚˜ ì „í˜€ ì‹¤í–‰ë˜ì§€ ì•ŠëŠ”ë‹¤.

```
ì¼ë°˜ ë³€ìˆ˜ (ë¹„ì›ìì ):
Thread 1: [ì½ê¸°] â†’ [ìˆ˜ì •] â†’ [ì“°ê¸°]
Thread 2:      [ì½ê¸°] â†’ [ìˆ˜ì •] â†’ [ì“°ê¸°]  âŒ ë°ì´í„° ë ˆì´ìŠ¤!

atomic ë³€ìˆ˜ (ì›ìì ):
Thread 1: [ì½ê¸°-ìˆ˜ì •-ì“°ê¸° (ì›ìì )]
Thread 2:                          [ì½ê¸°-ìˆ˜ì •-ì“°ê¸° (ì›ìì )] âœ“ ì•ˆì „!
```

### ì™œ std::atomicì´ í•„ìš”í•œê°€?
ë‹¤ìŒ ì½”ë“œë¥¼ ë³´ì:

```cpp
#include <iostream>
#include <thread>
#include <vector>

int counter = 0;  // ì¼ë°˜ ë³€ìˆ˜

void increment() {
    for (int i = 0; i < 100000; ++i) {
        ++counter;  // ì›ìì ì´ì§€ ì•ŠìŒ!
    }
}

int main() {
    std::vector<std::thread> threads;
    
    for (int i = 0; i < 10; ++i) {
        threads.emplace_back(increment);
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    std::cout << "ì˜ˆìƒ ê²°ê³¼: " << 1000000 << "\n";
    std::cout << "ì‹¤ì œ ê²°ê³¼: " << counter << "\n";  // 1000000ë³´ë‹¤ ì‘ì€ ê°’!
    
    return 0;
}
```

**ë¬¸ì œì **: `++counter`ëŠ” ì‹¤ì œë¡œ ì„¸ ë‹¨ê³„ë¡œ ì´ë£¨ì–´ì§„ë‹¤:
1. ë©”ëª¨ë¦¬ì—ì„œ ê°’ ì½ê¸°
2. ê°’ ì¦ê°€
3. ë©”ëª¨ë¦¬ì— ì“°ê¸°

ì´ ë‹¨ê³„ë“¤ ì‚¬ì´ì— ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ë¼ì–´ë“¤ ìˆ˜ ìˆì–´ ì˜ˆìƒì¹˜ ëª»í•œ ê²°ê³¼ê°€ ë°œìƒí•œë‹¤.
  
</br>  
  

## std::atomic ê¸°ë³¸ ì‚¬ìš©ë²•

### ì„ ì–¸ê³¼ ì´ˆê¸°í™”

```cpp
#include <atomic>

std::atomic<int> counter1;           // ê¸°ë³¸ ì´ˆê¸°í™” (0)
std::atomic<int> counter2(100);      // ê°’ ì´ˆê¸°í™”
std::atomic<int> counter3{200};      // ì¤‘ê´„í˜¸ ì´ˆê¸°í™” (ê¶Œì¥)

std::atomic<bool> flag{false};
std::atomic<double> value{3.14};
std::atomic<int*> ptr{nullptr};
```

### ì•ˆì „í•œ ì¹´ìš´í„° ì˜ˆì œ

```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <atomic>

std::atomic<int> counter{0};  // atomic ë³€ìˆ˜

void increment() {
    for (int i = 0; i < 100000; ++i) {
        ++counter;  // ì›ìì  ì¦ê°€!
    }
}

int main() {
    std::vector<std::thread> threads;
    
    for (int i = 0; i < 10; ++i) {
        threads.emplace_back(increment);
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    std::cout << "ì˜ˆìƒ ê²°ê³¼: " << 1000000 << "\n";
    std::cout << "ì‹¤ì œ ê²°ê³¼: " << counter << "\n";  // ì •í™•íˆ 1000000!
    
    return 0;
}
```
  
</br>  
  

## ì£¼ìš” API

### ê¸°ë³¸ ì—°ì‚°

```cpp
#include <atomic>
#include <iostream>

int main() {
    std::atomic<int> value{10};
    
    // ì½ê¸°
    int current = value.load();
    std::cout << "í˜„ì¬ ê°’: " << current << "\n";
    
    // ì“°ê¸°
    value.store(20);
    std::cout << "ì €ì¥ í›„: " << value << "\n";
    
    // êµí™˜ (exchange): ìƒˆ ê°’ìœ¼ë¡œ ì„¤ì •í•˜ê³  ì´ì „ ê°’ ë°˜í™˜
    int old = value.exchange(30);
    std::cout << "ì´ì „ ê°’: " << old << ", í˜„ì¬ ê°’: " << value << "\n";
    
    return 0;
}
```

### Compare-And-Swap (CAS)
ê°€ì¥ ê°•ë ¥í•œ ì›ìì  ì—°ì‚° ì¤‘ í•˜ë‚˜ì´ë‹¤:  

```cpp
#include <atomic>
#include <iostream>

int main() {
    std::atomic<int> value{100};
    
    int expected = 100;
    int desired = 200;
    
    // compare_exchange_strong:
    // value == expectedì´ë©´ valueë¥¼ desiredë¡œ ë³€ê²½í•˜ê³  true ë°˜í™˜
    // ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ expectedë¥¼ valueë¡œ ê°±ì‹ í•˜ê³  false ë°˜í™˜
    
    if (value.compare_exchange_strong(expected, desired)) {
        std::cout << "ì„±ê³µ: " << value << "\n";  // 200
    } else {
        std::cout << "ì‹¤íŒ¨. ì‹¤ì œ ê°’ì€: " << expected << "\n";
    }
    
    // ë‹¤ì‹œ ì‹œë„ (ì´ë²ˆì—” ì‹¤íŒ¨)
    expected = 100;  // ì˜ëª»ëœ ì˜ˆìƒ ê°’
    if (value.compare_exchange_strong(expected, 300)) {
        std::cout << "ì„±ê³µ\n";
    } else {
        std::cout << "ì‹¤íŒ¨. ì‹¤ì œ ê°’ì€: " << expected << "\n";  // 200
    }
    
    return 0;
}
```

### ì‚°ìˆ  ì—°ì‚° (ì •ìˆ˜í˜•ì—ë§Œ í•´ë‹¹)

```cpp
#include <atomic>
#include <iostream>

int main() {
    std::atomic<int> counter{0};
    
    counter++;           // í›„ìœ„ ì¦ê°€
    ++counter;           // ì „ìœ„ ì¦ê°€
    counter += 5;        // ë§ì…ˆ ëŒ€ì…
    counter -= 2;        // ëº„ì…ˆ ëŒ€ì…
    
    int prev = counter.fetch_add(10);  // ì¦ê°€ ì „ ê°’ ë°˜í™˜
    std::cout << "ì´ì „ ê°’: " << prev << ", í˜„ì¬ ê°’: " << counter << "\n";
    
    prev = counter.fetch_sub(3);       // ê°ì†Œ ì „ ê°’ ë°˜í™˜
    std::cout << "ì´ì „ ê°’: " << prev << ", í˜„ì¬ ê°’: " << counter << "\n";
    
    return 0;
}
```

### ë¹„íŠ¸ ì—°ì‚° (ì •ìˆ˜í˜•ì—ë§Œ í•´ë‹¹)

```cpp
#include <atomic>
#include <iostream>
#include <bitset>

int main() {
    std::atomic<unsigned int> flags{0b0000};
    
    flags |= 0b0001;  // ë¹„íŠ¸ ì„¤ì •
    std::cout << "OR í›„: " << std::bitset<4>(flags.load()) << "\n";
    
    flags &= 0b0011;  // ë¹„íŠ¸ ë§ˆìŠ¤í‚¹
    std::cout << "AND í›„: " << std::bitset<4>(flags.load()) << "\n";
    
    flags ^= 0b0010;  // ë¹„íŠ¸ í† ê¸€
    std::cout << "XOR í›„: " << std::bitset<4>(flags.load()) << "\n";
    
    // fetch_* ë²„ì „ë„ ì‚¬ìš© ê°€ëŠ¥
    unsigned int prev = flags.fetch_or(0b1000);
    std::cout << "ì´ì „: " << std::bitset<4>(prev) 
              << ", í˜„ì¬: " << std::bitset<4>(flags.load()) << "\n";
    
    return 0;
}
```
  
</br>  
  

## ë©”ëª¨ë¦¬ ìˆœì„œ(Memory Order)
`std::atomic`ì˜ ì§„ì •í•œ í˜ì€ **ë©”ëª¨ë¦¬ ìˆœì„œ ì œì–´**ì— ìˆë‹¤. ì´ë¥¼ í†µí•´ ì„±ëŠ¥ê³¼ ì•ˆì „ì„± ì‚¬ì´ì˜ ê· í˜•ì„ ì¡°ì ˆí•  ìˆ˜ ìˆë‹¤.

```
ë©”ëª¨ë¦¬ ìˆœì„œ ê°•ë„:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  memory_order_relaxed    (ê°€ì¥ ì•½í•¨)    â”‚  â† ì¬ë°°ì¹˜ í—ˆìš©, ìˆœì„œ ë³´ì¥ ì—†ìŒ
â”‚  memory_order_consume                  â”‚
â”‚  memory_order_acquire                  â”‚  â† íšë“-í•´ì œ ì˜ë¯¸ë¡ 
â”‚  memory_order_release                  â”‚
â”‚  memory_order_acq_rel                  â”‚
â”‚  memory_order_seq_cst    (ê°€ì¥ ê°•í•¨)    â”‚  â† ìˆœì°¨ ì¼ê´€ì„± (ê¸°ë³¸ê°’)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### memory_order_seq_cst (ê¸°ë³¸ê°’)
ê°€ì¥ ê°•ë ¥í•˜ì§€ë§Œ ê°€ì¥ ëŠë¦¬ë‹¤. ëª¨ë“  ìŠ¤ë ˆë“œê°€ ë™ì¼í•œ ìˆœì„œë¡œ ì—°ì‚°ì„ ê´€ì°°í•œë‹¤.

```cpp
#include <atomic>
#include <thread>
#include <iostream>

std::atomic<int> x{0};
std::atomic<int> y{0};

void thread1() {
    x.store(1, std::memory_order_seq_cst);  // ê¸°ë³¸ê°’
    int r1 = y.load(std::memory_order_seq_cst);
}

void thread2() {
    y.store(1, std::memory_order_seq_cst);
    int r2 = x.load(std::memory_order_seq_cst);
}

// r1 == 0 && r2 == 0 ì€ ë¶ˆê°€ëŠ¥ (ìˆœì°¨ ì¼ê´€ì„± ë³´ì¥)
```

### memory_order_relaxed
ìˆœì„œ ë³´ì¥ ì—†ì´ ì›ìì„±ë§Œ ë³´ì¥í•œë‹¤. ê°€ì¥ ë¹ ë¥´ì§€ë§Œ ì‹ ì¤‘í•˜ê²Œ ì‚¬ìš©í•´ì•¼ í•œë‹¤.

```cpp
#include <atomic>
#include <thread>
#include <iostream>
#include <vector>

std::atomic<int> counter{0};

void increment_relaxed() {
    for (int i = 0; i < 100000; ++i) {
        counter.fetch_add(1, std::memory_order_relaxed);
    }
}

int main() {
    std::vector<std::thread> threads;
    
    for (int i = 0; i < 10; ++i) {
        threads.emplace_back(increment_relaxed);
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    // ìµœì¢… ê°’ì€ ì •í™• (ì›ìì„± ë³´ì¥)
    // í•˜ì§€ë§Œ ì¤‘ê°„ ê°’ì˜ ê´€ì°° ìˆœì„œëŠ” ë³´ì¥ë˜ì§€ ì•ŠìŒ
    std::cout << "ê²°ê³¼: " << counter << "\n";  // 1000000
    
    return 0;
}
```

### memory_order_acquire / release
ìƒì‚°ì-ì†Œë¹„ì íŒ¨í„´ì— ì´ìƒì ì´ë‹¤.

```cpp
#include <atomic>
#include <thread>
#include <iostream>
#include <cassert>

std::atomic<bool> ready{false};
int data = 0;  // ì¼ë°˜ ë³€ìˆ˜

void producer() {
    data = 100;  // ë°ì´í„° ì¤€ë¹„
    ready.store(true, std::memory_order_release);  // í•´ì œ: ì´ì „ ì“°ê¸°ë“¤ì´ ê°€ì‹œí™”
}

void consumer() {
    while (!ready.load(std::memory_order_acquire)) {  // íšë“: ì´í›„ ì½ê¸°ë“¤ì´ ë³´í˜¸ë¨
        // ëŒ€ê¸°
    }
    assert(data == 100);  // í•­ìƒ ì°¸! (íšë“-í•´ì œ ì˜ë¯¸ë¡ )
    std::cout << "ë°ì´í„°: " << data << "\n";
}

int main() {
    std::thread t1(producer);
    std::thread t2(consumer);
    
    t1.join();
    t2.join();
    
    return 0;
}
```

**ì‘ë™ ì›ë¦¬**:
```
Producer ìŠ¤ë ˆë“œ:
  data = 100;        â”€â”€â”€â”
  release (ready)       â”‚ í•´ì œ: ì´ ì„  ìœ„ì˜ ëª¨ë“  ì“°ê¸°ê°€
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€ ì•„ë˜ë¡œ ì¬ë°°ì¹˜ ì•ˆ ë¨

Consumer ìŠ¤ë ˆë“œ:
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€ íšë“: ì´ ì„  ì•„ë˜ì˜ ëª¨ë“  ì½ê¸°ê°€
  acquire (ready)       â”‚ ìœ„ë¡œ ì¬ë°°ì¹˜ ì•ˆ ë¨
  assert(data==100)  â”€â”€â”€â”˜
```
  

## memory_order_acquire/memory_order_release ì™€ memory_order_relaxed/memory_order_consume ëª¨ë¸ê°„ì˜ ì°¨ì´  
C++ ë©”ëª¨ë¦¬ ìˆœì„œ(Memory Order)ëŠ” ë©€í‹°ì½”ì–´ CPUì™€ ì»´íŒŒì¼ëŸ¬ê°€ ì½”ë“œë¥¼ ì–´ë–»ê²Œ ì¬ë°°ì¹˜(reordering)í•  ìˆ˜ ìˆëŠ”ì§€ë¥¼ ì œì–´í•˜ëŠ” ê·œì¹™ì´ë‹¤.

ê°€ì¥ í° ì°¨ì´ì ì€ **`acquire`/`release`ëŠ” ìŠ¤ë ˆë“œ ê°„ì˜ ë©”ëª¨ë¦¬ ê°€ì‹œì„±(visibility)ê³¼ ìˆœì„œë¥¼ ë³´ì¥**í•˜ëŠ” **ë™ê¸°í™”(Synchronization)** ë¥¼ ìˆ˜í–‰í•œë‹¤. ë°˜ë©´, **`relaxed`ëŠ” ë‹¨ì§€ ì›ìì„±(atomicity)ë§Œ ë³´ì¥**í•  ë¿, ë©”ëª¨ë¦¬ ìˆœì„œë¥¼ ì „í˜€ ë³´ì¥í•˜ì§€ ì•ŠëŠ”ë‹¤.

`consume`ì€ `acquire`ì˜ ì•½í•œ ë²„ì „ì´ì—ˆì§€ë§Œ, ì§€ê¸ˆì€ ì‚¬ì‹¤ìƒ `acquire`ì™€ ë™ì¼í•˜ê²Œ ì·¨ê¸‰ëœë‹¤.

### 1. ğŸ”‘ í•µì‹¬ ìš”ì•½: ë™ê¸°í™” vs ì›ìì„±
ì´ ë‘˜ì„ ì´í•´í•˜ëŠ” ê²ƒì´ ê°€ì¥ ì¤‘ìš”í•˜ë‹¤.

  * **ì›ìì„± (Atomicity) - (`relaxed`ê°€ ë³´ì¥)**

      * `atomic_var = 10;`ì´ë¼ëŠ” ëª…ë ¹ì´ ìˆì„ ë•Œ, ì´ ì‘ì—…ì´ ì‹¤í–‰ë˜ëŠ” ë„ì¤‘ì— ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ë¼ì–´ë“¤ì–´ `atomic_var`ì˜ ê°’ì´ `5` ê°™ì€ ì—‰ëš±í•œ ê°’(Torn Write)ì´ ë˜ëŠ” ê²ƒì„ ë§‰ì•„ì¤€ë‹¤.
      * **ì¦‰, í•´ë‹¹ ë³€ìˆ˜ *ìì²´*ì˜ ì½ê¸°/ì“°ê¸°ë§Œ ë³´í˜¸í•œë‹¤.**

  * **ë™ê¸°í™” ë° ìˆœì„œ (Synchronization & Ordering) - (`acquire`/`release`ê°€ ë³´ì¥)**

      * ì›ìì„±ë¿ë§Œ ì•„ë‹ˆë¼, **ë‹¤ë¥¸ ë³€ìˆ˜ë“¤**ì˜ ë©”ëª¨ë¦¬ ì ‘ê·¼ ìˆœì„œê¹Œì§€ ì œì–´í•œë‹¤.
      * `data = 100;` (ì¼ë°˜ ë³€ìˆ˜)
      * `flag.store(true);` (atomic ë³€ìˆ˜)
      * `release`ëŠ” `flag.store`ê°€ `data = 100`ë³´ë‹¤ ë‚˜ì¤‘ì— ì‹¤í–‰ë˜ë„ë¡ ë³´ì¥í•˜ê³ , `data = 100`ì˜ ê°’ì„ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ê²Œ "ë³´ì´ë„ë¡(visible)" ë§Œë“ ë‹¤.

### 2. ğŸ¤ `memory_order_acquire` / `memory_order_release` (ë™ê¸°í™” ìŒ)

ì´ ë‘ ì˜µì…˜ì€ **í•­ìƒ ìŒìœ¼ë¡œ** ì‚¬ìš©ë˜ë©°, ìŠ¤ë ˆë“œ ê°„ì— ë°ì´í„°ë¥¼ ì•ˆì „í•˜ê²Œ ì „ë‹¬(ë™ê¸°í™”)í•˜ê¸° ìœ„í•´ ì¡´ì¬í•œë‹¤. ë®¤í…ìŠ¤ì˜ Lock/Unlockê³¼ ë§¤ìš° ìœ ì‚¬í•˜ë‹¤.

  * **`memory_order_release` (ì“°ê¸°/Store ì‘ì—…ì— ì‚¬ìš©)**

      * **"ë‚´ë³´ë‚´ê¸°"** ì¥ë²½ì´ë‹¤.
      * ì´ `release` ì“°ê¸° ëª…ë ¹ **ì´ì „**ì— ìˆëŠ” ëª¨ë“  ë©”ëª¨ë¦¬ ì‘ì—…(ì¼ë°˜ ë³€ìˆ˜ ì“°ê¸° í¬í•¨)ì€, `release` ì“°ê¸°ë³´ë‹¤ ë¨¼ì € ì™„ë£Œë˜ì–´ì•¼ í•¨ì„ ë³´ì¥í•œë‹¤. (ì½”ë“œ ì¬ë°°ì¹˜ ê¸ˆì§€)
      * ì´ ì‘ì—… ì´ì „ì— ì“´ ëª¨ë“  ë°ì´í„°ë¥¼ "íŒ¨í‚¤ì§€"ë¡œ ë¬¶ì–´ ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ë³¼ ìˆ˜ ìˆë„ë¡ "ë‚´ë³´ë‚¸ë‹¤."
      * (ë¹„ìœ : ë®¤í…ìŠ¤ì˜ **Unlock**)

  * **`memory_order_acquire` (ì½ê¸°/Load ì‘ì—…ì— ì‚¬ìš©)**

      * **"ê°€ì ¸ì˜¤ê¸°"** ì¥ë²½ì´ë‹¤.
      * ì´ `acquire` ì½ê¸° ëª…ë ¹ **ì´í›„**ì— ìˆëŠ” ëª¨ë“  ë©”ëª¨ë¦¬ ì‘ì—…(ì¼ë°˜ ë³€ìˆ˜ ì½ê¸° í¬í•¨)ì€, `acquire` ì½ê¸°ë³´ë‹¤ ë‚˜ì¤‘ì— ì‹œì‘ë˜ì–´ì•¼ í•¨ì„ ë³´ì¥í•œë‹¤. (ì½”ë“œ ì¬ë°°ì¹˜ ê¸ˆì§€)
      * `release`ê°€ ë³´ë‚¸ "íŒ¨í‚¤ì§€"ë¥¼ ì•ˆì „í•˜ê²Œ "ê°€ì ¸ì˜¨ë‹¤."
      * (ë¹„ìœ : ë®¤í…ìŠ¤ì˜ **Lock**)

### 3. ğŸ¤· `memory_order_relaxed` (ë‹¨ìˆœ ì›ìì„±)

ê°€ì¥ ì•½í•œ ë©”ëª¨ë¦¬ ìˆœì„œì´ë‹¤.

  * **ë³´ì¥í•˜ëŠ” ê²ƒ:** ì˜¤ì§ **ì›ìì„±** (Torn Read/Write ë°©ì§€) ë¿ì´ë‹¤.

  * **ë³´ì¥í•˜ì§€ ì•ŠëŠ” ê²ƒ:**

      * `relaxed` ì‘ì—… ì „í›„ì˜ ë‹¤ë¥¸ ë©”ëª¨ë¦¬ ì ‘ê·¼(ì˜ˆ: `data = 100;`)ê³¼ì˜ ìˆœì„œë¥¼ **ì „í˜€ ë³´ì¥í•˜ì§€ ì•ŠëŠ”ë‹¤.**
      * ì»´íŒŒì¼ëŸ¬ì™€ CPUê°€ `relaxed` ì‘ì—… ì „í›„ì˜ ì½”ë“œë¥¼ ë§ˆìŒëŒ€ë¡œ ì¬ë°°ì¹˜(reordering)í•  ìˆ˜ ìˆë‹¤.
      * ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ê²Œ ì´ ì‘ì—…ê³¼ ê´€ë ¨ëœ ë‹¤ë¥¸ ë°ì´í„°ì˜ **ê°€ì‹œì„±ì„ ë³´ì¥í•˜ì§€ ì•ŠëŠ”ë‹¤.**

  * **ì‚¬ìš©ì²˜:** ë‹¤ë¥¸ ë°ì´í„°ì™€ ì•„ë¬´ëŸ° ì—°ê´€ì´ ì—†ëŠ” ë‹¨ìˆœ ì¹´ìš´í„°(ì ‘ì†ì ìˆ˜ ì§‘ê³„ ë“±)ì²˜ëŸ¼, ìˆœì„œê°€ í‹€ë ¤ë„ ìƒê´€ì—†ëŠ” ê²½ìš°ì—ë§Œ ì‚¬ìš©í•œë‹¤.

### 4. ğŸš« `memory_order_consume` (ì‚¬ì‹¤ìƒ ì‚¬ìš©ë˜ì§€ ì•ŠìŒ)

`consume`ì€ `acquire`ì˜ ìµœì í™” ë²„ì „ìœ¼ë¡œ ì„¤ê³„ë˜ì—ˆë‹¤.

  * **`acquire`:** `load` ì´í›„ì˜ **ëª¨ë“ ** ë©”ëª¨ë¦¬ ì ‘ê·¼ ìˆœì„œë¥¼ ë§‰ëŠ”ë‹¤.

  * **`consume` (ì´ë¡ ):** `load` ì´í›„ì˜ ì‘ì—… ì¤‘, í•´ë‹¹ `load` ê°’ì— **ë°ì´í„° ì¢…ì†ì„±(data dependency)**ì´ ìˆëŠ” ì‘ì—…ì˜ ìˆœì„œë§Œ ë§‰ëŠ”ë‹¤.

      * `ptr = atomic_ptr.load(consume);`
      * `data = *ptr;` // `ptr`ì— ì¢…ì†ì ì´ë¯€ë¡œ ìˆœì„œ ë³´ì¥
      * `other_var = 10;` // `ptr`ê³¼ ë¬´ê´€í•˜ë¯€ë¡œ ìˆœì„œ ë³´ì¥ ì•ˆ ë¨ (ì¬ë°°ì¹˜ ê°€ëŠ¥)

  * **í˜„ì‹¤ (ë§¤ìš° ì¤‘ìš”):**

      * ì´ ì¢…ì†ì„±ì„ ì¶”ì í•˜ê³  êµ¬í˜„í•˜ëŠ” ê²ƒì´ ë„ˆë¬´ ë³µì¡í•´ì„œ, **ëª¨ë“  ì£¼ìš” ì»´íŒŒì¼ëŸ¬(MSVC, GCC, Clang)ëŠ” `consume`ì„ ê·¸ëƒ¥ `acquire`ë¡œ ìƒí–¥ ì¡°ì •(promote)í•˜ì—¬ ì²˜ë¦¬í•œë‹¤.**
      * C++ í‘œì¤€ ìœ„ì›íšŒì—ì„œë„ ì‚¬ìš©ì„ ê¶Œì¥í•˜ì§€ ì•Šìœ¼ë©° ì‚¬ì‹¤ìƒ ì‚¬ì¥ë˜ì—ˆë‹¤.
      * **ê²°ë¡ : ê·¸ëƒ¥ `acquire`ë¥¼ ì“°ë©´ ëœë‹¤.**

### 5. ğŸ’¡ ì½”ë“œ ì˜ˆì œ: Producer-Consumer

`acquire`/`release`ì™€ `relaxed`ì˜ ì°¨ì´ë¥¼ ë³´ì—¬ì£¼ëŠ” ê°€ì¥ ê³ ì „ì ì¸ ì˜ˆì œì´ë‹¤.

```cpp
#include <atomic>
#include <thread>
#include <iostream>

int data = 0;
std::atomic<bool> flag = false;

// --- ì‹œë‚˜ë¦¬ì˜¤ 1: acquire / release (ì˜¬ë°”ë¥¸ ì½”ë“œ) ---
void producer_release() {
    data = 100; // (A)
    flag.store(true, std::memory_order_release); // (B)
}

void consumer_acquire() {
    while (!flag.load(std::memory_order_acquire)); // (C)
    std::cout << "Acquire/Release: " << data << std::endl; // (D)
}
```

  * **ê²°ê³¼:** **í•­ìƒ 100ì´ ì¶œë ¥ëœë‹¤.**
  * **ì´ìœ :** `release` (B)ëŠ” (A)ê°€ ë¨¼ì € ì‹¤í–‰ë¨ì„ ë³´ì¥í•œë‹¤. `acquire` (C)ëŠ” (D)ê°€ ë‚˜ì¤‘ì— ì‹¤í–‰ë¨ì„ ë³´ì¥í•œë‹¤. (C)ê°€ (B)ì˜ `true`ë¥¼ ì½ëŠ” ìˆœê°„, (A)ì˜ `data = 100` ê°’ì´ (D)ì—ê²Œ **ë³´ì´ëŠ” ê²ƒì´ ë³´ì¥ëœë‹¤.**

<!-- end list -->

```cpp
// --- ì‹œë‚˜ë¦¬ì˜¤ 2: relaxed (ì˜ëª»ëœ ì½”ë“œ) ---
void producer_relaxed() {
    data = 200; // (X)
    flag.store(true, std::memory_order_relaxed); // (Y)
}

void consumer_relaxed() {
    while (!flag.load(std::memory_order_relaxed)); // (Z)
    std::cout << "Relaxed: " << data << std::endl; // (W)
}
```

  * **ê²°ê³¼:** **0 ë˜ëŠ” 200ì´ ì¶œë ¥ëœë‹¤.** (ì •ì˜ë˜ì§€ ì•Šì€ ë™ì‘ì€ ì•„ë‹ˆì§€ë§Œ, ê°’ì„ ì˜ˆì¸¡í•  ìˆ˜ ì—†ìŒ)
  * **ì´ìœ :**
    1.  `relaxed`ëŠ” ìˆœì„œë¥¼ ë³´ì¥í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ, ì»´íŒŒì¼ëŸ¬ë‚˜ CPUê°€ (W)ì˜ `data` ì½ê¸°ë¥¼ (Z)ì˜ `while` ë£¨í”„ **ì´ì „**ìœ¼ë¡œ ì¬ë°°ì¹˜í•  ìˆ˜ ìˆë‹¤. (ì¦‰, `data`ë¥¼ ë¨¼ì € ì½ê³  `while`ì„ ë”)
    2.  `producer_relaxed`ì—ì„œ (Y)ê°€ (X)ë³´ë‹¤ ë¨¼ì € ì‹¤í–‰ë  ìˆ˜ ìˆë‹¤. (ì¬ë°°ì¹˜)
    3.  `consumer_relaxed`ê°€ `flag`ê°€ `true`ì¸ ê²ƒì„ ë³´ì•˜ë”ë¼ë„, `producer_relaxed`ì˜ `data = 200` ì“°ê¸° ì‘ì—…ì´ `consumer_relaxed`ì˜ ìºì‹œì— ì•„ì§ ë³´ì´ì§€ ì•Šì„ ìˆ˜ ìˆë‹¤. (ê°€ì‹œì„± ë¬¸ì œ)

### 6\. ğŸ“Š í•œëˆˆì— ë¹„êµ

| ë©”ëª¨ë¦¬ ìˆœì„œ | ë³´ì¥í•˜ëŠ” ê²ƒ | ë³´ì¥í•˜ì§€ ì•ŠëŠ” ê²ƒ | ì£¼ìš” ìš©ë„ |
| :--- | :--- | :--- | :--- |
| **`relaxed`** | **ì›ìì„±** (Torn R/W ë°©ì§€) | ë©”ëª¨ë¦¬ ìˆœì„œ, ìŠ¤ë ˆë“œ ê°„ ê°€ì‹œì„± | ë‹¨ìˆœ ì¹´ìš´í„° (ì„±ëŠ¥ ìµœìš°ì„ ) |
| **`release`** (Store) | ì›ìì„± + ì´ ì‘ì—… **ì´ì „**ì˜ ëª¨ë“  ì“°ê¸° ìˆœì„œ ë³´ì¥ (ë‚´ë³´ë‚´ê¸°) | ì´ ì‘ì—… ì´í›„ì˜ ìˆœì„œ | ë°ì´í„° "ë‚´ë³´ë‚´ê¸°", ë®¤í…ìŠ¤ Unlock |
| **`acquire`** (Load) | ì›ìì„± + ì´ ì‘ì—… **ì´í›„**ì˜ ëª¨ë“  ì½ê¸°/ì“°ê¸° ìˆœì„œ ë³´ì¥ (ê°€ì ¸ì˜¤ê¸°) | ì´ ì‘ì—… ì´ì „ì˜ ìˆœì„œ | ë°ì´í„° "ê°€ì ¸ì˜¤ê¸°", ë®¤í…ìŠ¤ Lock |
| **`consume`** (Load) | (ì´ë¡ ) ë°ì´í„° ì¢…ì†ì„±ì´ ìˆëŠ” ì‘ì—… ìˆœì„œë§Œ ë³´ì¥<br>(**í˜„ì‹¤) `acquire`ì™€ ë™ì¼** | - | (ì‚¬ìš©í•˜ì§€ ì•ŠìŒ) |  
  

## acquire/release ì™€ acq_rel/seq_cst ì°¨ì´  

  * `acquire` (ì½ê¸°) / `release` (ì“°ê¸°)ëŠ” **í•œ ìŒ**ìœ¼ë¡œ, "ë°ì´í„°ë¥¼ ì£¼ê³ ë°›ëŠ”" ë™ê¸°í™”ì´ë‹¤.
  * `acq_rel` (ì½ê¸°-ìˆ˜ì •-ì“°ê¸°)ëŠ” **í•˜ë‚˜ì˜** ì‘ì—…ì´ "ê°€ì ¸ì˜¤ëŠ”(acquire) ë™ì‹œì— ë‚´ë³´ë‚´ëŠ”(release)" ë™ê¸°í™”ì´ë‹¤.
  * `seq_cst` (ëª¨ë“  ì‘ì—…)ëŠ” "ëª¨ë“  ìŠ¤ë ˆë“œê°€ ë™ì¼í•œ ìˆœì„œì— ë™ì˜"í•˜ëŠ” ê°€ì¥ ê°•ë ¥í•œ ë™ê¸°í™”ì´ë‹¤.

### 1. `acquire` / `release` (í•œ ìŒìœ¼ë¡œ ì‚¬ìš©)

ì´ê²ƒì€ ë‘ ê°œì˜ **ë³„ë„** ì‘ì—…ì´ë‹¤.

  * **`release` (ì“°ê¸°):** Producer ìŠ¤ë ˆë“œê°€ `store`í•  ë•Œ ì‚¬ìš©. (ì˜ˆ: `flag.store(true, release)`)
  * **`acquire` (ì½ê¸°):** Consumer ìŠ¤ë ˆë“œê°€ `load`í•  ë•Œ ì‚¬ìš©. (ì˜ˆ: `flag.load(acquire)`)

`release`ëŠ” "ë‚´ë³´ë‚´ê¸°" ì¥ë²½, `acquire`ëŠ” "ê°€ì ¸ì˜¤ê¸°" ì¥ë²½ì´ë‹¤. ì´ ë‘˜ì´ ë§Œë‚˜ì•¼ ë™ê¸°í™”ê°€ ì™„ì„±ëœë‹¤.  

### 2. `memory_order_acq_rel` (ë‹¨ì¼ ì‘ì—…)
ì´ê²ƒì€ `acquire`ì™€ `release`ë¥¼ **í•˜ë‚˜ì˜ ì›ìì  ì‘ì—…**ìœ¼ë¡œ í•©ì¹œ ê²ƒì´ë‹¤.

  * **ìš©ë„:** **ì½ê¸°-ìˆ˜ì •-ì“°ê¸° (RMW)** ì‘ì—…ì—ë§Œ ì‚¬ìš©ëœë‹¤.
      * ì˜ˆ: `fetch_add`, `fetch_sub`, `exchange`, `compare_exchange`
  * **ë™ì‘:**
    1.  ê°’ì„ **ì½ì„ ë•Œ** `acquire` ì¥ë²½ì²˜ëŸ¼ ì‘ë™í•œë‹¤.
    2.  ìƒˆ ê°’ì„ **ì“¸ ë•Œ** `release` ì¥ë²½ì²˜ëŸ¼ ì‘ë™í•œë‹¤.
  * **ì˜ˆì‹œ (ìŠ¤ë ˆë“œ ì„¸ì´í”„ í):** íì˜ `head` ì¸ë±ìŠ¤ë¥¼ ì¦ê°€ì‹œí‚¬ ë•Œ
      * `int old_head = head.fetch_add(1, std::memory_order_acq_rel);`
      * **`acquire` ë¶€ë¶„:** ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ íì— ë„£ì€ ë°ì´í„°(`release`ë¡œ ì“°ì¸)ë¥¼ ë‚´ê°€ ì•ˆì „í•˜ê²Œ ì½ì„ ìˆ˜ ìˆìŒì„ ë³´ì¥í•œë‹¤.
      * **`release` ë¶€ë¶„:** ë‚´ê°€ `head`ë¥¼ ì¦ê°€ì‹œí‚¨ ì´ ì‘ì—…ì´, ë‚˜ì¤‘ì— íì—ì„œ ë°ì´í„°ë¥¼ ë¹¼ê°ˆ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ê²Œ ë³´ì´ë„ë¡ ë³´ì¥í•œë‹¤.
  * **ìš”ì•½:** `acquire`ì™€ `release`ê°€ í•„ìš”í•œ RMW ì‘ì—…ì„ í•œ ë²ˆì— ì²˜ë¦¬í•˜ëŠ” ê²ƒì´ë‹¤.

### 3. `memory_order_seq_cst` (ê°€ì¥ ê°•ë ¥í•¨)

`seq_cst` (Sequential Consistency)ëŠ” ê°€ì¥ ê°•ë ¥í•˜ê³ , ê°€ì¥ ë¹„ì‹¸ë©°, ì´í•´í•˜ê¸° ê°€ì¥ ì‰¬ìš´ ëª¨ë¸ì´ë‹¤. C++ `std::atomic`ì˜ **ê¸°ë³¸ê°’**ì´ë‹¤.

`acquire`/`release`ê°€ ì œê³µí•˜ëŠ” ëª¨ë“  ê²ƒì„ í¬í•¨í•˜ë©°, **ì¶”ê°€ë¡œ í•œ ê°€ì§€**ë¥¼ ë” ë³´ì¥í•œë‹¤.

> **"ë‹¨ì¼ ì „ì²´ ìˆœì„œ (Single Total Order)"**
> ëª¨ë“  ìŠ¤ë ˆë“œê°€ ëª¨ë“  `seq_cst` ì‘ì—…ë“¤ì„ **ë™ì¼í•œ í•˜ë‚˜ì˜ ì‹¤í–‰ ìˆœì„œ**ë¡œ ë³´ëŠ” ê²ƒì— ë™ì˜í•œë‹¤.

ì´ê²ƒì´ `acquire`/`release`ì™€ì˜ ê²°ì •ì ì¸ ì°¨ì´ì´ë‹¤.

#### ğŸ’¡ `acquire`/`release`ì™€ `seq_cst`ì˜ ì°¨ì´ì  ì˜ˆì‹œ

ë‘ ê°œì˜ atomic ë³€ìˆ˜ `x`, `y`ê°€ ìˆë‹¤ê³  ê°€ì •í•´ ë³´ì. (ì´ˆê¸°ê°’ 0)

**ìŠ¤ë ˆë“œ 1:**

```cpp
x.store(1, std::memory_order_release);
```

**ìŠ¤ë ˆë“œ 2:**

```cpp
y.store(1, std::memory_order_release);
```

**ìŠ¤ë ˆë“œ 3:**

```cpp
while (x.load(std::memory_order_acquire) == 0);
int r1 = y.load(std::memory_order_acquire); // (A)
```

**ìŠ¤ë ˆë“œ 4:**

```cpp
while (y.load(std::memory_order_acquire) == 0);
int r2 = x.load(std::memory_order_acquire); // (B)
```

  * **`acquire`/`release` ê²°ê³¼:**
    `r1 == 0` ê·¸ë¦¬ê³  `r2 == 0`ì¸ ê²°ê³¼ê°€ **ê°€ëŠ¥í•˜ë‹¤.**
  * **ì´ìœ :** `acquire`/`release`ëŠ” `x`ì— ëŒ€í•œ ìˆœì„œì™€ `y`ì— ëŒ€í•œ ìˆœì„œë§Œ ê°ê° ë³´ì¥í•œë‹¤. ìŠ¤ë ˆë“œ 3ì´ `x`ë¥¼ ë³´ê³  `y`ë¥¼ ë³¼ ë•Œ, ìŠ¤ë ˆë“œ 4ëŠ” `y`ë¥¼ ë³´ê³  `x`ë¥¼ ë³¼ ìˆ˜ ìˆë‹¤. `x`ì™€ `y` ì‘ì—… ì‚¬ì´ì˜ ìˆœì„œëŠ” ë³´ì¥ë˜ì§€ ì•ŠëŠ”ë‹¤.


ì´ì œ ìœ„ ì½”ë“œë¥¼ `seq_cst`ë¡œ ë°”ê¿”ë³´ê² ë‹¤.

**ìŠ¤ë ˆë“œ 1:**

```cpp
x.store(1, std::memory_order_seq_cst);
```

**ìŠ¤ë ˆë“œ 2:**

```cpp
y.store(1, std::memory_order_seq_cst);
```

**ìŠ¤ë ˆë“œ 3:**

```cpp
while (x.load(std::memory_order_seq_cst) == 0);
int r1 = y.load(std::memory_order_seq_cst); // (A)
```

**ìŠ¤ë ˆë“œ 4:**

```cpp
while (y.load(std::memory_order_seq_cst) == 0);
int r2 = x.load(std::memory_order_seq_cst); // (B)
```

  * **`seq_cst` ê²°ê³¼:**
    `r1 == 0` ê·¸ë¦¬ê³  `r2 == 0`ì¸ ê²°ê³¼ê°€ **ì ˆëŒ€ ë¶ˆê°€ëŠ¥í•˜ë‹¤.**
  * **ì´ìœ :** `seq_cst`ëŠ” ëª¨ë“  ìŠ¤ë ˆë“œê°€ `x.store(1)`ì™€ `y.store(1)`ì˜ ìˆœì„œì— ë™ì˜í•˜ë„ë¡ ê°•ì œí•œë‹¤.
      * ë§Œì•½ `x.store(1)`ê°€ `y.store(1)`ë³´ë‹¤ "ì „ì²´ ìˆœì„œ"ì—ì„œ ë¨¼ì € ì¼ì–´ë‚¬ë‹¤ë©´, ìŠ¤ë ˆë“œ 4ëŠ” `y`ê°€ 1ì¸ ê²ƒì„ ë³¸ í›„ì— `x`ë¥¼ ë³´ë©´ `x`ë„ ë°˜ë“œì‹œ 1ì´ì–´ì•¼ í•œë‹¤ (ë”°ë¼ì„œ `r2 == 1`).
      * ë°˜ëŒ€ë„ ë§ˆì°¬ê°€ì§€ì´ë‹¤.

### ğŸ“Š ìš”ì•½ ë¹„êµ

| ë©”ëª¨ë¦¬ ìˆœì„œ | ì£¼ìš” ìš©ë„ | ì¥ë²½(ìˆœì„œ ë³´ì¥) | í•µì‹¬ íŠ¹ì§• |
| :--- | :--- | :--- | :--- |
| **`acquire`** | `load` (ì½ê¸°) | `acquire` ì¥ë²½. (ì´í›„ ì‘ì—…ì´ ì¬ë°°ì¹˜ë˜ì§€ ì•ŠìŒ) | `release`ì™€ ì§ì„ ì´ë¤„ ë°ì´í„°ë¥¼ "ê°€ì ¸ì˜´" |
| **`release`** | `store` (ì“°ê¸°) | `release` ì¥ë²½. (ì´ì „ ì‘ì—…ì´ ì¬ë°°ì¹˜ë˜ì§€ ì•ŠìŒ) | `acquire`ì™€ ì§ì„ ì´ë¤„ ë°ì´í„°ë¥¼ "ë‚´ë³´ëƒ„" |
| **`acq_rel`** | RMW (ì½ê¸°-ìˆ˜ì •-ì“°ê¸°) | `acquire` + `release` ì¥ë²½ | í•˜ë‚˜ì˜ ì›ìì  ì‘ì—…ì´ ê°€ì ¸ì˜¤ê¸°ì™€ ë‚´ë³´ë‚´ê¸°ë¥¼ ë™ì‹œì— ìˆ˜í–‰ |
| **`seq_cst`** | ëª¨ë“  ì‘ì—… (ê¸°ë³¸ê°’) | `acquire` + `release` ì¥ë²½ | **(ì¶”ê°€) ëª¨ë“  `seq_cst` ì‘ì—…ì— ëŒ€í•œ ë‹¨ì¼ ì „ì²´ ìˆœì„œ ë³´ì¥** |

`acquire`/`release`ëŠ” "**ì´ ë³€ìˆ˜**ë¥¼ ê¸°ì¤€ìœ¼ë¡œ" ìˆœì„œë¥¼ ë³´ì¥í•˜ëŠ” ë°˜ë©´, `seq_cst`ëŠ” "**ëª¨ë“  `seq_cst` ì‘ì—…**ì„ ê¸°ì¤€ìœ¼ë¡œ" ì „ì—­ì ì¸ ìˆœì„œë¥¼ ë³´ì¥í•œë‹¤.
  
  
</br>  
  

## ìŠ¤í•€ë½(Spinlock) êµ¬í˜„

```cpp
#include <atomic>
#include <thread>
#include <iostream>
#include <vector>

class Spinlock {
private:
    std::atomic<bool> locked{false};

public:
    void lock() {
        while (locked.exchange(true, std::memory_order_acquire)) {
            // ì´ë¯¸ ì ê²¨ìˆìœ¼ë©´ ê³„ì† ì‹œë„
            // CPU ì–‘ë³´ë¥¼ ìœ„í•œ íŒíŠ¸
            std::this_thread::yield();
        }
    }

    void unlock() {
        locked.store(false, std::memory_order_release);
    }
};

Spinlock spinlock;
int shared_counter = 0;

void increment_with_spinlock() {
    for (int i = 0; i < 10000; ++i) {
        spinlock.lock();
        ++shared_counter;  // ë³´í˜¸ëœ ì˜ì—­
        spinlock.unlock();
    }
}

int main() {
    std::vector<std::thread> threads;
    
    for (int i = 0; i < 10; ++i) {
        threads.emplace_back(increment_with_spinlock);
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    std::cout << "ê²°ê³¼: " << shared_counter << "\n";  // 100000
    
    return 0;
}
```
  
### ğŸ§ í˜„ì¬ ì½”ë“œê°€ ì˜¬ë°”ë¥´ê²Œ ë™ì‘í•˜ëŠ” ì´ìœ  (`acquire` / `release`)

í˜„ì¬ ì½”ë“œëŠ” `acquire` (íšë“)ì™€ `release` (í•´ì œ)ë¥¼ ìŒìœ¼ë¡œ ì‚¬ìš©í•˜ì—¬ ì™„ë²½í•œ ë™ê¸°í™”ë¥¼ ìˆ˜í–‰í•œë‹¤.

1.  **`unlock` (`release`): "ë‚´ë³´ë‚´ê¸°" ì¥ë²½**

      * `locked.store(false, std::memory_order_release);`
      * ì´ ì½”ë“œëŠ” "ì´ `store` ì‘ì—… **ì´ì „ì—** ìˆ˜í–‰ëœ ëª¨ë“  ë©”ëª¨ë¦¬ ì‘ì—…(íŠ¹íˆ `++shared_counter`)ì„ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ê²Œ **ë³´ì´ë„ë¡(visible) ë‚´ë³´ë‚´ë¼**"ê³  ëª…ë ¹í•œë‹¤.
      * ì»´íŒŒì¼ëŸ¬ì™€ CPUëŠ” `++shared_counter`ê°€ `locked = false`ë³´ë‹¤ **ë°˜ë“œì‹œ ë¨¼ì €** ì‹¤í–‰ë˜ë„ë¡ ë³´ì¥í•œë‹¤.

2.  **`lock` (`acquire`): "ê°€ì ¸ì˜¤ê¸°" ì¥ë²½**

      * `locked.exchange(true, std::memory_order_acquire);`
      * ì´ ì½”ë“œëŠ” ë½ íšë“ì— ì„±ê³µí–ˆì„ ë•Œ(ì¦‰, `exchange`ê°€ `false`ë¥¼ ë°˜í™˜í•˜ì—¬ `while` ë£¨í”„ íƒˆì¶œ ì‹œ), "ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ `release`ë¡œ **ë‚´ë³´ë‚¸** ëª¨ë“  ë©”ëª¨ë¦¬ ë³€ê²½ ì‚¬í•­(ì¦‰, `shared_counter`ì˜ ìµœì‹  ê°’)ì„ **ê°€ì ¸ì˜¤ë¼**"ê³  ëª…ë ¹í•œë‹¤.
      * ë˜í•œ, ì´ `lock` ì‘ì—… **ì´í›„ì—** ìˆ˜í–‰ë  ëª¨ë“  ë©”ëª¨ë¦¬ ì‘ì—…(íŠ¹íˆ `++shared_counter`)ì´ `lock`ë³´ë‹¤ **ë°˜ë“œì‹œ ë‚˜ì¤‘ì—** ì‹¤í–‰ë˜ë„ë¡ ë³´ì¥í•œë‹¤.

ì´ `acquire`/`release` ìŒì´ "ì„ê³„ ì˜ì—­(`++shared_counter`)ì˜ ìƒí˜¸ ë°°ì œ(mutual exclusion)ì™€ ë°ì´í„° ê°€ì‹œì„±"ì„ ë³´ì¥í•œë‹¤.


### ğŸ’£ `relaxed`ë¡œ ë³€ê²½ ì‹œ ë°œìƒí•˜ëŠ” ë¬¸ì œì 
`memory_order_relaxed`ëŠ” ì›ìì„±(atomicity)ë§Œ ë³´ì¥í•  ë¿, ìˆœì„œë‚˜ ê°€ì‹œì„±ì„ **ì „í˜€ ë³´ì¥í•˜ì§€ ì•ŠëŠ”ë‹¤.**

#### 1. `unlock`ì„ `relaxed`ë¡œ ë³€ê²½ ì‹œ (ê°€ì¥ ì¹˜ëª…ì )

```cpp
void unlock() {
    // !! ì¬ì•™ì ì¸ ë¬¸ì œ !!
    locked.store(false, std::memory_order_relaxed);
}
```

  * **ë¬¸ì œì : ì½”ë“œ ì¬ë°°ì¹˜ (Reordering)**
  * ì»´íŒŒì¼ëŸ¬ì™€ CPUëŠ” `++shared_counter;`ì™€ `locked.store(false)`ê°€ ì„œë¡œ ê´€ë ¨ ì—†ëŠ” ì‘ì—…ì´ë¼ê³  íŒë‹¨í•˜ê³  **ìˆœì„œë¥¼ ë’¤ë°”ê¿€ ìˆ˜ ìˆë‹¤.**
  * **ì¬ë°°ì¹˜ëœ ì½”ë“œ (ê°œë…):**
    ```cpp
    // unlock() ë‚´ë¶€
    locked.store(false, std::memory_order_relaxed); // (1) ë½ì„ ë¨¼ì € í’€ì–´ë²„ë¦¼
    ++shared_counter;                               // (2) ë½ì„ í‘¼ í›„ì— ì¹´ìš´í„° ì¦ê°€
    ```
  * **ì‹œë‚˜ë¦¬ì˜¤:**
    1.  ìŠ¤ë ˆë“œ Aê°€ `lock()`ì— ì§„ì….
    2.  ìŠ¤ë ˆë“œ Aê°€ `unlock()`ì„ í˜¸ì¶œ.
    3.  (ì¬ë°°ì¹˜ ë°œìƒ) ìŠ¤ë ˆë“œ Aê°€ `locked = false`ë¥¼ ë¨¼ì € ì‹¤í–‰í•©ë‹ˆë‹¤. (ë½ í’€ë¦¼)
    4.  ìŠ¤ë ˆë“œ Bê°€ `lock()`ì„ ì‹œë„í•˜ë‹¤ê°€ `locked`ê°€ `false`ì¸ ê²ƒì„ ë³´ê³  ë½ì„ íšë“í•œë‹¤.
    5.  ìŠ¤ë ˆë“œ Bê°€ `++shared_counter`ë¥¼ ì‹¤í–‰í•œë‹¤.
    6.  **ë™ì‹œì—** ìŠ¤ë ˆë“œ Aë„ (ì¬ë°°ì¹˜ëœ) `++shared_counter`ë¥¼ ì‹¤í–‰í•œë‹¤.
  * **ê²°ê³¼:** **ë‘ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— `shared_counter`ì— ì ‘ê·¼í•©ë‹ˆë‹¤.** `shared_counter` ê°’ì€ ì™„ì „íˆ ê¹¨ì§„ë‹¤.

#### 2. `lock`ì„ `relaxed`ë¡œ ë³€ê²½ ì‹œ

```cpp
void lock() {
    // !! ì‹¬ê°í•œ ë¬¸ì œ !!
    while (locked.exchange(true, std::memory_order_relaxed)) {
        std::this_thread::yield();
    }
}
```

  * **ë¬¸ì œì  1: ë©”ëª¨ë¦¬ ê°€ì‹œì„±(Visibility) ì‹¤íŒ¨**

      * `acquire` ì¥ë²½ì´ ì—†ìœ¼ë¯€ë¡œ, ìŠ¤ë ˆë“œ Bê°€ `lock`ì„ íšë“í–ˆë”ë¼ë„ ìŠ¤ë ˆë“œ Aê°€ `unlock` ì´ì „ì— ì¼ë˜ `shared_counter`ì˜ ìµœì‹  ê°’ì„ ë³¸ë‹¤ëŠ” ë³´ì¥ì´ ì—†ë‹¤.
      * ìŠ¤ë ˆë“œ BëŠ” ìì‹ ì˜ CPU ìºì‹œì— ìˆëŠ” ë‚¡ì€(stale) `shared_counter` ê°’ì„ ì½ê³  1ì„ ë”í•  ìˆ˜ ìˆë‹¤.
      * **ê²°ê³¼:** `shared_counter`ì˜ ì¦ê°€ë¶„ì´ ìœ ì‹¤ëœë‹¤. (ì˜ˆ: 100ì´ì–´ì•¼ í•  ê°’ì´ 50ì—ì„œ 51ë¡œ ì¦ê°€)

  * **ë¬¸ì œì  2: ì½”ë“œ ì¬ë°°ì¹˜ (Reordering)**

      * `acquire` ì¥ë²½ì´ ì—†ìœ¼ë¯€ë¡œ, ì»´íŒŒì¼ëŸ¬ê°€ `lock()` *ì´í›„*ì— ìˆì–´ì•¼ í•  `++shared_counter` ì½”ë“œë¥¼ `lock()` *ì´ì „*ìœ¼ë¡œ (ì˜ˆì¸¡ ì‹¤í–‰ ë“±ìœ¼ë¡œ) ì¬ë°°ì¹˜í•  ìˆ˜ë„ ìˆë‹¤.
      * **ê²°ê³¼:** ë½ì„ íšë“í•˜ê¸°ë„ ì „ì— ì„ê³„ ì˜ì—­ ì½”ë“œê°€ ì‹¤í–‰ë  ìˆ˜ ìˆë‹¤.

### âœ… ê²°ë¡ 
ìŠ¤í•€ë½ì´ë‚˜ ë®¤í…ìŠ¤ë¥¼ ì˜¬ë°”ë¥´ê²Œ êµ¬í˜„í•˜ë ¤ë©´ **ë°˜ë“œì‹œ** `unlock`ì— `release` ì¥ë²½ì´, `lock`ì— `acquire` ì¥ë²½ì´ í•„ìš”í•˜ë‹¤.

  * **`release` (unlock):** ë‚´ê°€ ì‘ì—…í•œ ë‚´ìš©ì„ (ì„ê³„ ì˜ì—­) **ìˆœì„œëŒ€ë¡œ í™•ì‹¤íˆ ë‚´ë³´ë‚¸ë‹¤.**
  * **`acquire` (lock):** ë‚¨ì´ ì‘ì—…í•œ ë‚´ìš©ì„ (ì„ê³„ ì˜ì—­) **ìˆœì„œëŒ€ë¡œ í™•ì‹¤íˆ ê°€ì ¸ì˜¨ë‹¤.**

`relaxed`ëŠ” ì´ ë³´ì¦ì„ ëª¨ë‘ ì œê±°í•˜ë¯€ë¡œ, ì„ê³„ ì˜ì—­ì´ ì „í˜€ ë³´í˜¸ë˜ì§€ ì•ŠëŠ”ë‹¤.
  
  

## ì§„í–‰ ìƒí™© ì¶”ì ê¸°

```cpp
#include <atomic>
#include <thread>
#include <vector>
#include <iostream>
#include <chrono>
#include <iomanip>

class ProgressTracker {
private:
    std::atomic<size_t> completed{0};
    std::atomic<bool> done{false};
    size_t total;

public:
    ProgressTracker(size_t total_tasks) : total(total_tasks) {}

    void increment() {
        completed.fetch_add(1, std::memory_order_relaxed);
    }

    void finish() {
        done.store(true, std::memory_order_release);
    }

    void display() {
        while (!done.load(std::memory_order_acquire)) {
            size_t current = completed.load(std::memory_order_relaxed);
            int percentage = (current * 100) / total;
            
            std::cout << "\rì§„í–‰ë¥ : [";
            int bar_width = 50;
            int filled = (bar_width * current) / total;
            
            for (int i = 0; i < bar_width; ++i) {
                if (i < filled) std::cout << "=";
                else if (i == filled) std::cout << ">";
                else std::cout << " ";
            }
            
            std::cout << "] " << percentage << "% (" 
                      << current << "/" << total << ")" << std::flush;
            
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
        
        std::cout << "\rì§„í–‰ë¥ : [";
        for (int i = 0; i < 50; ++i) std::cout << "=";
        std::cout << "] 100% (" << total << "/" << total << ")\n";
    }
};

void worker(ProgressTracker& tracker, int task_count) {
    for (int i = 0; i < task_count; ++i) {
        // ì‘ì—… ì‹œë®¬ë ˆì´ì…˜
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
        tracker.increment();
    }
}

int main() {
    const size_t total_tasks = 1000;
    const int num_workers = 10;
    const int tasks_per_worker = total_tasks / num_workers;
    
    ProgressTracker tracker(total_tasks);
    
    // ì§„í–‰ ìƒí™© í‘œì‹œ ìŠ¤ë ˆë“œ
    std::thread display_thread([&]() {
        tracker.display();
    });
    
    // ì‘ì—…ì ìŠ¤ë ˆë“œë“¤
    std::vector<std::thread> workers;
    for (int i = 0; i < num_workers; ++i) {
        workers.emplace_back(worker, std::ref(tracker), tasks_per_worker);
    }
    
    // ì‘ì—… ì™„ë£Œ ëŒ€ê¸°
    for (auto& w : workers) {
        w.join();
    }
    
    tracker.finish();
    display_thread.join();
    
    return 0;
}
```
   
### 1. `completed` ë³€ìˆ˜: `memory_order_relaxed`

`worker` ìŠ¤ë ˆë“œì˜ `increment()`ì™€ `display` ìŠ¤ë ˆë“œì˜ `completed.load()`ëŠ” ëª¨ë‘ `memory_order_relaxed`ë¥¼ ì‚¬ìš©í•œë‹¤.

* **`increment()` (worker):** `completed.fetch_add(1, std::memory_order_relaxed)`
    * **ì´ìœ :** `completed` ë³€ìˆ˜ëŠ” **ë‹¨ìˆœ ì¹´ìš´í„°**ì´ë‹¤. ì‘ì—…ì ìŠ¤ë ˆë“œë“¤ì€ ì´ ë³€ìˆ˜ë¥¼ ì¦ê°€ì‹œí‚¬ ë¿, ì´ ë³€ìˆ˜ì™€ *ë‹¤ë¥¸* ë°ì´í„°ë¥¼ ë™ê¸°í™”í•˜ì§€ ì•ŠëŠ”ë‹¤. (ì˜ˆ: `data = 100`ì„ ì“´ ë’¤ `completed`ë¥¼ ì¦ê°€ì‹œí‚¤ëŠ” ì‹ì˜ ì‘ì—…ì´ ì—†ë‹¤.)
    * `relaxed`ëŠ” **ì›ìì„±(Atomicity)**ë§Œ ë³´ì¥í•œë‹¤. ì¦‰, ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— `fetch_add`ë¥¼ í˜¸ì¶œí•´ë„ ì¹´ìš´íŠ¸ê°€ ìœ ì‹¤ë˜ê±°ë‚˜ ê¹¨ì§€ì§€ ì•Šê²Œ í•´ì¤€ë‹¤. ì´ ì‚¬ìš©ì²˜ì—ì„œëŠ” ìˆœì„œ ë³´ì¥(ordering)ì´ í•„ìš” ì—†ìœ¼ë¯€ë¡œ, ê°€ì¥ ë¹ ë¥´ê³  ì•½í•œ `relaxed`ê°€ ì •ë‹µì´ë‹¤.

* **`completed.load()` (display):** `size_t current = completed.load(std::memory_order_relaxed)`
    * **ì´ìœ :** `display` ìŠ¤ë ˆë“œëŠ” ì§„í–‰ë¥ ì„ **"í‘œì‹œ"**í•˜ëŠ” ê²ƒì´ ëª©ì ì´ë‹¤. 100msë§ˆë‹¤ í•œ ë²ˆì”© ê°’ì„ ì½ì–´ì˜¤ëŠ”ë°, ì´ ê°’ì´ CPU ìºì‹œ ë•Œë¬¸ì— ì•„ì£¼ ì•½ê°„(ìˆ˜ ë‚˜ë…¸ì´ˆ) ëŠ¦ì€ "ê³¼ê±°ì˜ ê°’"ì´ë¼ë„ ì „í˜€ ë¬¸ì œì—†ë‹¤.
    * ì§„í–‰ë¥  í‘œì‹œëŠ” 100% ì •í™•í•œ ì‹¤ì‹œê°„ ë™ê¸°í™”ê°€ í•„ìš” ì—†ë‹¤. 50%ì¼ ë•Œ 49.9%ë¡œ ë³´ì´ë”ë¼ë„ ë‹¤ìŒ 100ms í›„ì— 50.1%ë¡œ ë³´ì´ë©´ ê·¸ë§Œì´ë‹¤. ë”°ë¼ì„œ ì›ìì  ì½ê¸°(Torn read ë°©ì§€)ë§Œ ë³´ì¥í•˜ëŠ” `relaxed`ë¡œ ì¶©ë¶„í•˜ë‹¤.

### 2. `done` ë³€ìˆ˜: `release` / `acquire`

`done` ë³€ìˆ˜ëŠ” ì‘ì—…ì ìŠ¤ë ˆë“œì™€ í‘œì‹œ ìŠ¤ë ˆë“œ ê°„ì˜ **ì¢…ë£Œ ì‹ í˜¸**ë¼ëŠ” ëª…í™•í•œ ë™ê¸°í™” ëª©ì ì„ ê°€ì§„ë‹¤.

* **`finish()` (main):** `done.store(true, std::memory_order_release)`
    * **ì´ìœ :** `main` ìŠ¤ë ˆë“œëŠ” ëª¨ë“  ì‘ì—…ì ìŠ¤ë ˆë“œê°€ `join()`í•˜ëŠ” ê²ƒì„ ê¸°ë‹¤ë¦°ë‹¤. `join()`ì€ ê·¸ ìì²´ë¡œ ê°•ë ¥í•œ ë™ê¸°í™” ì¥ë²½ì´ë‹¤. `join()`ì´ ì™„ë£Œë˜ë©´ `main` ìŠ¤ë ˆë“œëŠ” ëª¨ë“  ì‘ì—…ì´ 100% ì™„ë£Œë˜ì—ˆìŒì„ **í™•ì‹ **í•  ìˆ˜ ìˆë‹¤.
    * ì´ "ì‘ì—… ì™„ë£Œ"ë¼ëŠ” ì‚¬ì‹¤ì„ `display` ìŠ¤ë ˆë“œì—ê²Œ "ë‚´ë³´ë‚´ê¸°(publish)" ìœ„í•´ **`release`**ë¥¼ ì‚¬ìš©í•œë‹¤.

* **`display()` (display):** `while (!done.load(std::memory_order_acquire))`
    * **ì´ìœ :** `display` ìŠ¤ë ˆë“œëŠ” `done` í”Œë˜ê·¸ë¥¼ ì£¼ê¸°ì ìœ¼ë¡œ í™•ì¸í•œë‹¤. `main` ìŠ¤ë ˆë“œê°€ `release`ë¡œ "ë‚´ë³´ë‚¸" `true` ê°’ì„ "ê°€ì ¸ì˜¤ê¸°(subscribe)" ìœ„í•´ **`acquire`**ë¥¼ ì‚¬ìš©í•œë‹¤.
    * `acquire`ì™€ `release`ê°€ ì§ì„ ì´ë¤„ **ë™ê¸°í™”(synchronizes-with)**ê°€ ì™„ì„±ëœë‹¤.
    * `done.load(std::memory_order_acquire)`ê°€ `true`ë¥¼ ë°˜í™˜í•˜ëŠ” ìˆœê°„, `display` ìŠ¤ë ˆë“œëŠ” `main` ìŠ¤ë ˆë“œê°€ `finish()`ë¥¼ í˜¸ì¶œí•˜ê¸° ì´ì „ì— ë°œìƒí•œ ëª¨ë“  ì¼(ì¦‰, ëª¨ë“  ì‘ì—…ìì˜ `join()`)ì´ ì™„ë£Œë˜ì—ˆìŒì„ **ë³´ì¥**ë°›ê²Œ ëœë‹¤.

### ğŸ“„ ìš”ì•½
ì´ ì½”ë“œëŠ” ë‘ `atomic` ë³€ìˆ˜ì˜ ì—­í• ì„ ì™„ë²½í•˜ê²Œ ë¶„ë¦¬í–ˆë‹¤.

1.  **`completed` (ì¹´ìš´í„°):** ë™ê¸°í™” ëª©ì ì´ ì—†ìœ¼ë©° ì›ìì„±ë§Œ í•„ìš”í•˜ë¯€ë¡œ **`relaxed`**ë¥¼ ì‚¬ìš©í•œë‹¤.
2.  **`done` (ì‹ í˜¸):** ìŠ¤ë ˆë“œ ê°„ì˜ ì¢…ë£Œ ì‹ í˜¸ë¥¼ ì£¼ê³ ë°›ëŠ” ëª…í™•í•œ ë™ê¸°í™” ëª©ì ì´ ìˆìœ¼ë¯€ë¡œ **`release`/`acquire`**ë¥¼ ì‚¬ìš©í•œë‹¤.

  

## ë”ë¸” ì²´í¬ ë½í‚¹(Double-Checked Locking)
ì‹±ê¸€í†¤ íŒ¨í„´ ë“±ì—ì„œ ì‚¬ìš©ë˜ëŠ” ìµœì í™” ê¸°ë²•ì´ë‹¤:

```cpp
#include <atomic>
#include <mutex>
#include <memory>
#include <iostream>
#include <thread>
#include <vector>

class Singleton {
private:
    static std::atomic<Singleton*> instance;
    static std::mutex mutex;
    
    int data;
    
    Singleton() : data(42) {
        std::cout << "Singleton ìƒì„±ë¨\n";
    }

public:
    static Singleton* getInstance() {
        Singleton* tmp = instance.load(std::memory_order_acquire);
        
        if (tmp == nullptr) {  // ì²« ë²ˆì§¸ ì²´í¬ (ë½ ì—†ì´)
            std::lock_guard<std::mutex> lock(mutex);
            tmp = instance.load(std::memory_order_relaxed);
            
            if (tmp == nullptr) {  // ë‘ ë²ˆì§¸ ì²´í¬ (ë½ ì•ˆì—ì„œ)
                tmp = new Singleton();
                instance.store(tmp, std::memory_order_release);
            }
        }
        
        return tmp;
    }
    
    int getData() const { return data; }
};

std::atomic<Singleton*> Singleton::instance{nullptr};
std::mutex Singleton::mutex;

int main() {
    std::vector<std::thread> threads;
    
    // ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ì ‘ê·¼
    for (int i = 0; i < 10; ++i) {
        threads.emplace_back([]() {
            Singleton* s = Singleton::getInstance();
            std::cout << "ìŠ¤ë ˆë“œ " << std::this_thread::get_id() 
                      << ": " << s->getData() << "\n";
        });
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    // "Singleton ìƒì„±ë¨"ì€ ì •í™•íˆ í•œ ë²ˆë§Œ ì¶œë ¥ë¨
    
    return 0;
}
```
   

### 1. í•µì‹¬ ë™ê¸°í™”: `release`ì™€ `acquire`ì˜ ì§

ì´ íŒ¨í„´ì˜ í•µì‹¬ì€ **"Fast Path"(ë½ ì—†ëŠ” ê²½ë¡œ)** ì™€ **"Slow Path"(ë½ ìˆëŠ” ê²½ë¡œ)** ê°„ì˜ ë™ê¸°í™”ì´ë‹¤.

#### 1. `instance.store(tmp, std::memory_order_release);` (Slow Path - ì“°ê¸°)

  * **ì—­í• :** ìƒì„±ëœ `Singleton` ê°ì²´(`tmp`)ë¥¼ `instance` í¬ì¸í„°ì— "ê²Œì‹œ(publish)"í•œë‹¤.
  * **`release` (ë‚´ë³´ë‚´ê¸°):** ì´ `store` ì‘ì—…ì€ "ë‚´ë³´ë‚´ê¸°" ì¥ë²½ì´ë‹¤.
  * **ë³´ì¥:** ì´ `store` ì‘ì—… **ì´ì „ì—** ì¼ì–´ë‚œ ëª¨ë“  ë©”ëª¨ë¦¬ ì“°ê¸°(ì¦‰, `tmp = new Singleton();`ì—ì„œ ë°œìƒí•œ ë©”ëª¨ë¦¬ í• ë‹¹ ë° **ìƒì„±ì í˜¸ì¶œ** `data(42)`)ê°€ ì´ `store` ì‘ì—…ë³´ë‹¤ ë¨¼ì € ì™„ë£Œë˜ë©°, ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ê²Œ "ë³´ì´ë„ë¡" ë§Œë“ ë‹¤.
  * **ì¤‘ìš”ì„±:** ë§Œì•½ `relaxed`ë¥¼ ì¼ë‹¤ë©´, ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ `instance` ëŠ” ë´¤ì§€ë§Œ, ì•„ì§ ìƒì„±ìê°€ ì™„ë£Œë˜ì§€ ì•Šì€ `tmp` (ì¦‰, `tmp->data`ê°€ 42ê°€ ì•„ë‹Œ ì“°ë ˆê¸° ê°’ì¸ ìƒíƒœ)ì— ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤. `release`ëŠ” ì´ë¥¼ ë°©ì§€í•œë‹¤.

#### 2. `instance.load(std::memory_order_acquire);` (Fast Path - ì½ê¸°)

  * **ì—­í• :** `getInstance()`ê°€ í˜¸ì¶œë  ë•Œë§ˆë‹¤ ê°€ì¥ ë¨¼ì € ì‹¤í–‰ë˜ëŠ” "ë¹ ë¥¸ ê²½ë¡œ" ì²´í¬ì´ë‹¤.
  * **`acquire` (ê°€ì ¸ì˜¤ê¸°):** ì´ `load` ì‘ì—…ì€ "ê°€ì ¸ì˜¤ê¸°" ì¥ë²½ì´ë‹¤.
  * **ë³´ì¥:** ìœ„ 1ë²ˆì˜ `release` ì“°ê¸°ì™€ ì§ì„ ì´ë£¬ë‹¤. ë§Œì•½ ì´ `load`ê°€ `nullptr`ê°€ ì•„ë‹Œ ê°’(ì¦‰, 1ë²ˆì—ì„œ ê²Œì‹œí•œ `tmp`)ì„ ì½ì—ˆë‹¤ë©´, 1ë²ˆì˜ `release` ì¥ë²½ **ì´ì „ì—** ì¼ì–´ë‚¬ë˜ ëª¨ë“  ë©”ëª¨ë¦¬ ì“°ê¸°(ì¦‰, **ìƒì„±ì í˜¸ì¶œ** `data(42)`)ê°€ **í˜„ì¬ ìŠ¤ë ˆë“œì—ê²Œë„ "ë³´ì´ë„ë¡"** ê°•ì œí•œë‹¤.
  * **ê²°ê³¼:** `tmp`ê°€ `nullptr`ê°€ ì•„ë‹ˆë¼ë©´, `tmp->data`ëŠ” **ë°˜ë“œì‹œ 42**ì„ì´ ë³´ì¥ëœë‹¤.

### 2. ë½ ë‚´ë¶€ì˜ `relaxed`: ì™œ ê´œì°®ì€ê°€?

#### `tmp = instance.load(std::memory_order_relaxed);` (Slow Path - ë‘ ë²ˆì§¸ ì²´í¬)

"ì–´? `acquire`ë„ ì•„ë‹ˆê³  `relaxed`ë¥¼ ì¼ëŠ”ë° ê´œì°®ë‚˜ìš”?"

ì´ ë¶€ë¶„ë„ **ì™„ë²½í•˜ê²Œ ì˜¬ë°”ë¥´ë©° ìµœì í™”ëœ** ì‚¬ìš©ë²•ì´ë‹¤.

  * **ì´ìœ :** ì´ `load`ëŠ” `std::lock_guard<std::mutex> lock(mutex);` **ì´í›„ì—** ì‹¤í–‰ëœë‹¤.
  * **`std::mutex::lock()`ì˜ ì—­í• :** C++ í‘œì¤€ì— ë”°ë¼, `mutex`ì˜ `lock()` ì‘ì—…ì€ ê·¸ ìì²´ë¡œ **`acquire` íœìŠ¤** ì—­í• ì„ ìˆ˜í–‰í•œë‹¤. (ë§ˆì°¬ê°€ì§€ë¡œ `unlock()`ì€ `release` íœìŠ¤ì´ë‹¤.)
  * **ê²°ë¡ :** ì´ë¯¸ `lock()`ì„ í†µí•´ `acquire` ë™ê¸°í™”ê°€ ì´ë£¨ì–´ì¡Œê¸° ë•Œë¬¸ì—, ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ `release`ë¡œ ì¼ë˜ `instance` ê°’ì€ í˜„ì¬ ìŠ¤ë ˆë“œì—ê²Œ ì´ë¯¸ ë³´ì¸ë‹¤. ë”°ë¼ì„œ ì´ `load`ëŠ” êµ³ì´ `acquire`ë¥¼ ì¤‘ë³µìœ¼ë¡œ ìˆ˜í–‰í•  í•„ìš” ì—†ì´, ë‹¨ìˆœíˆ ì›ìì ìœ¼ë¡œ(atomically) í¬ì¸í„° ê°’ë§Œ ë‹¤ì‹œ í™•ì¸í•˜ë©´ ë˜ë¯€ë¡œ `relaxed`ë¡œ ì¶©ë¶„í•˜ë‹¤.

### âœ… ìš”ì•½ ë° í‰ê°€
1.  **Fast Path (`acquire` load):** `release`ë¡œ ê²Œì‹œëœ `Singleton` ê°ì²´ì˜ ì™„ì „í•œ ì´ˆê¸°í™”(ìƒì„±ì)ë¥¼ ì•ˆì „í•˜ê²Œ í™•ì¸í•œë‹¤.
2.  **Slow Path (`release` store):** `Singleton` ê°ì²´ê°€ ì™„ì „íˆ ìƒì„±ëœ í›„ì—ë§Œ `instance` í¬ì¸í„°ë¥¼ `release`ë¡œ ê²Œì‹œí•œë‹¤.
3.  **Slow Path (`relaxed` load):** `mutex.lock()`ì´ ì´ë¯¸ `acquire` ì—­í• ì„ ìˆ˜í–‰í–ˆìœ¼ë¯€ë¡œ, ì¤‘ë³µ `acquire` ì—†ì´ `relaxed`ë¡œ íš¨ìœ¨ì ì¸ ì¬í™•ì¸ì´ ê°€ëŠ¥í•˜ë‹¤.

  
</br>  
  

## atomic vs mutex ì„ íƒ ê°€ì´ë“œ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              ì–¸ì œ atomicì„ ì‚¬ìš©í•˜ë‚˜?                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ“ ë‹¨ì¼ ë³€ìˆ˜ì— ëŒ€í•œ ê°„ë‹¨í•œ ì—°ì‚°                           â”‚
â”‚ âœ“ ì¹´ìš´í„°, í”Œë˜ê·¸, ìƒíƒœ ë³€ìˆ˜                              â”‚
â”‚ âœ“ Lock-free ìë£Œêµ¬ì¡° êµ¬í˜„                               â”‚
â”‚ âœ“ ìµœëŒ€ ì„±ëŠ¥ì´ í•„ìš”í•œ ê²½ìš°                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              ì–¸ì œ mutexë¥¼ ì‚¬ìš©í•˜ë‚˜?                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ“ ì—¬ëŸ¬ ë³€ìˆ˜ë¥¼ ë™ì‹œì— ë³´í˜¸í•´ì•¼ í•  ë•Œ                      â”‚
â”‚ âœ“ ë³µì¡í•œ ì—°ì‚° ì‹œí€€ìŠ¤                                     â”‚
â”‚ âœ“ ì¡°ê±´ ë³€ìˆ˜ì™€ í•¨ê»˜ ì‚¬ìš©                                  â”‚
â”‚ âœ“ ì½”ë“œ ê°€ë…ì„±ì´ ë” ì¤‘ìš”í•œ ê²½ìš°                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ë¹„êµ ì˜ˆì œ

```cpp
#include <atomic>
#include <mutex>
#include <iostream>
#include <thread>
#include <vector>
#include <chrono>

// atomic ì‚¬ìš©
std::atomic<long long> atomic_counter{0};

void increment_atomic(int iterations) {
    for (int i = 0; i < iterations; ++i) {
        ++atomic_counter;
    }
}

// mutex ì‚¬ìš©
std::mutex mtx;
long long mutex_counter = 0;

void increment_mutex(int iterations) {
    for (int i = 0; i < iterations; ++i) {
        std::lock_guard<std::mutex> lock(mtx);
        ++mutex_counter;
    }
}

template<typename Func>
void benchmark(const std::string& name, Func func, int num_threads, int iterations) {
    auto start = std::chrono::high_resolution_clock::now();
    
    std::vector<std::thread> threads;
    for (int i = 0; i < num_threads; ++i) {
        threads.emplace_back(func, iterations);
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    std::cout << name << ": " << duration.count() << "ms\n";
}

int main() {
    const int num_threads = 4;
    const int iterations = 1000000;
    
    benchmark("atomic", increment_atomic, num_threads, iterations);
    std::cout << "atomic ê²°ê³¼: " << atomic_counter << "\n\n";
    
    benchmark("mutex ", increment_mutex, num_threads, iterations);
    std::cout << "mutex ê²°ê³¼: " << mutex_counter << "\n";
    
    // atomicì´ ì¼ë°˜ì ìœ¼ë¡œ í›¨ì”¬ ë¹ ë¦„
    
    return 0;
}
```
  
</br>  
  

## ì£¼ì˜ì‚¬í•­ê³¼ ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤

### ì£¼ì˜ì‚¬í•­

```cpp
// âŒ ë‚˜ìœ ì˜ˆ: atomicì€ ë³µì‚¬ ë¶ˆê°€
std::atomic<int> a{10};
// std::atomic<int> b = a;  // ì»´íŒŒì¼ ì—ëŸ¬!

// âœ“ ì¢‹ì€ ì˜ˆ: load() ì‚¬ìš©
std::atomic<int> c{a.load()};

// âŒ ë‚˜ìœ ì˜ˆ: í¬ê¸°ê°€ í° íƒ€ì…
struct BigStruct {
    char data[1024];
};
// std::atomic<BigStruct> big;  // ë¹„íš¨ìœ¨ì ì´ê±°ë‚˜ ë¶ˆê°€ëŠ¥!

// âœ“ ì¢‹ì€ ì˜ˆ: í¬ì¸í„° ì‚¬ìš©
std::atomic<BigStruct*> big_ptr{nullptr};
```

### is_lock_free í™•ì¸

```cpp
#include <atomic>
#include <iostream>

int main() {
    std::atomic<int> a;
    std::atomic<double> b;
    
    std::cout << "intëŠ” lock-freeì¸ê°€? " 
              << (a.is_lock_free() ? "ì˜ˆ" : "ì•„ë‹ˆì˜¤") << "\n";
    std::cout << "doubleì€ lock-freeì¸ê°€? " 
              << (b.is_lock_free() ? "ì˜ˆ" : "ì•„ë‹ˆì˜¤") << "\n";
    
    // ì»´íŒŒì¼ íƒ€ì„ì— í™•ì¸í•˜ë ¤ë©´:
    static_assert(std::atomic<int>::is_always_lock_free, 
                  "int atomicì€ í•­ìƒ lock-freeì—¬ì•¼ í•¨");
    
    return 0;
}
```

### ABA ë¬¸ì œ
Lock-free ìë£Œêµ¬ì¡°ì—ì„œ ë°œìƒí•  ìˆ˜ ìˆëŠ” ë¬¸ì œì´ë‹¤:

```cpp
/*
ABA ë¬¸ì œ:
1. Thread 1ì´ headë¥¼ ì½ìŒ (ê°’: A)
2. Thread 2ê°€ Aë¥¼ popí•˜ê³  Bë¥¼ popí•˜ê³  Aë¥¼ ë‹¤ì‹œ push
3. Thread 1ì˜ CASê°€ ì„±ê³µ (headê°€ ì—¬ì „íˆ Aì´ë¯€ë¡œ)
   í•˜ì§€ë§Œ ì‹¤ì œë¡œëŠ” ë‹¤ë¥¸ A!

í•´ê²°ì±…: ë²„ì „ ì¹´ìš´í„°ë‚˜ hazard pointer ì‚¬ìš©
*/

#include <atomic>
#include <cstdint>

template<typename T>
class TaggedPointer {
private:
    struct Pointer {
        T* ptr;
        std::uint64_t tag;
    };
    
    std::atomic<Pointer> data;

public:
    void set(T* ptr, std::uint64_t tag) {
        data.store({ptr, tag}, std::memory_order_release);
    }
    
    bool compare_exchange(T*& expected_ptr, T* new_ptr, 
                         std::uint64_t& expected_tag, std::uint64_t new_tag) {
        Pointer expected{expected_ptr, expected_tag};
        Pointer desired{new_ptr, new_tag};
        
        if (data.compare_exchange_strong(expected, desired)) {
            return true;
        }
        
        expected_ptr = expected.ptr;
        expected_tag = expected.tag;
        return false;
    }
};
```
  
</br>  
  
  
## ë©”ëª¨ë¦¬ ìˆœì„œ ìš”ì•½ ë‹¤ì´ì–´ê·¸ë¨

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ë©”ëª¨ë¦¬ ìˆœì„œ ì‚¬ìš© ê°€ì´ë“œ                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  ìˆœì°¨ ì¼ê´€ì„± (Sequentially Consistent)                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚  â”‚ memory_order_seq_cst (ê¸°ë³¸ê°’)       â”‚                      â”‚
â”‚  â”‚ - ê°€ì¥ ê°•í•œ ë³´ì¥                     â”‚                      â”‚
â”‚  â”‚ - ëª¨ë“  ìŠ¤ë ˆë“œê°€ ë™ì¼í•œ ìˆœì„œ ê´€ì°°       â”‚                      â”‚
â”‚  â”‚ - ì„±ëŠ¥ ì˜¤ë²„í—¤ë“œ ìˆìŒ                 â”‚                       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚                                                              â”‚
â”‚  íšë“-í•´ì œ (Acquire-Release)                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚  â”‚ memory_order_acquire (load)        â”‚                     â”‚
â”‚  â”‚ memory_order_release (store)       â”‚                     â”‚
â”‚  â”‚ memory_order_acq_rel (read-modify) â”‚                     â”‚
â”‚  â”‚ - ìƒì‚°ì-ì†Œë¹„ì íŒ¨í„´ì— ì í•©            â”‚                     â”‚
â”‚  â”‚ - ë°ì´í„° ì˜ì¡´ì„± ë³´í˜¸                  â”‚                     â”‚
â”‚  â”‚ - ê· í˜•ì¡íŒ ì„±ëŠ¥                      â”‚                     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
â”‚                                                             â”‚
â”‚  ì™„í™”ëœ ìˆœì„œ (Relaxed)                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚  â”‚ memory_order_relaxed               â”‚                     â”‚
â”‚  â”‚ - ì›ìì„±ë§Œ ë³´ì¥                      â”‚                     â”‚
â”‚  â”‚ - ìˆœì„œ ë³´ì¥ ì—†ìŒ                     â”‚                     â”‚
â”‚  â”‚ - ìµœê³  ì„±ëŠ¥                         â”‚                     â”‚
â”‚  â”‚ - ì¹´ìš´í„° ë“± ë‹¨ìˆœ ì—°ì‚°ì— ì í•©           â”‚                     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```
  
</br>  


## ì •ë¦¬
`std::atomic`ì€ C++ ë©€í‹°ìŠ¤ë ˆë“œ í”„ë¡œê·¸ë˜ë°ì˜ í•µì‹¬ ë„êµ¬ì´ë‹¤. ì£¼ìš” í¬ì¸íŠ¸ë¥¼ ì •ë¦¬í•˜ë©´:

**í•µì‹¬ ê°œë…**:
- ì›ìì  ì—°ì‚°ì€ ì¤‘ë‹¨ ë¶ˆê°€ëŠ¥í•œ ë‹¨ì¼ ì—°ì‚°
- ë°ì´í„° ë ˆì´ìŠ¤ ë°©ì§€ì™€ ë©”ëª¨ë¦¬ ë™ê¸°í™” ì œê³µ
- Lock-free í”„ë¡œê·¸ë˜ë°ì˜ ê¸°ë°˜

**ì–¸ì œ ì‚¬ìš©í•˜ë‚˜**:
- ë‹¨ì¼ ë³€ìˆ˜ì˜ ê°„ë‹¨í•œ ì—°ì‚° (ì¹´ìš´í„°, í”Œë˜ê·¸)
- ê³ ì„±ëŠ¥ì´ í•„ìš”í•œ ìƒí™©
- Lock-free ìë£Œêµ¬ì¡° êµ¬í˜„

**ì£¼ì˜ì‚¬í•­**:
- ë³µì‚¬ ë¶ˆê°€, load()ë¡œ ê°’ ì½ê¸°
- ì ì ˆí•œ ë©”ëª¨ë¦¬ ìˆœì„œ ì„ íƒ
- is_lock_free() í™•ì¸
- ABA ë¬¸ì œ ê³ ë ¤

**ì„±ëŠ¥**:
- atomic < spinlock < mutex (ì¼ë°˜ì ìœ¼ë¡œ)
- í•˜ì§€ë§Œ ì‚¬ìš© ì‚¬ë¡€ì— ë”°ë¼ ë‹¤ë¦„
- ë²¤ì¹˜ë§ˆí¬ë¡œ í™•ì¸ í•„ìˆ˜

  
ë‹¤ìŒ í‘œëŠ” C++ì˜ ì£¼ìš” `std::atomic` APIë¥¼ ëª©ì ê³¼ ê°„ë‹¨í•œ ì‚¬ìš© ì˜ˆë¡œ ì •ë¦¬í•œ ê²ƒì´ë‹¤. ê¸°ë³¸ ë©”ëª¨ë¦¬ ìˆœì„œëŠ” `memory_order::seq_cst`ì´ë©°, í•„ìš” ì‹œ ê° ì—°ì‚°ì˜ ë§ˆì§€ë§‰ ì¸ìë¡œ `memory_order`ë¥¼ ì§€ì •í•˜ë©´ ëœë‹¤.
  
### í•µì‹¬ atomic ì—°ì‚°

| API                                      | ëª©ì                     | ê°„ë‹¨í•œ ì‚¬ìš© ì˜ˆ                                                            | ë¹„ê³                                            |                      |
| ---------------------------------------- | --------------------- | ------------------------------------------------------------------- | -------------------------------------------- | -------------------- |
| `std::atomic<T>`                         | ì›ìì ìœ¼ë¡œ ì½ê¸°/ì“°ê¸° ê°€ëŠ¥í•œ ë³€ìˆ˜ ì •ì˜ | `std::atomic<int> a{0};`                                            | ëŒ€ë¶€ë¶„ì˜ Trivially copyable íƒ€ì…ì—ì„œ ì‚¬ìš© ê°€ëŠ¥í•˜ë‹¤         |                      |
| `is_lock_free()`                         | ì ê¸ˆ ì—†ì´ êµ¬í˜„ë˜ëŠ”ì§€ í™•ì¸        | `a.is_lock_free();`                                                 | ì„±ëŠ¥ íŠ¹ì„± íŒë‹¨ì— ì‚¬ìš©í•œë‹¤                               |                      |
| `load()`                                 | ì›ìì ìœ¼ë¡œ ì½ê¸°              | `int v = a.load();`                                                 | `a.load(memory_order_acquire);`ì²˜ëŸ¼ ìˆœì„œ ì§€ì • ê°€ëŠ¥í•˜ë‹¤ |                      |
| `store()`                                | ì›ìì ìœ¼ë¡œ ì“°ê¸°              | `a.store(42);`                                                      | `a.store(42, memory_order_release);` ê°€ëŠ¥í•˜ë‹¤    |                      |
| `exchange()`                             | ìƒˆ ê°’ ì €ì¥í•˜ê³  ì´ì „ ê°’ ë°˜í™˜      | `int old = a.exchange(1);`                                          | ìŠ¤ì™‘ í˜•íƒœë¡œ ìì£¼ ì‚¬ìš©í•œë‹¤                               |                      |
| `compare_exchange_strong()`              | ê¸°ëŒ€ê°’ê³¼ ê°™ìœ¼ë©´ ìƒˆ ê°’ìœ¼ë¡œ êµì²´     | `int exp=0; a.compare_exchange_strong(exp, 1);`                     | ì‹¤íŒ¨ ì‹œ `exp`ê°€ ì‹¤ì œ ê°’ìœ¼ë¡œ ê°±ì‹ ëœë‹¤                      |                      |
| `compare_exchange_weak()`                | ì•½í•œ CAS, ìŠ¤í¼ë¦¬ì–´ìŠ¤ ì‹¤íŒ¨ í—ˆìš©   | ë°˜ë³µë¬¸ê³¼ í•¨ê»˜ ì‚¬ìš©í•œë‹¤ â†’ `while(!a.compare_exchange_weak(exp, 1)) /*retry*/;` | ë£¨í”„ì—ì„œ ë” ë¹ ë¥¼ ìˆ˜ ìˆë‹¤                               |                      |
| `fetch_add() / fetch_sub()`              | ë”í•˜ê³ /ë¹¼ê³  ì´ì „ ê°’ ë°˜í™˜        | `int old = a.fetch_add(2);`                                         | ì •ìˆ˜Â·í¬ì¸í„°ì—ì„œ ì‚¬ìš©í•œë‹¤                                |                      |
| `fetch_and() / fetch_or() / fetch_xor()` | ë¹„íŠ¸ ì—°ì‚° í›„ ì´ì „ ê°’ ë°˜í™˜       | `flags.fetch_or(0x01);`                                             | í”Œë˜ê·¸ í† ê¸€ì— ìœ ìš©í•˜ë‹¤                                 |                      |
| `++/--, +=/-=, &=/                       | =/^=`                 | ì—°ì‚°ì ì˜¤ë²„ë¡œë“œ ì œê³µ                                                         | `++a; a += 4;`                               | ë‚´ë¶€ì ìœ¼ë¡œ fetch ê³„ì—´ì„ ì‚¬ìš©í•œë‹¤ |

### ë™ê¸°í™”Â·ëŒ€ê¸° ê´€ë ¨(C++20~)

| API              | ëª©ì                        | ê°„ë‹¨í•œ ì‚¬ìš© ì˜ˆ                                                                     | ë¹„ê³                |
| ---------------- | ------------------------ | ---------------------------------------------------------------------------- | ---------------- |
| `wait(expected)` | ê°’ì´ `expected`ì™€ ë‹¤ë¥¼ ë•Œê¹Œì§€ ëŒ€ê¸° | `a.store(0); std::jthread t([&]{ a.store(1); a.notify_one(); }); a.wait(0);` | ìœ ì € ê³µê°„ ëŒ€ê¸°ë¼ íš¨ìœ¨ì ì´ë‹¤  |
| `notify_one()`   | í•˜ë‚˜ì˜ ëŒ€ê¸° ìŠ¤ë ˆë“œ ê¹¨ìš°ê¸°           | `a.notify_one();`                                                            | `wait`ê³¼ ìŒìœ¼ë¡œ ì‚¬ìš©í•œë‹¤ |
| `notify_all()`   | ëª¨ë“  ëŒ€ê¸° ìŠ¤ë ˆë“œ ê¹¨ìš°ê¸°            | `a.notify_all();`                                                            | ë¸Œë¡œë“œìºìŠ¤íŠ¸ì— ì‚¬ìš©í•œë‹¤     |

### ë©”ëª¨ë¦¬ íœìŠ¤

| API                               | ëª©ì               | ê°„ë‹¨í•œ ì‚¬ìš© ì˜ˆ                                               | ë¹„ê³                  |
| --------------------------------- | --------------- | ------------------------------------------------------ | ------------------ |
| `std::atomic_thread_fence(order)` | ìŠ¤ë ˆë“œ ê°„ ë©”ëª¨ë¦¬ ìˆœì„œ ê°•ì œ | `std::atomic_thread_fence(std::memory_order_release);` | ì›ì ì—°ì‚°ê³¼ í•¨ê»˜ ìˆœì„œë§Œ ë³´ì¥í•œë‹¤ |
| `std::atomic_signal_fence(order)` | ì»´íŒŒì¼ëŸ¬ ì¬ì •ë ¬ë§Œ ì œí•œ    | `std::atomic_signal_fence(std::memory_order_acq_rel);` | í•˜ë“œì›¨ì–´ íœìŠ¤ëŠ” ì•„ë‹ˆë‹¤       |

### `atomic_flag`(ìµœì†Œ ë½Â·í…ŒìŠ¤íŠ¸ì•¤ë“œì…‹)

| API                | ëª©ì               | ê°„ë‹¨í•œ ì‚¬ìš© ì˜ˆ                                                        | ë¹„ê³            |
| ------------------ | --------------- | --------------------------------------------------------------- | ------------ |
| `std::atomic_flag` | ê°€ì¥ ë‹¨ìˆœí•œ ë½ í”„ë¦¬ í”Œë˜ê·¸ | `std::atomic_flag f = ATOMIC_FLAG_INIT;`                        | í•­ìƒ ë½ í”„ë¦¬ë‹¤     |
| `test_and_set()`   | 1ë¡œ ì„¤ì •í•˜ë©° ì´ì „ ê°’ ë°˜í™˜ | `while(f.test_and_set(std::memory_order_acquire)) { /*spin*/ }` | ìŠ¤í•€ë½ êµ¬í˜„ì— ì‚¬ìš©í•œë‹¤ |
| `clear()`          | 0ìœ¼ë¡œ í´ë¦¬ì–´         | `f.clear(std::memory_order_release);`                           | ë½ í•´ì œ ì—­í• ì„ í•œë‹¤  |

### ê·¸ ë°–ì˜ ìœ ìš©í•œ ìš”ì†Œ

| API                    | ëª©ì                | ê°„ë‹¨í•œ ì‚¬ìš© ì˜ˆ                                                      | ë¹„ê³                         |
| ---------------------- | ---------------- | ------------------------------------------------------------- | ------------------------- |
| `std::atomic_ref<T>`   | ê¸°ì¡´ ê°ì²´ë¥¼ ì›ìì ìœ¼ë¡œ ë‹¤ë£¨ê¸° | `int x=0; std::atomic_ref<int> ar{x}; ar.fetch_add(1);`       | C++20ë¶€í„° ì§€ì›í•œë‹¤              |
| í¬ì¸í„° íŠ¹ìˆ˜í™”                | í¬ì¸í„°ì— ëŒ€í•œ ì‚°ìˆ        | `std::atomic<int*> p{buf}; p.fetch_add(1);`                   | ìš”ì†Œ í¬ê¸°ë§Œí¼ ì¦ê°€í•œë‹¤              |
| ë¶€ìš¸ ì›ì                  | í”Œë˜ê·¸ ë™ê¸°í™”          | `std::atomic<bool> ready{false};`                             | `wait/notify`ì™€ í•¨ê»˜ ì“°ë©´ ê¹”ë”í•˜ë‹¤ |
| ë©”ëª¨ë¦¬ ìˆœì„œ(`memory_order`) | ìˆœì„œ ì œì–´ ì—´ê±°í˜•        | `relaxed, consume(íì§€ ì˜ˆì •), acquire, release, acq_rel, seq_cst` | ê¸°ë³¸ì€ `seq_cst`ë‹¤            |
