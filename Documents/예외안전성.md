# 예외 안전성 (Exception Safety in Multithreading)

## 멀티스레드 환경에서의 예외 처리

### 예외와 스레드의 관계
멀티스레드 프로그래밍에서 예외 처리는 단일 스레드 환경보다 훨씬 복잡하다. 스레드는 독립적인 실행 흐름을 가지므로, 한 스레드에서 발생한 예외는 다른 스레드로 자동으로 전파되지 않는다. 더욱이, 동기화 객체(뮤텍스, 크리티컬 섹션 등)를 사용하는 도중 예외가 발생하면 락이 해제되지 않아 데드락(deadlock)이 발생할 수 있다.

Win32 API는 C 기반이므로 예외를 던지지 않지만, C++ 코드에서는 `new` 연산자, STL 컨테이너, 사용자 정의 함수 등에서 예외가 발생할 수 있다. 따라서 멀티스레드 환경에서 예외 안전성을 보장하는 것은 필수적이다.

**예외 안전성의 세 가지 수준:**

1. **기본 보장(Basic Guarantee)**: 예외가 발생해도 프로그램의 불변식(invariant)이 유지되고, 리소스 누수가 없다.
2. **강력한 보장(Strong Guarantee)**: 예외가 발생하면 프로그램 상태가 연산 이전 상태로 롤백된다.
3. **예외 없음 보장(No-throw Guarantee)**: 절대 예외를 던지지 않는다.
  
#### 불변식의 개념
객체는 자신의 상태(state)를 여러 멤버 변수로 표현한다.
이때 “정상적인 상태”로 간주되기 위해 항상 만족해야 하는 규칙들이 있다.
예를 들어, 다음과 같은 클래스가 있다고 하자.

```cpp
class Stack {
    std::vector<int> data;
    int topIndex;
};
```

이 `Stack` 클래스의 불변식은 다음과 같이 정의될 수 있다.

* `0 <= topIndex <= data.size()`
* `data`는 항상 유효한 메모리를 가리켜야 한다.

즉, 프로그램이 정상적으로 동작하려면 언제나 이 불변식이 유지되어야 한다.

#### “불변식이 유지된다”의 의미
**예외가 발생하더라도 객체가 여전히 정상적인(일관된) 상태에 있다는 뜻이다.**
예외가 던져진 이후에도 객체의 내부 데이터가 불합리한 상태로 망가져 있지 않음을 의미한다.

예를 들어, `push()` 도중 메모리 할당 예외가 발생했더라도:

* `Stack`의 `data` 벡터는 여전히 유효해야 하고,
* `topIndex` 값이 `data.size()`를 벗어나면 안 된다.

즉, “작업이 실패하더라도 객체는 여전히 쓸 수 있는 상태로 남아 있다”는 것이 불변식 유지의 핵심이다.

> “불변식이 유지된다”는 말은 예외가 발생하더라도 프로그램(또는 객체)이 **정상적이고 일관된 내부 상태를 보존한다**는 의미다.
> 즉, 깨진 상태로 방치되어 나중에 더 큰 오류를 일으키는 일이 없다는 뜻이다.
  
  
  
### 멀티스레드에서의 예외 처리 문제점
다음 코드는 예외 안전성이 보장되지 않는 전형적인 예시다:

```cpp
#include <windows.h>
#include <iostream>
#include <vector>

CRITICAL_SECTION g_cs;
std::vector<int> g_sharedData;

DWORD WINAPI UnsafeThread(LPVOID lpParam) {
    try {
        EnterCriticalSection(&g_cs);
        
        // 메모리 할당 중 예외 발생 가능
        g_sharedData.resize(1000000000); // 메모리 부족으로 예외 발생 가능
        
        LeaveCriticalSection(&g_cs);
    }
    catch (const std::exception& e) {
        std::cerr << "예외 발생: " << e.what() << std::endl;
        // 문제: 크리티컬 섹션이 해제되지 않음!
        return 1;
    }
    return 0;
}

int main() {
    InitializeCriticalSection(&g_cs);
    
    HANDLE hThread = CreateThread(NULL, 0, UnsafeThread, NULL, 0, NULL);
    
    if (hThread) {
        WaitForSingleObject(hThread, INFINITE);
        CloseHandle(hThread);
    }
    
    DeleteCriticalSection(&g_cs);
    return 0;
}
```

이 코드의 문제점:
- `resize()` 에서 예외가 발생하면 `LeaveCriticalSection()`이 호출되지 않는다.
- 크리티컬 섹션이 잠긴 상태로 남아 다른 스레드가 영원히 대기하게 된다.
- 프로그램이 데드락 상태에 빠진다.
  

## RAII를 활용한 예외 안전성 보장

### RAII (Resource Acquisition Is Initialization) 개념
RAII는 C++의 핵심 디자인 패턴으로, 리소스의 획득과 해제를 객체의 생성자와 소멸자에 묶는 기법이다. 객체가 스코프를 벗어나면 자동으로 소멸자가 호출되므로, 예외가 발생해도 리소스가 안전하게 해제된다.

**RAII의 장점:**
- 예외가 발생해도 리소스 누수가 없다.
- 코드가 간결하고 가독성이 높다.
- 실수로 리소스 해제를 빠뜨릴 위험이 없다.

### 크리티컬 섹션 RAII 래퍼 구현
다음은 크리티컬 섹션을 RAII 패턴으로 감싸는 클래스다:

```cpp
#include <windows.h>
#include <iostream>
#include <vector>
#include <stdexcept>

// 크리티컬 섹션 RAII 래퍼
class CriticalSectionLock {
private:
    CRITICAL_SECTION& cs_;
    bool locked_;

public:
    // 생성자에서 락 획득
    explicit CriticalSectionLock(CRITICAL_SECTION& cs) 
        : cs_(cs), locked_(false) {
        EnterCriticalSection(&cs_);
        locked_ = true;
    }

    // 소멸자에서 락 해제
    ~CriticalSectionLock() {
        if (locked_) {
            LeaveCriticalSection(&cs_);
        }
    }

    // 복사 방지 (C++11)
    CriticalSectionLock(const CriticalSectionLock&) = delete;
    CriticalSectionLock& operator=(const CriticalSectionLock&) = delete;

    // 이동 생성자 (C++11)
    CriticalSectionLock(CriticalSectionLock&& other) noexcept
        : cs_(other.cs_), locked_(other.locked_) {
        other.locked_ = false;
    }

    // 수동 해제 (필요한 경우)
    void unlock() {
        if (locked_) {
            LeaveCriticalSection(&cs_);
            locked_ = false;
        }
    }
};

// 크리티컬 섹션 관리 클래스
class CriticalSectionWrapper {
private:
    CRITICAL_SECTION cs_;

public:
    CriticalSectionWrapper() {
        InitializeCriticalSection(&cs_);
    }

    ~CriticalSectionWrapper() {
        DeleteCriticalSection(&cs_);
    }

    // 복사 방지
    CriticalSectionWrapper(const CriticalSectionWrapper&) = delete;
    CriticalSectionWrapper& operator=(const CriticalSectionWrapper&) = delete;

    CRITICAL_SECTION& get() { return cs_; }
};

// 전역 데이터
CriticalSectionWrapper g_csWrapper;
std::vector<int> g_sharedData;

DWORD WINAPI SafeThread(LPVOID lpParam) {
    try {
        // RAII로 자동 락 관리
        CriticalSectionLock lock(g_csWrapper.get());
        
        std::cout << "스레드 " << GetCurrentThreadId() 
                  << ": 크리티컬 섹션 진입" << std::endl;
        
        // 예외가 발생할 수 있는 작업
        if (reinterpret_cast<int>(lpParam) == 1) {
            throw std::runtime_error("의도적인 예외 발생");
        }
        
        g_sharedData.push_back(GetCurrentThreadId());
        Sleep(1000);
        
        std::cout << "스레드 " << GetCurrentThreadId() 
                  << ": 작업 완료" << std::endl;
        
        // lock 객체가 스코프를 벗어나면 자동으로 LeaveCriticalSection 호출
    }
    catch (const std::exception& e) {
        std::cerr << "스레드 " << GetCurrentThreadId() 
                  << " 예외: " << e.what() << std::endl;
        // 크리티컬 섹션은 자동으로 해제됨
        return 1;
    }
    return 0;
}

int main() {
    std::cout << "=== RAII 기반 예외 안전 스레드 실행 ===" << std::endl;
    
    HANDLE threads[3];
    
    // 첫 번째 스레드는 정상 실행
    threads[0] = CreateThread(NULL, 0, SafeThread, 
                              reinterpret_cast<LPVOID>(0), 0, NULL);
    
    // 두 번째 스레드는 예외 발생
    threads[1] = CreateThread(NULL, 0, SafeThread, 
                              reinterpret_cast<LPVOID>(1), 0, NULL);
    
    // 세 번째 스레드는 정상 실행 (두 번째 스레드의 예외에 영향받지 않음)
    threads[2] = CreateThread(NULL, 0, SafeThread, 
                              reinterpret_cast<LPVOID>(0), 0, NULL);
    
    // 모든 스레드 대기
    WaitForMultipleObjects(3, threads, TRUE, INFINITE);
    
    for (int i = 0; i < 3; ++i) {
        CloseHandle(threads[i]);
    }
    
    std::cout << "\n공유 데이터 크기: " << g_sharedData.size() << std::endl;
    std::cout << "프로그램 정상 종료 (데드락 없음)" << std::endl;
    
    return 0;
}
```

**코드 설명:**

1. `CriticalSectionLock` 클래스는 생성자에서 `EnterCriticalSection()`을, 소멸자에서 `LeaveCriticalSection()`을 호출한다.
2. 예외가 발생해도 스택 언와인딩(stack unwinding) 과정에서 소멸자가 자동으로 호출된다.
3. `CriticalSectionWrapper`는 크리티컬 섹션의 초기화와 삭제를 자동화한다.
4. 두 번째 스레드에서 예외가 발생해도 세 번째 스레드는 정상적으로 크리티컬 섹션에 진입할 수 있다.

### 뮤텍스 RAII 래퍼 구현
Win32 뮤텍스도 동일한 방식으로 RAII 패턴을 적용할 수 있다:

```cpp
#include <windows.h>
#include <iostream>
#include <string>

// 뮤텍스 RAII 래퍼
class MutexLock {
private:
    HANDLE hMutex_;
    bool locked_;

public:
    explicit MutexLock(HANDLE hMutex, DWORD timeout = INFINITE)
        : hMutex_(hMutex), locked_(false) {
        
        DWORD result = WaitForSingleObject(hMutex_, timeout);
        
        if (result == WAIT_OBJECT_0) {
            locked_ = true;
        }
        else if (result == WAIT_TIMEOUT) {
            throw std::runtime_error("뮤텍스 획득 타임아웃");
        }
        else if (result == WAIT_ABANDONED) {
            // 이전 소유 스레드가 뮤텍스를 해제하지 않고 종료
            locked_ = true; // 뮤텍스는 획득되지만 경고 필요
            std::cerr << "경고: 버려진 뮤텍스 획득" << std::endl;
        }
        else {
            throw std::runtime_error("뮤텍스 획득 실패");
        }
    }

    ~MutexLock() {
        if (locked_) {
            ReleaseMutex(hMutex_);
        }
    }

    // 복사 방지
    MutexLock(const MutexLock&) = delete;
    MutexLock& operator=(const MutexLock&) = delete;

    bool isLocked() const { return locked_; }
};

// 뮤텍스 관리 클래스
class MutexWrapper {
private:
    HANDLE hMutex_;

public:
    explicit MutexWrapper(const char* name = nullptr) {
        hMutex_ = CreateMutexA(NULL, FALSE, name);
        if (!hMutex_) {
            throw std::runtime_error("뮤텍스 생성 실패");
        }
    }

    ~MutexWrapper() {
        if (hMutex_) {
            CloseHandle(hMutex_);
        }
    }

    // 복사 방지
    MutexWrapper(const MutexWrapper&) = delete;
    MutexWrapper& operator=(const MutexWrapper&) = delete;

    HANDLE get() const { return hMutex_; }
};

// 공유 리소스
MutexWrapper g_mutex;
int g_counter = 0;

DWORD WINAPI WorkerThread(LPVOID lpParam) {
    int threadId = reinterpret_cast<int>(lpParam);
    
    try {
        for (int i = 0; i < 5; ++i) {
            // RAII로 뮤텍스 자동 관리
            MutexLock lock(g_mutex.get());
            
            std::cout << "스레드 " << threadId << ": 카운터 증가 전 = " 
                      << g_counter << std::endl;
            
            // 예외가 발생할 수 있는 시뮬레이션
            if (threadId == 2 && i == 2) {
                throw std::runtime_error("스레드 2에서 예외 발생");
            }
            
            ++g_counter;
            Sleep(100);
            
            // lock이 스코프를 벗어나면 자동으로 뮤텍스 해제
        }
    }
    catch (const std::exception& e) {
        std::cerr << "스레드 " << threadId << " 오류: " 
                  << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}

int main() {
    std::cout << "=== 뮤텍스 RAII 예제 ===" << std::endl;
    
    HANDLE threads[3];
    
    for (int i = 0; i < 3; ++i) {
        threads[i] = CreateThread(NULL, 0, WorkerThread, 
                                  reinterpret_cast<LPVOID>(i + 1), 0, NULL);
    }
    
    WaitForMultipleObjects(3, threads, TRUE, INFINITE);
    
    for (int i = 0; i < 3; ++i) {
        CloseHandle(threads[i]);
    }
    
    std::cout << "\n최종 카운터 값: " << g_counter << std::endl;
    
    return 0;
}
```

### 세마포어 RAII 래퍼
세마포어도 동일한 패턴으로 구현할 수 있다:

```cpp
#include <windows.h>
#include <iostream>
#include <vector>

// 세마포어 RAII 래퍼
class SemaphoreLock {
private:
    HANDLE hSemaphore_;
    bool acquired_;

public:
    explicit SemaphoreLock(HANDLE hSemaphore, DWORD timeout = INFINITE)
        : hSemaphore_(hSemaphore), acquired_(false) {
        
        DWORD result = WaitForSingleObject(hSemaphore_, timeout);
        
        if (result == WAIT_OBJECT_0) {
            acquired_ = true;
        }
        else if (result == WAIT_TIMEOUT) {
            throw std::runtime_error("세마포어 획득 타임아웃");
        }
        else {
            throw std::runtime_error("세마포어 획득 실패");
        }
    }

    ~SemaphoreLock() {
        if (acquired_) {
            ReleaseSemaphore(hSemaphore_, 1, NULL);
        }
    }

    SemaphoreLock(const SemaphoreLock&) = delete;
    SemaphoreLock& operator=(const SemaphoreLock&) = delete;
};

// 세마포어 관리 클래스
class SemaphoreWrapper {
private:
    HANDLE hSemaphore_;

public:
    SemaphoreWrapper(LONG initialCount, LONG maxCount) {
        hSemaphore_ = CreateSemaphore(NULL, initialCount, maxCount, NULL);
        if (!hSemaphore_) {
            throw std::runtime_error("세마포어 생성 실패");
        }
    }

    ~SemaphoreWrapper() {
        if (hSemaphore_) {
            CloseHandle(hSemaphore_);
        }
    }

    SemaphoreWrapper(const SemaphoreWrapper&) = delete;
    SemaphoreWrapper& operator=(const SemaphoreWrapper&) = delete;

    HANDLE get() const { return hSemaphore_; }
};

// 제한된 리소스 풀 (최대 3개의 스레드만 동시 접근)
SemaphoreWrapper g_resourcePool(3, 3);

DWORD WINAPI ResourceUser(LPVOID lpParam) {
    int threadId = reinterpret_cast<int>(lpParam);
    
    try {
        std::cout << "스레드 " << threadId << ": 리소스 대기 중..." << std::endl;
        
        // RAII로 세마포어 자동 관리 (타임아웃 5초)
        SemaphoreLock lock(g_resourcePool.get(), 5000);
        
        std::cout << "스레드 " << threadId << ": 리소스 획득!" << std::endl;
        
        // 리소스 사용 시뮬레이션
        Sleep(2000);
        
        // 의도적인 예외 발생 시뮬레이션
        if (threadId == 4) {
            throw std::runtime_error("작업 중 오류 발생");
        }
        
        std::cout << "스레드 " << threadId << ": 작업 완료" << std::endl;
        
        // lock이 스코프를 벗어나면 자동으로 세마포어 해제
    }
    catch (const std::exception& e) {
        std::cerr << "스레드 " << threadId << " 예외: " 
                  << e.what() << std::endl;
        // 세마포어는 자동으로 해제됨
        return 1;
    }
    
    return 0;
}

int main() {
    std::cout << "=== 세마포어 RAII 예제 (최대 3개 동시 접근) ===" << std::endl;
    
    const int NUM_THREADS = 6;
    HANDLE threads[NUM_THREADS];
    
    // 6개의 스레드 생성 (3개씩 번갈아가며 실행됨)
    for (int i = 0; i < NUM_THREADS; ++i) {
        threads[i] = CreateThread(NULL, 0, ResourceUser, 
                                  reinterpret_cast<LPVOID>(i + 1), 0, NULL);
        Sleep(200); // 스레드 생성 간격
    }
    
    WaitForMultipleObjects(NUM_THREADS, threads, TRUE, INFINITE);
    
    for (int i = 0; i < NUM_THREADS; ++i) {
        CloseHandle(threads[i]);
    }
    
    std::cout << "\n모든 스레드 완료" << std::endl;
    
    return 0;
}
```
  

## noexcept 지정자를 활용한 성능 최적화

### noexcept의 개념과 중요성
C++11에서 도입된 `noexcept` 지정자는 함수가 예외를 던지지 않음을 명시적으로 선언한다. 이는 단순한 문서화 도구가 아니라 컴파일러 최적화와 직접적으로 연관된다.

**noexcept의 장점:**

1. **컴파일러 최적화**: 컴파일러가 예외 처리 코드를 생성하지 않아 성능이 향상된다.
2. **STL 최적화**: STL 컨테이너가 이동 생성자를 안전하게 사용할 수 있다.
3. **명확한 계약**: 함수의 예외 보장 수준을 명확히 한다.

**noexcept와 예외 발생:**
- `noexcept` 함수에서 예외가 발생하면 **`std::terminate()`가 호출되어 프로그램이 즉시 종료**된다.
- 따라서 `noexcept`는 절대 예외를 던지지 않는 함수에만 사용해야 한다.

### 스레드 함수에서의 noexcept 활용
스레드의 최상위 함수는 예외를 밖으로 던져서는 안 되므로, 내부에서 모든 예외를 처리해야 한다:

```cpp
#include <windows.h>
#include <iostream>
#include <exception>
#include <atomic>

// 스레드 안전 카운터
std::atomic<int> g_successCount(0);
std::atomic<int> g_failureCount(0);

// noexcept 지정된 스레드 래퍼 함수
DWORD WINAPI SafeThreadWrapper(LPVOID lpParam) noexcept {
    try {
        int threadId = reinterpret_cast<int>(lpParam);
        
        std::cout << "스레드 " << threadId << " 시작" << std::endl;
        
        // 실제 작업 수행
        for (int i = 0; i < 10; ++i) {
            // 예외가 발생할 수 있는 작업
            if (threadId == 3 && i == 5) {
                throw std::runtime_error("의도적인 예외");
            }
            
            Sleep(100);
        }
        
        ++g_successCount;
        std::cout << "스레드 " << threadId << " 성공" << std::endl;
        return 0;
    }
    catch (const std::exception& e) {
        ++g_failureCount;
        std::cerr << "스레드 예외 포착: " << e.what() << std::endl;
        return 1;
    }
    catch (...) {
        ++g_failureCount;
        std::cerr << "알 수 없는 예외 포착" << std::endl;
        return 2;
    }
}

int main() {
    std::cout << "=== noexcept 스레드 래퍼 예제 ===" << std::endl;
    
    const int NUM_THREADS = 5;
    HANDLE threads[NUM_THREADS];
    
    for (int i = 0; i < NUM_THREADS; ++i) {
        threads[i] = CreateThread(NULL, 0, SafeThreadWrapper, 
                                  reinterpret_cast<LPVOID>(i + 1), 0, NULL);
    }
    
    WaitForMultipleObjects(NUM_THREADS, threads, TRUE, INFINITE);
    
    for (int i = 0; i < NUM_THREADS; ++i) {
        CloseHandle(threads[i]);
    }
    
    std::cout << "\n=== 실행 결과 ===" << std::endl;
    std::cout << "성공: " << g_successCount << std::endl;
    std::cout << "실패: " << g_failureCount << std::endl;
    
    return 0;
}
```

### 이동 생성자와 noexcept
STL 컨테이너는 `noexcept` 이동 생성자를 가진 타입에 대해서만 이동 연산을 사용하고, 그렇지 않으면 복사 연산을 사용한다. 이는 예외 안전성을 보장하기 위함이다:

```cpp
#include <windows.h>
#include <iostream>
#include <vector>
#include <string>

// 예외 안전한 스레드 데이터 클래스
class ThreadData {
private:
    int* data_;
    size_t size_;
    std::string name_;

public:
    ThreadData(size_t size, const std::string& name)
        : data_(new int[size]), size_(size), name_(name) {
        std::cout << "ThreadData 생성: " << name_ << std::endl;
    }

    // 소멸자는 noexcept (암묵적)
    ~ThreadData() {
        delete[] data_;
        std::cout << "ThreadData 소멸: " << name_ << std::endl;
    }

    // 복사 생성자 (예외 발생 가능)
    ThreadData(const ThreadData& other)
        : data_(new int[other.size_]), size_(other.size_), name_(other.name_) {
        std::cout << "복사 생성: " << name_ << std::endl;
        std::copy(other.data_, other.data_ + size_, data_);
    }

    // 이동 생성자 (noexcept 지정으로 최적화)
    ThreadData(ThreadData&& other) noexcept
        : data_(other.data_), size_(other.size_), name_(std::move(other.name_)) {
        std::cout << "이동 생성: " << name_ << std::endl;
        other.data_ = nullptr;
        other.size_ = 0;
    }

    // 복사 대입 연산자
    ThreadData& operator=(const ThreadData& other) {
        if (this != &other) {
            std::cout << "복사 대입: " << other.name_ << std::endl;
            delete[] data_;
            data_ = new int[other.size_];
            size_ = other.size_;
            name_ = other.name_;
            std::copy(other.data_, other.data_ + size_, data_);
        }
        return *this;
    }

    // 이동 대입 연산자 (noexcept)
    ThreadData& operator=(ThreadData&& other) noexcept {
        if (this != &other) {
            std::cout << "이동 대입: " << other.name_ << std::endl;
            delete[] data_;
            data_ = other.data_;
            size_ = other.size_;
            name_ = std::move(other.name_);
            other.data_ = nullptr;
            other.size_ = 0;
        }
        return *this;
    }

    const std::string& getName() const { return name_; }
};

CRITICAL_SECTION g_cs;
std::vector<ThreadData> g_dataQueue;

DWORD WINAPI ProducerThread(LPVOID lpParam) noexcept {
    try {
        int threadId = reinterpret_cast<int>(lpParam);
        
        for (int i = 0; i < 3; ++i) {
            // ThreadData 생성 (이동 생성자 사용)
            ThreadData data(1000, "Thread-" + std::to_string(threadId) + 
                                  "-Data-" + std::to_string(i));
            
            {
                CriticalSectionLock lock(g_cs);
                
                // vector에 추가 시 noexcept 이동 생성자 사용
                g_dataQueue.push_back(std::move(data));
                std::cout << "데이터 추가됨" << std::endl;
            }
            
            Sleep(500);
        }
        
        return 0;
    }
    catch (const std::exception& e) {
        std::cerr << "Producer 예외: " << e.what() << std::endl;
        return 1;
    }
    catch (...) {
        std::cerr << "알 수 없는 예외" << std::endl;
        return 2;
    }
}

// RAII 락 (이전 예제에서 사용한 클래스)
class CriticalSectionLock {
private:
    CRITICAL_SECTION& cs_;
    bool locked_;

public:
    explicit CriticalSectionLock(CRITICAL_SECTION& cs) 
        : cs_(cs), locked_(false) {
        EnterCriticalSection(&cs_);
        locked_ = true;
    }

    ~CriticalSectionLock() {
        if (locked_) {
            LeaveCriticalSection(&cs_);
        }
    }

    CriticalSectionLock(const CriticalSectionLock&) = delete;
    CriticalSectionLock& operator=(const CriticalSectionLock&) = delete;
};

int main() {
    std::cout << "=== noexcept 이동 생성자 최적화 예제 ===" << std::endl;
    std::cout << "이동 생성자가 호출되면 복사가 아닌 이동이 발생합니다.\n" << std::endl;
    
    InitializeCriticalSection(&g_cs);
    
    const int NUM_THREADS = 2;
    HANDLE threads[NUM_THREADS];
    
    for (int i = 0; i < NUM_THREADS; ++i) {
        threads[i] = CreateThread(NULL, 0, ProducerThread, 
                                  reinterpret_cast<LPVOID>(i + 1), 0, NULL);
    }
    
    WaitForMultipleObjects(NUM_THREADS, threads, TRUE, INFINITE);
    
    for (int i = 0; i < NUM_THREADS; ++i) {
        CloseHandle(threads[i]);
    }
    
    std::cout << "\n=== 최종 큐 상태 ===" << std::endl;
    std::cout << "큐에 저장된 데이터 개수: " << g_dataQueue.size() << std::endl;
    
    for (const auto& data : g_dataQueue) {
        std::cout << "  - " << data.getName() << std::endl;
    }
    
    DeleteCriticalSection(&g_cs);
    
    return 0;
}
```

### 조건부 noexcept
`noexcept` 지정자는 조건부로 사용할 수 있다. 이는 템플릿 프로그래밍에서 특히 유용하다:

```cpp
#include <windows.h>
#include <iostream>
#include <type_traits>
#include <atomic>

// 스레드 안전 스왑 함수 (조건부 noexcept)
template<typename T>
void threadSafeSwap(T& a, T& b, CRITICAL_SECTION& cs) 
    noexcept(std::is_nothrow_move_constructible<T>::value &&
             std::is_nothrow_move_assignable<T>::value) {
    
    EnterCriticalSection(&cs);
    
    // T의 이동 연산이 noexcept면 이 함수도 noexcept
    T temp = std::move(a);
    a = std::move(b);
    b = std::move(temp);
    
    LeaveCriticalSection(&cs);
}

// noexcept 이동 연산을 가진 타입
struct SafeData {
    int value;
    
    SafeData(int v = 0) : value(v) {}
    
    SafeData(SafeData&& other) noexcept 
        : value(other.value) {
        other.value = 0;
    }
    
    SafeData& operator=(SafeData&& other) noexcept {
        value = other.value;
        other.value = 0;
        return *this;
    }
};

// 예외를 던질 수 있는 이동 연산을 가진 타입
struct UnsafeData {
    int* ptr;
    
    UnsafeData(int v = 0) : ptr(new int(v)) {}
    
    ~UnsafeData() { delete ptr; }
    
    // 이동 생성자가 noexcept가 아님
    UnsafeData(UnsafeData&& other) 
        : ptr(other.ptr) {
        other.ptr = nullptr;
    }
    
    UnsafeData& operator=(UnsafeData&& other) {
        delete ptr;
        ptr = other.ptr;
        other.ptr = nullptr;
        return *this;
    }
};

CRITICAL_SECTION g_cs;

int main() {
    InitializeCriticalSection(&g_cs);
    
    std::cout << "=== 조건부 noexcept 예제 ===" << std::endl;
    
    SafeData s1(10), s2(20);
    UnsafeData u1(100), u2(200);
    
    std::cout << "SafeData swap은 noexcept? " 
              << noexcept(threadSafeSwap(s1, s2, g_cs)) << std::endl;
    
    std::cout << "UnsafeData swap은 noexcept? " 
              << noexcept(threadSafeSwap(u1, u2, g_cs)) << std::endl;
    
    threadSafeSwap(s1, s2, g_cs);
    std::cout << "SafeData swap 후: s1=" << s1.value 
              << ", s2=" << s2.value << std::endl;
    
    threadSafeSwap(u1, u2, g_cs);
    std::cout << "UnsafeData swap 후: u1=" << *u1.ptr 
              << ", u2=" << *u2.ptr << std::endl;
    
    DeleteCriticalSection(&g_cs);
    
    return 0;
}
```
  


## 실전 예제: 예외 안전한 생산자-소비자 큐
이제 지금까지 배운 모든 개념을 통합한 실전 예제를 살펴보자. 완전한 예외 안전성을 보장하는 스레드 안전 큐를 구현한다:  

```cpp
#include <windows.h>
#include <iostream>
#include <queue>
#include <memory>
#include <exception>
#include <string>

// RAII 기반 크리티컬 섹션 래퍼
class CriticalSectionWrapper {
private:
    CRITICAL_SECTION cs_;

public:
    CriticalSectionWrapper() {
        InitializeCriticalSection(&cs_);
    }

    ~CriticalSectionWrapper() {
        DeleteCriticalSection(&cs_);
    }

    CriticalSectionWrapper(const CriticalSectionWrapper&) = delete;
    CriticalSectionWrapper& operator=(const CriticalSectionWrapper&) = delete;

    void lock() { EnterCriticalSection(&cs_); }
    void unlock() { LeaveCriticalSection(&cs_); }
    CRITICAL_SECTION& get() { return cs_; }
};

// RAII 락 가드
class LockGuard {
private:
    CriticalSectionWrapper& cs_;

public:
    explicit LockGuard(CriticalSectionWrapper& cs) : cs_(cs) {
        cs_.lock();
    }

    ~LockGuard() noexcept {
        cs_.unlock();
    }

    LockGuard(const LockGuard&) = delete;
    LockGuard& operator=(const LockGuard&) = delete;
};

// 예외 안전한 스레드 안전 큐
template<typename T>
class ThreadSafeQueue {
private:
    std::queue<T> queue_;
    CriticalSectionWrapper cs_;
    HANDLE hNotEmpty_;
    HANDLE hNotFull_;
    size_t maxSize_;
    bool shutdown_;

public:
    explicit ThreadSafeQueue(size_t maxSize = 100)
        : maxSize_(maxSize), shutdown_(false) {
        
        hNotEmpty_ = CreateEvent(NULL, FALSE, FALSE, NULL);
        hNotFull_ = CreateEvent(NULL, FALSE, TRUE, NULL);
        
        if (!hNotEmpty_ || !hNotFull_) {
            if (hNotEmpty_) CloseHandle(hNotEmpty_);
            if (hNotFull_) CloseHandle(hNotFull_);
            throw std::runtime_error("이벤트 생성 실패");
        }
    }

    ~ThreadSafeQueue() noexcept {
        shutdown_ = true;
        SetEvent(hNotEmpty_);
        SetEvent(hNotFull_);
        CloseHandle(hNotEmpty_);
        CloseHandle(hNotFull_);
    }

    // 복사 방지
    ThreadSafeQueue(const ThreadSafeQueue&) = delete;
    ThreadSafeQueue& operator=(const ThreadSafeQueue&) = delete;

    // 큐에 데이터 추가 (예외 안전 보장)
    bool push(const T& item, DWORD timeout = INFINITE) {
        // 큐가 가득 찰 때까지 대기
        while (true) {
            {
                LockGuard lock(cs_);
                
                if (shutdown_) {
                    return false;
                }
                
                if (queue_.size() < maxSize_) {
                    try {
                        queue_.push(item);
                        SetEvent(hNotEmpty_);
                        
                        if (queue_.size() >= maxSize_) {
                            ResetEvent(hNotFull_);
                        }
                        
                        return true;
                    }
                    catch (...) {
                        // 예외 발생 시에도 이벤트 상태는 일관성 유지
                        throw;
                    }
                }
            }
            
            // 락을 해제한 상태에서 대기
            DWORD result = WaitForSingleObject(hNotFull_, timeout);
            if (result == WAIT_TIMEOUT) {
                return false;
            }
            if (shutdown_) {
                return false;
            }
        }
    }

    // 이동 버전 push (noexcept 이동 생성자를 가진 타입에 최적화)
    bool push(T&& item, DWORD timeout = INFINITE) {
        while (true) {
            {
                LockGuard lock(cs_);
                
                if (shutdown_) {
                    return false;
                }
                
                if (queue_.size() < maxSize_) {
                    try {
                        queue_.push(std::move(item));
                        SetEvent(hNotEmpty_);
                        
                        if (queue_.size() >= maxSize_) {
                            ResetEvent(hNotFull_);
                        }
                        
                        return true;
                    }
                    catch (...) {
                        throw;
                    }
                }
            }
            
            DWORD result = WaitForSingleObject(hNotFull_, timeout);
            if (result == WAIT_TIMEOUT) {
                return false;
            }
            if (shutdown_) {
                return false;
            }
        }
    }

    // 큐에서 데이터 추출 (예외 안전 보장)
    bool pop(T& item, DWORD timeout = INFINITE) {
        while (true) {
            {
                LockGuard lock(cs_);
                
                if (shutdown_ && queue_.empty()) {
                    return false;
                }
                
                if (!queue_.empty()) {
                    try {
                        item = std::move(queue_.front());
                        queue_.pop();
                        SetEvent(hNotFull_);
                        
                        if (queue_.empty()) {
                            ResetEvent(hNotEmpty_);
                        }
                        
                        return true;
                    }
                    catch (...) {
                        throw;
                    }
                }
            }
            
            DWORD result = WaitForSingleObject(hNotEmpty_, timeout);
            if (result == WAIT_TIMEOUT) {
                return false;
            }
        }
    }

    // 큐 크기 반환 (noexcept)
    size_t size() const noexcept {
        LockGuard lock(const_cast<CriticalSectionWrapper&>(cs_));
        return queue_.size();
    }

    // 종료 신호
    void shutdown() noexcept {
        LockGuard lock(cs_);
        shutdown_ = true;
        SetEvent(hNotEmpty_);
        SetEvent(hNotFull_);
    }
};

// 작업 데이터 구조체
struct WorkItem {
    int id;
    std::string description;
    
    WorkItem(int i = 0, const std::string& desc = "")
        : id(i), description(desc) {}
    
    // noexcept 이동 생성자
    WorkItem(WorkItem&& other) noexcept
        : id(other.id), description(std::move(other.description)) {
        other.id = 0;
    }
    
    WorkItem& operator=(WorkItem&& other) noexcept {
        id = other.id;
        description = std::move(other.description);
        other.id = 0;
        return *this;
    }
};

ThreadSafeQueue<WorkItem> g_workQueue(10);

// 생산자 스레드 (noexcept 보장)
DWORD WINAPI ProducerThread(LPVOID lpParam) noexcept {
    try {
        int producerId = reinterpret_cast<int>(lpParam);
        
        for (int i = 0; i < 15; ++i) {
            WorkItem item(producerId * 100 + i, 
                         "Producer " + std::to_string(producerId) + 
                         " - Item " + std::to_string(i));
            
            if (g_workQueue.push(std::move(item), 5000)) {
                std::cout << "Producer " << producerId 
                          << " pushed item " << i << std::endl;
            }
            else {
                std::cerr << "Producer " << producerId 
                          << " timeout on item " << i << std::endl;
            }
            
            Sleep(100 + (rand() % 200));
        }
        
        std::cout << "Producer " << producerId << " finished" << std::endl;
        return 0;
    }
    catch (const std::exception& e) {
        std::cerr << "Producer exception: " << e.what() << std::endl;
        return 1;
    }
    catch (...) {
        std::cerr << "Producer unknown exception" << std::endl;
        return 2;
    }
}

// 소비자 스레드 (noexcept 보장)
DWORD WINAPI ConsumerThread(LPVOID lpParam) noexcept {
    try {
        int consumerId = reinterpret_cast<int>(lpParam);
        
        while (true) {
            WorkItem item;
            
            if (g_workQueue.pop(item, 2000)) {
                std::cout << "Consumer " << consumerId 
                          << " processing: " << item.description << std::endl;
                
                // 작업 처리 시뮬레이션
                Sleep(150 + (rand() % 150));
            }
            else {
                // 타임아웃 - 큐가 비어있거나 종료 신호
                if (g_workQueue.size() == 0) {
                    std::cout << "Consumer " << consumerId 
                              << " timeout, checking for more work..." << std::endl;
                }
            }
            
            // 큐가 비어있고 일정 시간 대기했으면 종료
            static int emptyCount = 0;
            if (g_workQueue.size() == 0) {
                if (++emptyCount > 5) break;
            }
            else {
                emptyCount = 0;
            }
        }
        
        std::cout << "Consumer " << consumerId << " finished" << std::endl;
        return 0;
    }
    catch (const std::exception& e) {
        std::cerr << "Consumer exception: " << e.what() << std::endl;
        return 1;
    }
    catch (...) {
        std::cerr << "Consumer unknown exception" << std::endl;
        return 2;
    }
}

int main() {
    std::cout << "=== 예외 안전한 생산자-소비자 큐 예제 ===" << std::endl;
    std::cout << "큐 최대 크기: 10\n" << std::endl;
    
    const int NUM_PRODUCERS = 2;
    const int NUM_CONSUMERS = 3;
    
    HANDLE producers[NUM_PRODUCERS];
    HANDLE consumers[NUM_CONSUMERS];
    
    // 소비자 스레드 생성
    for (int i = 0; i < NUM_CONSUMERS; ++i) {
        consumers[i] = CreateThread(NULL, 0, ConsumerThread, 
                                    reinterpret_cast<LPVOID>(i + 1), 0, NULL);
    }
    
    // 생산자 스레드 생성
    for (int i = 0; i < NUM_PRODUCERS; ++i) {
        producers[i] = CreateThread(NULL, 0, ProducerThread, 
                                    reinterpret_cast<LPVOID>(i + 1), 0, NULL);
    }
    
    // 생산자 완료 대기
    WaitForMultipleObjects(NUM_PRODUCERS, producers, TRUE, INFINITE);
    std::cout << "\n모든 생산자 완료" << std::endl;
    
    // 소비자가 남은 작업 처리할 시간 제공
    Sleep(5000);
    
    // 큐 종료 신호
    g_workQueue.shutdown();
    
    // 소비자 완료 대기
    WaitForMultipleObjects(NUM_CONSUMERS, consumers, TRUE, INFINITE);
    std::cout << "모든 소비자 완료" << std::endl;
    
    // 핸들 정리
    for (int i = 0; i < NUM_PRODUCERS; ++i) {
        CloseHandle(producers[i]);
    }
    for (int i = 0; i < NUM_CONSUMERS; ++i) {
        CloseHandle(consumers[i]);
    }
    
    std::cout << "\n프로그램 정상 종료 (예외 안전성 보장됨)" << std::endl;
    
    return 0;
}
```

  

## 연습 문제

### 연습 문제 1: RAII 기반 이벤트 래퍼
Win32 이벤트 객체에 대한 RAII 래퍼를 작성하시오. 생성자에서 이벤트를 생성하고, 소멸자에서 자동으로 핸들을 닫도록 구현하라. 예외가 발생해도 리소스 누수가 없어야 한다.

**요구사항:**
- 자동/수동 리셋 이벤트 모두 지원
- 복사 방지, 이동 지원
- `wait()`, `signal()`, `reset()` 메서드 제공

### 연습 문제 2: 예외 안전한 리소스 풀
제한된 수의 리소스를 관리하는 스레드 안전 리소스 풀을 구현하시오. 세마포어를 사용하여 동시 접근을 제한하고, RAII 패턴으로 자동 반환을 보장하라.

**요구사항:**
- 최대 N개의 리소스 동시 사용 제한
- 리소스 획득 시 자동 반환을 보장하는 RAII 핸들 반환
- 타임아웃 지원
- 예외 발생 시에도 리소스 반환 보장

### 연습 문제 3: 조건부 noexcept 템플릿 함수
두 개의 스레드 안전 컨테이너 간에 데이터를 교환하는 템플릿 함수를 작성하시오. 타입 T의 이동 연산이 noexcept인 경우에만 함수도 noexcept가 되도록 구현하라.

**요구사항:**
- `std::is_nothrow_move_constructible` 활용
- 크리티컬 섹션으로 보호
- 강력한 예외 안전성 보장


## 요약
이 장에서는 멀티스레드 환경에서의 예외 안전성을 다루었다:

1. **예외 안전성의 중요성**: 멀티스레드 환경에서 예외가 발생하면 락이 해제되지 않아 데드락이 발생할 수 있다.

2. **RAII 패턴**: 리소스 획득과 해제를 객체의 생성자와 소멸자에 묶어 예외가 발생해도 자동으로 리소스를 해제한다.

3. **동기화 객체 래퍼**: 크리티컬 섹션, 뮤텍스, 세마포어 등을 RAII 패턴으로 감싸면 예외 안전성이 보장된다.

4. **noexcept 지정자**: 함수가 예외를 던지지 않음을 명시하여 컴파일러 최적화를 가능하게 하고, STL과의 효율적인 상호작용을 지원한다.

5. **스레드 함수의 예외 처리**: 최상위 스레드 함수는 모든 예외를 내부에서 처리하고 noexcept로 선언해야 한다.

6. **조건부 noexcept**: 템플릿에서 타입 특성에 따라 조건부로 noexcept를 지정할 수 있다.

예외 안전성은 견고한 멀티스레드 프로그램을 작성하는 데 필수적이다. RAII 패턴과 noexcept를 적절히 활용하면 예외 발생 시에도 프로그램의 안정성과 성능을 보장할 수 있다.  
